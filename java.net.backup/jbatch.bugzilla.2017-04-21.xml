<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<!DOCTYPE bugzilla SYSTEM "https://java.net/bugzilla/page.cgi?id=bugzilla.dtd">

<bugzilla version="4.4.11"
          urlbase="https://java.net/bugzilla/"
          
          maintainer="site-admin@java.net"
>

    <bug>
          <bug_id>4834</bug_id>
          
          <creation_ts>2013-03-24 19:02:00 +0000</creation_ts>
          <short_desc>SPEC - JobExecution handed to JobOperator client &quot;by reference&quot; or &quot;by value&quot;?</short_desc>
          <delta_ts>2015-10-01 13:47:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13041</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-24 19:02:24 +0000</bug_when>
    <thetext>If I do this for a running job:		

  JobExecution exec = jo.getJobExecution(execId);

Do I see, in this &apos;exec&apos; object, the updates as the job executes (e.g. BatchStatus getting set)? 

Or am I only getting a snapshot, and might I need to get a new one to see the ongoing execution?  

I.e. does the container have a reference (PBR) back to this JobExecution or is it taking a snapshot of the &quot;value&quot; (PBV)?

Since the spec has no remotable use cases... you might think it should maintain a reference.  

I don&apos;t think the TCK requires PBR behavior.. I think we ask for a new object each time we want to check the status whether we need to or not.

Since there are no setters on JobExecution, JobInstance, it seems PBR would have no undesirable side effects...

I think it should be spec&apos;d and not left to the implementation, since it is a very basic aspect of the JobOperator programming model.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13042</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-24 19:53:29 +0000</bug_when>
    <thetext>The JobExecution should be viewed as a value object with no guarantees of it&apos;s ties to a running job.  jo.getJobExecution(execId) may return a previously run JobExecution as an example.   Also, with regards to the &quot;no remoteable use cases&quot;, while the spec does not address remote executions, it does not preclude them either (there is nothing to prevent a user from developing a RemoteJobOperator implementation of the JobOperator interface for example).  

I don&apos;t think we can say within the spec that the JobExecution returned by the JobOperator is the same instance being acted upon by an executing job.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13052</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-26 02:22:56 +0000</bug_when>
    <thetext>(In reply to comment #1)
Michael,

I agree with your angle on this one, which then leads me to the question of should the spec say that is is by value, e.g. that

  JobExecution exec = jo.getJobExecution(execId);
  JobExecution exec2 = jo.getJobExecution(execId);

return different instances?

Since there&apos;s no setters maybe it doesn&apos;t matter. 

Te RI uses &quot;by-reference&quot; for a currently-executed job and &quot;by-value&quot; for a terminated job.

The TCK assumes &quot;by-value&quot;, e.g. in the polling routine we get a new JobExecution each time we poll rather than rechecking status on the existing.   But it doesn&apos;t require &quot;by-value&quot; either (obviously since the RI doesn&apos;t always use it).

I guess it could be left as an implementation detail.   The only code I can conjure up where it matters woul be:

// JobOperator &quot;monitor&quot;

while (..running..) {
  JobExecution exec = jo.getJobExecution(execId);
  logMonitorEntry(exec)
}

// now go process logged executions

-------------------

If I have PBR then instead of a list of &quot;snapshots&quot; I&apos;m going to get a bunch of copies of the execution in its final state.   

Specifying PBV &quot;breaks&quot; the RI though...however, we could adjust still I believe.   Maybe it would be a clearer API to just specify &quot;by value&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14022</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 15:07:46 +0000</bug_when>
    <thetext>Leaving it open that a spec clarification might be desirable.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14367</commentid>
    <comment_count>4</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2013-10-28 07:51:31 +0000</bug_when>
    <thetext>I&apos;m not sure if this is settled but can I put in a vote for the spec and TCK to be changed to allow JobExecution, StepExecution &amp;&amp; JobInstance to be value classes.

The way I see it these values are tied to the the implementation of the job repository and requiring these classes to provide an up to date view of the repository will add unnecessary performance penalties to some implementations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14461</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-04 22:26:56 +0000</bug_when>
    <thetext>This hasn&apos;t been settled, so thanks Brent too for your comments.

I had another thought in this area: that the spec might say that  StepExecution#getPersistentUserData() is returned by value.

The way the RI is currently coded, it&apos;s theoretically possible for an operator to introduce side effects to the persistent user data that then affect say a Decider operating on the StepExecution.

We might also consider waiting to see if it turns out to be a real-world issue, since it might not be too likely someone would do that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14467</commentid>
    <comment_count>6</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-11-04 22:59:19 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #5)
&gt; This hasn&apos;t been settled, so thanks Brent too for your comments.
&gt; 
&gt; I had another thought in this area: that the spec might say that 
&gt; StepExecution#getPersistentUserData() is returned by value.
&gt; 
&gt; The way the RI is currently coded, it&apos;s theoretically possible for an
&gt; operator to introduce side effects to the persistent user data that then
&gt; affect say a Decider operating on the StepExecution.
&gt; 
&gt; We might also consider waiting to see if it turns out to be a real-world
&gt; issue, since it might not be too likely someone would do that.

By exposing only java.io.Serializable to the client, the expectation is the client should not modify it. 

I think it&apos;s more likely application itself (which knows the actual type of the user data) will use getPersistentUserData() to pass data between differnet parts, and the apps may expect the returned object is by reference.  StepContext.getPersistentUserData() and StepExecution.getPersistentUserData should be consistent in this regard.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14469</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-04 23:41:58 +0000</bug_when>
    <thetext>(In reply to cf126330 from comment #6)
&gt; StepContext.getPersistentUserData() and
&gt; StepExecution.getPersistentUserData should be consistent in this regard.

Cheng, I agree with everything up until this last sentence, but wasn&apos;t sure where you were trying to end up.

You seemed to think that StepContext returns the persistent data by-reference and StepExecution returns it by-value, but then what did you mean in saying they should be &quot;consistent&quot;?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14470</commentid>
    <comment_count>8</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-11-05 02:39:40 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #7)
&gt; (In reply to cf126330 from comment #6)
&gt; &gt; StepContext.getPersistentUserData() and
&gt; &gt; StepExecution.getPersistentUserData should be consistent in this regard.
&gt; 
&gt; Cheng, I agree with everything up until this last sentence, but wasn&apos;t sure
&gt; where you were trying to end up.
&gt; 
&gt; You seemed to think that StepContext returns the persistent data
&gt; by-reference and StepExecution returns it by-value, but then what did you
&gt; mean in saying they should be &quot;consistent&quot;?

Application can access persistent user data via StepContext, and a job client can access persistent user data via StepExecution. So whether we settle on by-reference or by-value, the same rule should apply to both StepContext.getPersistentUserData() and StepExecution.getPersistentUserData(). I think by-reference is a better fit.  If an application is really concerned with the risk of persistent user data being modified by a job client, it can choose immutable or unmodifiable types for persistent data.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14471</commentid>
    <comment_count>9</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-05 03:39:59 +0000</bug_when>
    <thetext>I strongly think this should be by value (per my previous statements).  One thing to keep in mind is that the StepExecution and JobExecution may not retrieved within the same JVM as the job actually executing.  I could have a Job running in JVM 1 and use the JobOperator to retrieve the current state of the job from the job repository in JVM 2.  How would this work if it was pass by reference and the expectation was that modifications to the data by the client in JVM 2 was to impact JVM 1?  Allowing the client to modify the StepExecution/JobExecution in a way that the runtime is expected to react is a dangerous path IMHO.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15136</commentid>
    <comment_count>10</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 13:12:32 +0000</bug_when>
    <thetext>Not committing to address in future, just listing as candidates and pointing out they&apos;re excluded from current Maintenance Rel.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5075</bug_id>
          
          <creation_ts>2013-06-08 00:31:00 +0000</creation_ts>
          <short_desc>Injecting JobOperator</short_desc>
          <delta_ts>2015-10-01 13:47:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>arungupta</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>atsticks</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>reza_rahman</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13466</commentid>
    <comment_count>0</comment_count>
    <who name="">arungupta</who>
    <bug_when>2013-06-08 00:31:21 +0000</bug_when>
    <thetext>JobOperator jo = BatchRuntime.getJobOperator();

does not align very well with the CDI-way of doing things in Java EE 7.

A better way would be:

@Inject JobOperator jo;

This request has been asked multiple times at different conferences around the world.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13468</commentid>
    <comment_count>1</comment_count>
    <who name="">atsticks</who>
    <bug_when>2013-06-08 17:03:05 +0000</bug_when>
    <thetext>I also think batch must integrate with cdi asap.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13469</commentid>
    <comment_count>2</comment_count>
    <who name="">reza_rahman</who>
    <bug_when>2013-06-08 17:15:23 +0000</bug_when>
    <thetext>+1 for me.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14388</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 14:58:19 +0000</bug_when>
    <thetext>In Spring this would be handled with a FactoryBean.  Couldn&apos;t this just be handled with a Producer without the need to add CDI specific language to the spec?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14389</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-29 15:03:59 +0000</bug_when>
    <thetext>So say we were to take the same approach as we did with injecting the properties and contexts, and say that the API was:

@Inject JobOperator jobOp 

without specifying whether it&apos;s CDI, or some other DI.

How would that then fit with the Spring approach?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14390</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 15:24:13 +0000</bug_when>
    <thetext>With Spring Batch&apos;s implementation of the JSR, we have a FactoryBean that creates the Job/Step contexts to handle the @Inject scenario.  I understand how @Inject for the JobOperator looks in the EE world.  How does this proposal work in the SE world?  Right now, all of the @Inject requirements still work in the SE world.  This one is a bit different since the JobOperator is the entrance point for a batch application and probably provides/needs some bootstrapping.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5382</bug_id>
          
          <creation_ts>2013-09-11 14:56:00 +0000</creation_ts>
          <short_desc>Support common java types in @BatchProperty injection</short_desc>
          <delta_ts>2015-10-08 13:54:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>jrperkinsjr</cc>
    
    <cc>rmannibucau</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14124</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-09-11 14:56:48 +0000</bug_when>
    <thetext>Currently only java.lang.String is supported in @BatchProperty field injection.  For other types of data, applications have to convert from String.  I propose we support all common java types for @BatchProperty field injections, to make batch api easier to use.  A related bug was Bug 4353.

We don&apos;t need to change the job xml schema, where properties are still declared as string values.  The batch container is responsible for data conversion behind the scene.  For example,

@BatchProperty
private int count;

A list of common java types pertaining to batch API:

all primitive types (int, short, byte, long, double, float, boolean, char)
array of all primitive types
wrapper type of all primitive types
array of all wrapper types of primitive types
List&lt;String&gt;
Map&lt;String, String&gt;
Set&lt;String&gt;
BigInteger
BitDecimal
java.util.Date
java.io.File
java.util.jar.JarFile
java.util.regex.Pattern
URL
URI
Inet4Address
Inet6Address
java.util.logging.Logger
java.lang.Class</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19197</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-10 17:44:34 +0000</bug_when>
    <thetext>Getting back to this.  

I like the idea.. just wondering 
A) precisely which ones to include/exclude
B) How to reference the specifics of each type of conversion (without having to define it in the batch spec itself).   Not that it would be that hard to do so in our spec..just wondering if this was already defined.

E.g. it seems BatchEE accomplishes this using
 org.apache.xbean.propertyeditor.PropertyEditors

http://geronimo.apache.org/maven/xbean/3.6/xbean-reflect/apidocs/org/apache/xbean/propertyeditor/package-tree.html

---

I wonder where that would leave JSONObject ?   Not as easy as I&apos;m naively assuming for some reason or just didn&apos;t happen to be in that list?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19246</commentid>
    <comment_count>2</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-24 21:51:11 +0000</bug_when>
    <thetext>Most probably something like github.com/tomitribe/sabot mecanism (same idea as JAXRS with its fromString or constructor handling) would match very well, I agree.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19271</commentid>
    <comment_count>3</comment_count>
    <who name="">jrperkinsjr</who>
    <bug_when>2015-09-29 20:53:30 +0000</bug_when>
    <thetext>I think the spec should only guarantee that primitives (and their Object types), String, BigDecimal and BigInteger the allowed injection types. Maybe primitive arrays too. Implementations can implement more providers for other types if they&apos;d like.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19318</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-08 13:54:02 +0000</bug_when>
    <thetext>Seems kind of arbitrary to pick the set beyond the primitives, I agree...

I guess another direction to take this in is to model after JSF Converter, and define some built-in converters and the opportunity for custom converters.

Since JSF and JPA each have a bit different converters, seems like the precedent would be set for batch to define its own.

Would need to be clear if this is part of CDI integration or DI-neutral.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5383</bug_id>
          
          <creation_ts>2013-09-11 15:30:00 +0000</creation_ts>
          <short_desc>Support @PostConstruct and @PreDestroy callbacks in batch artifacts</short_desc>
          <delta_ts>2016-03-24 14:39:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>thomas_haines</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14125</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-09-11 15:30:26 +0000</bug_when>
    <thetext>PostConstruct and PreDestroy callbacks enable applications to influence how batch container manages batch artifact lifecycles.  Both classes are in already Java SE 6:

http://docs.oracle.com/javase/6/docs/api/javax/annotation/PostConstruct.html
http://docs.oracle.com/javase/6/docs/api/javax/annotation/PreDestroy.html

For example,

@PostConstruct
private void checkData() throws BatchRuntimeException {
  //make sure all injected properties are in place and valid.
  //do the necessary data conversion from string properties to other types
  //or consolidate several properties into 1
  //or other initialization work
}

@PreDestroy
void cleanUp() {
  //clean up 
}

Currently there is no portable way to perform init and cleanup work in a batch artifact.  So applications have to do it at the beginning of business processing methods, and have to take care to only perform it once.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19856</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-24 14:39:42 +0000</bug_when>
    <thetext>If the batch artifact is loaded via CDI then PostConstruct and PreDestroy will be called.

So it seems the concern would be to standardize this across non-CDI artifact loading.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5386</bug_id>
          
          <creation_ts>2013-09-11 18:37:00 +0000</creation_ts>
          <short_desc>Consider allowing decision as first execution element within job.</short_desc>
          <delta_ts>2015-10-01 13:47:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14130</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-11 18:37:58 +0000</bug_when>
    <thetext>In reviewing the TCK, I suggested this might be overly restrictive and lifting this restriction worth consideration, and Michael agreed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5416</bug_id>
          
          <creation_ts>2013-09-26 13:53:00 +0000</creation_ts>
          <short_desc>Require artifact loading via CDI when CDI is &quot;available&quot; (beans.xml is present)?</short_desc>
          <delta_ts>2015-10-01 13:47:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>chrisschaefer</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>simas_ch</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14214</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-26 13:53:58 +0000</bug_when>
    <thetext>The JSR 352 specification was developed with the intent to leave open the question of what technology would be used for:

a) dynamic injection - of batch properties and job/step context
b) artifact loading - mapping @ref values to classes and object instances 

In working on the EE TCK (in CTS), we realized the following dilemna:  the presence of beans.xml in the application archive forces the batch runtime to be able to satisfy a) via CDI.

How should the spec be updated to reflect this de facto requirement for CDI support?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14374</commentid>
    <comment_count>1</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-10-28 15:11:36 +0000</bug_when>
    <thetext>Our position from Spring Batch was to ensure that CDI was not the assumption but I was never really happy with how far we swung in saying no assumption about DI.  I had proposed a similar approach to the JSR-107, but cannot recall the details right now.  I&apos;d have to reinvestigate. I&apos;m not for implying CDI as the DI.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14375</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-28 16:04:54 +0000</bug_when>
    <thetext>Wayne,

Again, the core problem is this scenario:  in an EE-environment, if you have a beans.xml in your app archive, then you must be able to satisfy the @Inject for properties and contexts via CDI.   (Not sure if SE has an analogous case with beans.xml or not).   CDI doesn&apos;t care that you wanted to use some other DI technology at that point in your batch app.. you blow up since CDI can&apos;t satisfy the injection.

Yes, another DI could put its own extra burden on the batch implementation, like CDI does, and as you know we have worked to keep the 352 language DI technology-neutral.  
 
But CDI is part of the EE platform... so could a batch implementation really choose to blow up completely just because the batch artifacts are part of a bigger application using CDI?   That&apos;s not very friendly from the EE platform viewpoint.   

That&apos;s where I was headed in wondering if we could &quot;require CDI support for injection when beans.xml is present&quot; (note we wouldn&apos;t necessarily have to require its use for artifact loading, i.e. mapping @ref values to artifact instances).   I&apos;d probably need some help phrasing it correctly from a CDI expert.   Another thing I wondered is if this is really for the EE 7 platform spec to clarify..not for our individual spec (352).

In any case, I&apos;d be curious to hear if you&apos;d developed any new angles (e.g. in JSR 107) that might be helpful in resolving this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14393</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 16:18:24 +0000</bug_when>
    <thetext>It seems to me that we&apos;ve gone down a path that has backfired on us.  The use of @Inject was intended to be a portable way to allow for properties/contexts to be injected.  

What I think Scott is saying is that it, is in fact, not portable and ends up tying us to CDI.  I was already planning on suggesting the removal of the @Inject annotation from properties (it&apos;s redundant to the @BatchProperty annotation).  The only other place the @Inject is used (off the top of my head) is the contexts.  I&apos;d advocate for an update that addresses the injection of contexts without @Inject than require CDI support in any scenario.

As I&apos;ve noted in other issues, the expert group was clear on this.  The spec should not require DI but be open to it&apos;s use.  To not only require DI, but a specific implementation of it goes directly against this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14395</commentid>
    <comment_count>4</comment_count>
    <who name="">simas_ch</who>
    <bug_when>2013-10-29 16:33:40 +0000</bug_when>
    <thetext>I&apos;m currently using the RI in one of my projects. 

My problem is that in the Java EE environment where CDI is present I can use @Named for my artifacts and in the JSL file I use that name as the reference.
I also could use CDI interceptors, decorators etc.

But when my batch runs in Java SE this wouldn&apos;t work. 
Therefor my batch will not be portable anymore.

CDI is based on JSR-330 javax.inject and Google Guice and Spring Framework implement JSR-330.

Could it be an option to allow everything that is in javax.inject?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14396</commentid>
    <comment_count>5</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-10-29 21:22:35 +0000</bug_when>
    <thetext>(In reply to mminella from comment #3)
&gt; It seems to me that we&apos;ve gone down a path that has backfired on us.  The
&gt; use of @Inject was intended to be a portable way to allow for
&gt; properties/contexts to be injected.  
&gt; 
&gt; What I think Scott is saying is that it, is in fact, not portable and ends
&gt; up tying us to CDI.  I was already planning on suggesting the removal of the
&gt; @Inject annotation from properties (it&apos;s redundant to the @BatchProperty
&gt; annotation).  The only other place the @Inject is used (off the top of my
&gt; head) is the contexts.  I&apos;d advocate for an update that addresses the
&gt; injection of contexts without @Inject than require CDI support in any
&gt; scenario.
&gt; 
&gt; As I&apos;ve noted in other issues, the expert group was clear on this.  The spec
&gt; should not require DI but be open to it&apos;s use.  To not only require DI, but
&gt; a specific implementation of it goes directly against this.

+1 on the removal of @Inject annotation from properties already marked w/ @BatchProperty.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14397</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-29 22:05:40 +0000</bug_when>
    <thetext>(In reply to mminella from comment #3)

We&apos;ve collectively spent a lot of time and effort on this nuanced approach to DI, and I don&apos;t see why we now have to throw up our hands.

We had originally failed to recognize, however, that there is such thing as a CDI app, i.e. an EE app archive (someone feel free to state more precisely) that includes beans.xml, that will trigger CDI-managed injection.   

(This case could exist in some form in SE but without CDI in the platform, we don&apos;t have to address it today.)

As it stands, we&apos;ve left open that a 352 impl can inject into a non-CDI Batch application however it sees fit.  There&apos;s no reason to now view this case any differently.

Requiring CDI support for a CDI app, in an EE server that presumably already has support for CDI in general, is a particular case, and I don&apos;t think strays from the original goal of not being unnecessarily tied to CDI.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5432</bug_id>
          
          <creation_ts>2013-10-02 15:15:00 +0000</creation_ts>
          <short_desc>Add getException method to StepExecution interface</short_desc>
          <delta_ts>2015-10-01 13:47:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14241</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-10-02 15:15:54 +0000</bug_when>
    <thetext>StepContext has a getException method:
http://docs.oracle.com/javaee/7/api/javax/batch/runtime/context/StepContext.html

But StepExecution does not:
http://docs.oracle.com/javaee/7/api/javax/batch/runtime/StepExecution.html

Any exception that occurred during a step execution is vital data for a batch client, which can only get hold of StepExecution.  StepContext is intended more for the code running inside batch container, not the client.  So how about adding getException method to StepExecution interface?

A common use is, a batch job monitoring tool shows step execution data in a table:
id, name, batch status, exit status, exception, metrics</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5502</bug_id>
          
          <creation_ts>2013-10-29 13:05:00 +0000</creation_ts>
          <short_desc>Metrics across retry</short_desc>
          <delta_ts>2015-10-01 13:47:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14386</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-29 13:05:53 +0000</bug_when>
    <thetext>I think it was Cheng who pointed out there was some ambiguity as to what metrics should show on a retry.   Consider tightening up the spec by clarifying.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15135</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 13:12:31 +0000</bug_when>
    <thetext>Not committing to address in future, just listing as candidates and pointing out they&apos;re excluded from current Maintenance Rel.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5515</bug_id>
          
          <creation_ts>2013-11-04 04:09:00 +0000</creation_ts>
          <short_desc>Address propagation of contexts (JNDI, classloader?) across threads, in EE</short_desc>
          <delta_ts>2015-10-01 13:47:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14439</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-04 04:09:13 +0000</bug_when>
    <thetext>See public ML discussion:
https://java.net/projects/jbatch/lists/public/archive/2013-10/message/2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5701</bug_id>
          
          <creation_ts>2014-01-10 15:56:00 +0000</creation_ts>
          <short_desc>Support @BatchProperty injection on method, not just field</short_desc>
          <delta_ts>2015-10-01 13:47:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14922</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 15:56:24 +0000</bug_when>
    <thetext>The wording of the spec suggests @BatchProperty is a field, not method injection.

Though actually the Java code snippet pasted suggests support for method injection as well, all the RI fully supports is field injection.

One could argue method injection is a better practice in general, but it should probably at least be an alternative.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5728</bug_id>
          
          <creation_ts>2014-01-20 21:34:00 +0000</creation_ts>
          <short_desc>Section 11 threading requirements for Job&apos;s and Step&apos;s should be relaxed</short_desc>
          <delta_ts>2015-10-01 13:47:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>BrentDouglas</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14986</commentid>
    <comment_count>0</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-01-20 21:34:40 +0000</bug_when>
    <thetext>Job&apos;s must have their before listeners and after listeners invoked in the same thread (11.3). Similarly partitioned Step&apos;s must have various parts invoked in the same thread as the thread as the Step started in (11.5,11.7).

Throughout these sections the main thread per section is referred to as &apos;Thread A&apos; and it runs many of the items. This definition should be relaxed such that items run in &apos;Thread A&apos; occur relative to other numbered items in the diagram with a relationship described as &apos;Happens before with the guarantee of only a single thread run in each item at a time&apos;.

The current &apos;Thread A&apos; definition means that we have a blocked thread for the duration of the job, and more blocked threads for the duration of each partitioned step, and really no convenient way to get around it. This proposal will not cause any issues with that approach but will allow other approaches, such as evented execution (which you could do now, but if &apos;Thread A&apos; from one task got assigned another longer running task that the partitions, a completing task would have to wait for their &apos;Thread A&apos; to be freed before resuming execution, so would not be very useful).


&gt;     &apos;Thread A&apos; ---&gt;                       |-------------&gt; 
&gt;     &apos;Px 1&apos;         |--&gt;
&gt;     &apos;Px 2&apos;         |------&gt;
&gt;     &apos;Other thing&apos;  |---------------------&gt;

FIG.1 If &apos;Thread A&apos; spawns Px1 and Px2, but Thread A gets put back in the pool and gets assigned to &apos;Other thing&apos; from some other job, &apos;Thread A&apos; can&apos;t resume the first job until &apos;Other thing&apos; finishes.


The only downside to this proposal is that clients will no longer be able to use ThreadLocal&apos;s, but realistically, they shouldn&apos;t have been doing that anyhow in managed code and should have been storing things in the Job/Step Context anyway.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14987</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-20 22:49:58 +0000</bug_when>
    <thetext>Brent,

Thanks for writing that up.  It had crossed my mind that we might want to relax this.

Since I don&apos;t see this as a current spec or TCK ambiguity, I&apos;m going to file this with a &quot;future&quot; tag, to look at for a possible future 1.1 release.  Hopefully we can get some other feedback too at that point.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5760</bug_id>
          
          <creation_ts>2014-01-31 16:07:00 +0000</creation_ts>
          <short_desc>Spec should clarify that reader/write close() get called after exceptions</short_desc>
          <delta_ts>2016-06-20 20:47:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15067</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-31 16:07:19 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15093</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-05 15:19:38 +0000</bug_when>
    <thetext>Added &apos;future&apos; to whiteboard to consider idea of extending Closeable in a future release.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15138</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 13:12:33 +0000</bug_when>
    <thetext>Not committing to address in future, just listing as candidates and pointing out they&apos;re excluded from current Maintenance Rel.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16982</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 10:49:31 +0000</bug_when>
    <thetext>As I&apos;m looking back on this now I&apos;m realizing that I got too hung up on the idea that it was too late to start implementing Closeable (with idempotent close()).   We could have still considered saying this was the required behavior even without the interface to enforce this further.

For what it&apos;s worth, I&apos;m almost positive the RI may call close() twice in some cases, for example if the writer close() throws an exception on certain paths we might retry to close both reader and writer.

Noticing this in walking through my fix for Bug 6259.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>20166</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-06-20 20:47:36 +0000</bug_when>
    <thetext>Another thing to clarify:  the diagrams in Section 11, showing reader and writer close() in a single transaction, could lead to some confusion.  E.g. if the writer close() throws an exception, and the tran rolls back, what does this mean for the reader?  Do we still call reader close()?  In what transaction?

This should be clarified.  Note that there are now several close()-related issues open (e.g. Bug 6456, Bug 7684) and it might make sense to tackle them together instead of via the current breakdown.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5776</bug_id>
          
          <creation_ts>2014-02-10 20:37:00 +0000</creation_ts>
          <short_desc>Support StepContext.getJobContext() method</short_desc>
          <delta_ts>2015-10-01 13:47:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15104</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-02-10 20:37:06 +0000</bug_when>
    <thetext>JobContext may contain contextual data a step artifact needs. Currently the only way for a batch artifact to obtain StepContext or JobContext is through injection. So if both stepContext and jobContext are needed, there will be 2 field injections.  It will be nice to be able to retrive JobContext from StepContext on-demand.

@Inject StepContext stepContext;

public Object readItem() {
  if(needToAccessJobContext)
     JobContext jobContext = stepContext.getJobContext();
...
}</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5779</bug_id>
          
          <creation_ts>2014-02-11 19:45:00 +0000</creation_ts>
          <short_desc>Clarify that on restart the &quot;defaults&quot; for the &quot;restartParameters&quot; java.util.Properties object should be used (i.e. that a getProperty is done)</short_desc>
          <delta_ts>2015-10-06 18:09:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15110</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-11 19:45:40 +0000</bug_when>
    <thetext>In DeciderTests#restartJobParameters(), line 683 creates a new set of properties for the restart of the job under test.  Line 684 correctly overwrites a previously set job parameter in the new Properties object.  However, line 685, incorrectly overwrites the job parameter in the old Properties object (not the new one).  Line 685 should read:

restartJobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;None&quot;);

instead of

jobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;None&quot;);</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15114</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-12 03:31:10 +0000</bug_when>
    <thetext>Michael,

Good catch.   I think this error does not affect the test logic though.

The MultipleExitStatusBatchlet looks for this property and returns a special exit status if the value matches the current step name. 

This check is significant since this same batchlet is reused in multiple steps across this job in decider_transitions_from_split_on_restart.xml.

So in failing to do:

  restartJobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;None&quot;);

we essentially did:

  restartJobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, null);

which leads to the same result in the MultipleExitStatusBatchlet logic.   

That is, since there&apos;s no step named &quot;None&quot;,  failing to set it has the same effect as setting it to &quot;None&quot;, even though that was clearly-intended.

--

Will leave this open to eventually clean up next time we do an update, but it shouldn&apos;t affect anyone&apos;s compliance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15116</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-12 05:09:07 +0000</bug_when>
    <thetext>That isn&apos;t correct.  By not doing 

restartJobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;None&quot;);

you are actually doing 

restartJobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;split1flow2step2&quot;);

because on line 683, you copy the parameters from the first run to the second run.  This causes flow2 to end up the same way it did in the first run, breaking the test.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15121</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-12 21:53:42 +0000</bug_when>
    <thetext>For the record, it does impact our compliance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15122</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-12 22:09:11 +0000</bug_when>
    <thetext>(In reply to mminella from comment #2)

Michael,

Yes, I was wrong.  I was incorrectly working backwards from the fact that this test passes for me.

Hmm...I wonder if our JREs are implementing java.util.Properties differently?

Seems the IBM and Oracle JREs I&apos;ve tested with implement the constructor:
 Properties(Properties properties)
WITHOUT doing a clone.

So updating jobParameters &quot;after the fact&quot; 
   jobParameters.setProperty(&quot;stop.job.after.this.step2&quot;, &quot;None&quot;);
still has an effect on restartJobParameters allowing the test to pass.

Maybe you&apos;re using a JRE where this is implemented via a clone of the default properties?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15123</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-12 22:31:09 +0000</bug_when>
    <thetext>Per the java.util.Properties javadoc:

A property list can contain another property list as its &quot;defaults&quot;; this second property list is searched if the property key is not found in the original property list.

The constructor you&apos;re using for this test is the one that specifies the defaults.  So I would expect that if the property isn&apos;t set on the current Properties instance, it would look in the one provided via the constructor and find it there.  What I think the difference is that I&apos;m using Properties.getProperty(&quot;keyName&quot;) and you&apos;re probably using Properties.get(&quot;keyName&quot;).  The latter is really inherited from the Map interface and doesn&apos;t provide the full Properties functionality.  The test case below exhibits that behavior:

	@Test
	public void testProperitesClone() {
		Properties props1 = new Properties();
		props1.put(&quot;key1&quot;, &quot;value1&quot;);
		props1.put(&quot;key2&quot;, &quot;value2&quot;);

		Properties props2 = new Properties(props1);
		assertEquals(&quot;value1&quot;, props2.getProperty(&quot;key1&quot;));
		assertEquals(&quot;value2&quot;, props2.getProperty(&quot;key2&quot;));
		assertNull(props2.get(&quot;key1&quot;));
		assertNull(props2.get(&quot;key2&quot;));
	}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15125</commentid>
    <comment_count>6</comment_count>
    <who name="">kmukher</who>
    <bug_when>2014-02-13 03:32:08 +0000</bug_when>
    <thetext>Michael, I agree that the code in the test is not as clear as it could be. Updating the default Properties list, &quot;jobParameters&quot; after the restartJobParameters constructor makes things a bit confusing. However, I don&apos;t see how this is an issue. 

restartJobParameters.getProperty(&quot;stop.job.after.this.step2&quot;) should still return &quot;None&quot; instead of &quot;split1flow2step2&quot; since it defaults to the Properties list passed into the constructor.

    @Test
    public void testProperitesDefaultingAfterConstructor() {
        Properties props1 = new Properties();
        props1.put(&quot;key1&quot;, &quot;value1&quot;);
        props1.put(&quot;key2&quot;, &quot;value2&quot;);

        Properties props2 = new Properties(props1);
        //override after constructor
        props1.put(&quot;key2&quot;, &quot;value2override&quot;);

        assertEquals(&quot;value1&quot;, props2.getProperty(&quot;key1&quot;));
        assertNotSame(&quot;value2&quot;, props2.getProperty(&quot;key2&quot;));
        assertEquals(&quot;value2override&quot;, props2.getProperty(&quot;key2&quot;));
    }

As Scott mentioned, is it possible that your JRE is performing a clone during  Properties(Properties properties)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15140</commentid>
    <comment_count>7</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-13 15:40:33 +0000</bug_when>
    <thetext>I stand corrected.  It is a bug in our code.  For those reading, if you&apos;re interested, when calling addAll() on a Properties object and passing it another Properties object, the defaults are not brought along.  In our case, we were dropping the defaults when we created the new Properties object to use when restarting a job.  Sorry for the confusion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15141</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 16:27:47 +0000</bug_when>
    <thetext>Thanks for clearing that up.   No problem, sorry for the confusing test parameters.  So let&apos;s tag with &quot;tck_1.0&quot; and come back whenever the next time is we need to do an update.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17769</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-03-03 21:10:37 +0000</bug_when>
    <thetext>Remembering this issue, it occurred to me the spec should explicitly say what this test is expecting, which is that the jobParameters substitution operator is resolved using the java.util.Properties#getProperty(String) method, with its behavior concerning (recursive) defaults.

This is a natural pattern for batch where the previous execution&apos;s Properties serves as the default for the next execution&apos;s.

As we see here the 1.0 TCK already enforces it, so this mention would just to be even more clear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19094</commentid>
    <comment_count>10</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:38:32 +0000</bug_when>
    <thetext>We&apos;d ended up thinking the spec should be clarified, the existing TCK test should be cleaned up, and possibly a new one added.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19304</commentid>
    <comment_count>11</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-06 18:09:10 +0000</bug_when>
    <thetext>Recast summary.  We should say something in the spec and maybe add another test that makes the same point as the one discussed earlier. (And look at this original test to clarify it as well).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5926</bug_id>
          
          <creation_ts>2014-04-01 17:58:00 +0000</creation_ts>
          <short_desc>add attribute to job xml partition element to enable distributed/clustered execution</short_desc>
          <delta_ts>2016-01-13 21:29:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15470</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-04-01 17:58:17 +0000</bug_when>
    <thetext>There should be a portable configuration for apps to enable distributed execution for partitioned steps.  For example,

&lt;partition distributed=&quot;true&quot;&gt;
  &lt;plan ...&gt;&lt;/plan&gt;
  &lt;collector .../&gt;
&lt;/partition&gt;

If the above job is executed in a clustered application server environment, distributed=&apos;true&apos; allows the batch container to allocate partitions to different cluster nodes for execution.

This is similar to the distributable element in web.xml (see http://www.oracle.com/webfolder/technetwork/jsc/xml/ns/javaee/web-app_2_5.xsd)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15471</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-04-01 18:14:23 +0000</bug_when>
    <thetext>Why would we limit this type of functionality to only application server specific use cases?  In Spring Batch we offer an extension point (PartitionHandler: http://docs.spring.io/spring-batch/apidocs/org/springframework/batch/core/partition/PartitionHandler.html) that allows for the ability to distribute partition work in any way the developer sees fit.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15483</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-04-03 02:21:18 +0000</bug_when>
    <thetext>Thanks for the linked resource.  I agree batch clustering should not be tied to application server or Java EE environment.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19610</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-13 21:29:48 +0000</bug_when>
    <thetext>If we were to add this, I could see a case for the default being true... more compatible w/ 1.0 where nothing special was required in some implementations.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6234</bug_id>
          
          <creation_ts>2014-07-14 20:56:00 +0000</creation_ts>
          <short_desc>Add @Documented meta-annotation to BatchProperty definition</short_desc>
          <delta_ts>2014-07-14 20:56:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16339</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-07-14 20:56:38 +0000</bug_when>
    <thetext>When a batch artifact class (e.g., MyItemReader) contains @BatchProperty fields, the @BatchProperty annotation does not appear in the generated javadoc.  Can we add @Documented meta-annotation to BatchProperty definition, so any usage of @BatchProperty will appear in javadoc?

For example,

    @Inject
    @BatchProperty
    protected String queueCapacity;

I want both @Inject and @BatchProperty appear in the javadoc, so readers can know this is a *batch property* injection fields.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6288</bug_id>
          
          <creation_ts>2014-07-30 14:03:00 +0000</creation_ts>
          <short_desc>Consider a beforeStep/afterStep-equivalent that runs on a partition thread.</short_desc>
          <delta_ts>2016-03-30 15:14:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>m_edgar</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16503</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-07-30 14:03:27 +0000</bug_when>
    <thetext>It is a noticeable asymmetry between partitioned and non-partition steps that there is no equivalent to beforeStep/afterStep on the partition thread.

True, the ChunkListener runs on the partition thread, but you don&apos;t have a clear way without inventing one to know it&apos;s the last chunk.   True, the PartitionAnalyzer runs at the end of the partition, but that&apos;s back on the main thread. 

Would be curious to hear other opinions on whether this would be desirable for a future release.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16853</commentid>
    <comment_count>1</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-09-19 02:23:58 +0000</bug_when>
    <thetext>I agree with your comments. The closest fit, as you say, is the ChunkListener. It requires some extra coding to know that it is the final chunk and overall doesn&apos;t feel as clean as a PartitionListener (or extended StepListener) interface would.

That leaves partitioned batchlet steps without any before/after listener options at all. Of course it could be coded/called directly from each batchlet, but I think the listener approach is cleaner.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19886</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-30 15:14:36 +0000</bug_when>
    <thetext>Let me follow-up and propose adding beforePartition/afterPartition to StepListener.

So beforeStep/afterStep will continue to be called only on the top-level thread, and the new beforePartition/afterPartition will only be called on the partition threads.

(Also relevant to keep in mind, the PartitionReducer#beginPartitionedStep/afterPartitionedStepCompletion methods allow for before/after calls as well, and only from the top-level.  Both these and beforeStep/afterStep can continue to be useful in different cases from the top-level.)   

Let&apos;s deal with any other new listener method proposals separately (e.g. https://java.net/bugzilla/show_bug.cgi?id=7374)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6356</bug_id>
          
          <creation_ts>2014-08-26 07:40:00 +0000</creation_ts>
          <short_desc>PartitionAnalyzer transaction boundary on partitioned chunk (and batchlet) step need clarification</short_desc>
          <delta_ts>2015-12-10 14:06:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>fantarama</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>Mobe</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16691</commentid>
    <comment_count>0</comment_count>
    <who name="">fantarama</who>
    <bug_when>2014-08-26 07:40:25 +0000</bug_when>
    <thetext>In section 11.7 actions 6-18 define a transaction that live for the entire duration of all partitions, but in long running scenario this expose the runtime to a transaction timeout exception.

My test case (with jberet implementation) is a partitioned chunk step with 8 partitions. All partitions end in about 30 minutes, transaction timeout occurs after 5 minutes so the runtime throw exception when try to commit (action 18) because the transaction isn&apos;t alive anymore.

May the transaction begin/commit need to be executed for each analyzeCollectorData?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16734</commentid>
    <comment_count>1</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-08-30 12:34:33 +0000</bug_when>
    <thetext>I don&apos;t think your proposal really sits well with the way collectors work.

The spec allows a couple of ways to deal with your issue. The simplest and most portable way is to increase the transaction timeout for your step:

&lt;step id=&quot;HalfHourStep&quot;&gt;
    &lt;properties&gt;
        &lt;property name=&quot;javax.transaction.global.timeout&quot; value=&quot;1800&quot;/&gt;
        ...
    &lt;/properties&gt;
    ...
&lt;/step&gt;

This will increase the timeout for each chunk though.

A less portable way is to ask the JBeret guys to add a property to set the transaction timeout for this transaction individually so you would end up with something like:

&lt;step id=&quot;HalfHourStep&quot;&gt;
    &lt;properties&gt;
        &lt;property name=&quot;javax.transaction.global.timeout&quot; value=&quot;300&quot;/&gt;
        &lt;property name=&quot;org.jberet.transaction.timeout.collector&quot; value=&quot;1800&quot;/&gt;
        ...
    &lt;/properties&gt;
    ...
&lt;/step&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16735</commentid>
    <comment_count>2</comment_count>
    <who name="">fantarama</who>
    <bug_when>2014-08-30 16:54:07 +0000</bug_when>
    <thetext>The workaround is clear, but I report this as a bug because I would like to understand why the spec define this approach.

Transactions are suited for short time atomic operation. The chunk oriented step is a powerful way to handle this aspect, and I agree that is a developer responsibility to handle the transaction timeout, but only for the sigle chunk, not the full step process. In the chunk step I can manage the item count to be sure that transaction will never be greater than a fixed time.

My step work on unfixed size set of data, can goes from 1000 items to over a milion of items. I can&apos;t predict the entire step duration, and I don&apos;t want to do: chunks support checkpoints, but what appened if the analyzer throw exception? It rollback 1h of work?

I think that is wrong to have a transaction that live for the entire step lifecycle, because developer could not handle this pattern.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16736</commentid>
    <comment_count>3</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-08-30 19:29:05 +0000</bug_when>
    <thetext>I don&apos;t really see setting the transaction timeout to 30m when you need to run a 30m transaction as a workaround. A more correct way to deal with it that I wrote before would be something like:

&lt;step id=&quot;HalfHourStep&quot;&gt;
    &lt;properties&gt;
        &lt;property name=&quot;javax.transaction.global.timeout&quot; value=&quot;1800&quot;/&gt;
    &lt;/properties&gt;
    &lt;checkpoint-algorithm ref=&quot;fiveMinutesAndTenUnits&quot;/&gt;
    &lt;chunk  checkpoint-policy=&quot;custom&quot;&gt;

&lt;/step&gt;

@Named(&quot;fiveMinutesAndTenUnits&quot;)
final class FiveMinutesAndTenUnitsCheckpointAlgorithm implements CheckpointAlgorithm {

    private static final int UNITS = 10; //What you would have set the &apos;units&apos; attribute to 

    int current;

    @Override
    public int checkpointTimeout() throws Exception {
        return TimeUnit.SECONDS.toMillis(5);
    }

    @Override
    public void beginCheckpoint() throws Exception {
        current = 0;
    }

    @Override
    public boolean isReadyToCheckpoint() throws Exception {
        if (current &gt; UNITS) {
            throw new IllegalStateException();
        }
        return target == ++current;
    }

    @Override
    public void endCheckpoint() throws Exception {
        //
    }
}


I just noticed a post from Cheng on the forum regarding accessing a DB in an analyzer or collector which I am assuming is the underlying issue you are talking about here. The spec provides a straightforward way to persist data across restarts in the StepContext#setPersistentUserData(Serializable) method. This gets updated at the end of every step regardless of it&apos;s outcome (section 11.7 #21). It will then be loaded when you retry the failed step to complete the unfinished partitions.

If you leave the transaction timeout at 5m for a half hour step you will obviously have to ensure the step&apos;s &apos;start-limit&apos; attribute either not set (unlimited) or set to at least 6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16737</commentid>
    <comment_count>4</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-08-30 19:38:52 +0000</bug_when>
    <thetext>I accidentally posted that before I was finished and can&apos;t work out how to edit the comment. The #checkpointTimeout() method should just return 5 as it is in seconds not millis and the checkpoint-algorithm should be in the unterminated chunk element. It should also say &apos;than I wrote before&apos; on the second line rather than &apos;that I wrote before&apos;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16738</commentid>
    <comment_count>5</comment_count>
    <who name="">fantarama</who>
    <bug_when>2014-08-30 21:38:35 +0000</bug_when>
    <thetext>I understand your solution, but maybe I wansn&apos;t able to explain the issue.

The chunk work inside a transaction, and I agree that I had to size the timeout correctly, but the chunk is not the step, is a part of them. The spec define begin/commit transaction only for the chunk not the step. As I wrote I can&apos;t predict how long will take the entire step, I can only define the business logic inside the chunk to take the smaller time possible and in my case the single chunk take only few seconds to terminate.

A non partitioned step don&apos;t has this issue because there aren&apos;t any thread that begin/commit transaction for the entire step duration. 
But the partitioned one does! The thread that wait for all partitions ends and that call the partition analyzer methods work iside a single transaction.
The question is the same: why? Why I need a transaction that no one can predict the duration? I have millions of items to process, my single chunk never take more than a minute, but to process all the data set is a very long process which duration depends on too many variables.

If a single chunk take 70s instead of 30s this will in fact change a lot the total time.

Also if in the analyzer a simply write to a log (no db access) I&apos;m exposed to the transaction timeout. I really just want to understand the reason of this design, why regular step work well and a partitioned one doesn&apos;t? I need partitions for time saving purpose, but in fact I can&apos;t use it because I had to know how long will take the entire step?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16750</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-03 14:15:20 +0000</bug_when>
    <thetext>fantarama, thanks for raising this issue.

I agree there&apos;s definitely a spec clarification needed (if not a change/fix).  
The RI seems wrong here as well.

My first reaction is to agree with you, and to argue the spec intention was that a new tran is started around each call to the analyzer.   I.e. each analyzer call to either analyzeCollectorData or analyzeStatus is done within a global tran, and if the tran rolls back then PartitionReducer.rollbackPartitionedStep is called.  (We&apos;d call this a bug in laying out the outline flow chart then.)

I think the behavior becomes coherent with that approach.. but need to think it through.   

For what it&apos;s worth, I don&apos;t see that the RI uses a global tran at any point when calling the analyzer, which is clearly wrong.

The timeout becomes a more pressing concern for partitioned chunks, but for the sake of symmetry I think the same comment would apply to partitioned batchlets, don&apos;t you?   That would leave us knowing that the analyzer methods always run in a global tran.

Also we should note this is a potentially disruptive change. It could break any analyzer already using the RI, say, depending on the lack of a global tran.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17049</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 20:08:44 +0000</bug_when>
    <thetext>Picking up this thread again... we have a case where the spec defines a behavior that I agree is undesirable, the RI implements a different behavior, and the TCK is silent.  And switching between a global tran or not can break apps.

Since there&apos;s not an easy way out, I&apos;d like to back up to square one.  

I don&apos;t see why a transaction would be so commonly needed around the analyzer calls that the spec should insist that one is present.   The analyzer itself could start one if it really needed one.

Now, it sounds like JBeret is already providing a global tran surrounding the analyzer calls.    

Note that with the RI not starting global trans in the analyzer at all currently, we already have a case today where portability across Glassfish &amp; JBeret is potentially an issue.

So let me pose the question to Cheng.   What would you think about changing the behavior of JBeret here to not surround the analyzer calls with a global tran?  Do you agree this would be preferable?  
 
Yet another alternative to consider would be a single global tran around each analyzer call (this is roughly doubling the total # of trans, since there&apos;s basically one for each chunk tran).  This would be less disruptive to any app running in JBeret, though still could break certain apps.   Still, I wonder if the overhead of the tran is worth it enough to start it all the time.

I&apos;m trying to especially incorporate the JBeret perspective here since I don&apos;t want to punish them for actually implementing what the spec said all along. Of course this is a public list, so don&apos;t take that to exclude other people commenting.

At some point we&apos;d need to update the spec too, but I thought we could continue the conversation before then here.

Thanks,
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17054</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 22:02:48 +0000</bug_when>
    <thetext>On second thought, my thoughts were incomplete, as I failed to consider
PartitionReducer.rollbackPartitionedStep.   

Need to think a bit more here..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17058</commentid>
    <comment_count>9</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-11-01 02:10:05 +0000</bug_when>
    <thetext>Between the 2 options, I feel no transaction around analyzers is cleaner. I personally think this is the right move despite the risk of incompatibility. I will also check with WildFly and JBeret users for any concerns and objections.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19500</commentid>
    <comment_count>10</comment_count>
    <who name="">Mobe</who>
    <bug_when>2015-12-10 14:06:31 +0000</bug_when>
    <thetext>I also think there should be no transactions around analyzer calls.

Once there is no single transaction around analyzer calls any more I do not see any reason for retaining transactions around calls to PartitionReducer.rollbackPartitionedStep or PartitionReducer.beforePartitionedStepCompletion.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6427</bug_id>
          
          <creation_ts>2014-09-23 16:52:00 +0000</creation_ts>
          <short_desc>Exception on analyzer thread leaves partitions executing while failing job, causing an immediate job restart to fail.</short_desc>
          <delta_ts>2015-09-03 16:17:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16871</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-23 16:52:58 +0000</bug_when>
    <thetext>Since the PartitionedStepControllerImpl doesn&apos;t currently catch exceptions thrown by analyzeStatus() or analyzeCollectorData(), an exception thrown from either of these two can immediately fail the job, while allowing the partitions to continue executing.

This can be a problem if the job is restarted, since the RI will determine that the partitions cannot be restarted at that point (if they are still executing from the original execution).

I think a better behavior is to wait around for the partitions to complete, and then call the rollbackPartitionedStep() method.

(Yet another interesting question is whether to continue &quot;dispatching&quot; not-previously running partitions after an analyzer exception.  I&apos;m choosing to continue to do so for now in the patch I&apos;ll push shortly).

I know I need to supply a test at some point.  This also might be worthy of a future TCK addition.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19090</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:17:25 +0000</bug_when>
    <thetext>Let&apos;s consider the RI complete (even absent a new test).

The spec question still:  what should happen to an executing partitioned step when an exception is thrown from the analyzer.

Possibly we consider execution of new partitions (i.e. whether to start a partition that hasn&apos;t been started yet because we&apos;ve only run a subset of the total #) as well.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6456</bug_id>
          
          <creation_ts>2014-10-07 11:02:00 +0000</creation_ts>
          <short_desc>Spec says that writer should be closed before reader.  RI does things in reverse.</short_desc>
          <delta_ts>2016-03-10 22:15:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>issues</cc>
    
    <cc>struberg</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16984</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 11:02:03 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17026</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-23 16:27:23 +0000</bug_when>
    <thetext>Oh..one more minor note:

In &quot;Rollback Procedure&quot; at the end of Sec 11.9 we for some reason have the writer open() call before the reader open().

This seems like a copy/paste error.   I would like to queue up a spec update to treat it as such.

Any objections?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17051</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 20:59:04 +0000</bug_when>
    <thetext>Fixed in RI (along with other fixes) at:
https://github.com/WASdev/standards.jsr352.jbatch/commit/1679181c55a5267a15feade1bba35fffd4d401c4

Moving this to &apos;SPEC&apos; to address the typo in Comment 1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19121</commentid>
    <comment_count>3</comment_count>
    <who name="">struberg</who>
    <bug_when>2015-09-07 07:52:26 +0000</bug_when>
    <thetext>was there a test for it in the TCK or was it described that way in the API?
If so, then we need to keep it imo (according to JCP rules).

If it was ambiguous or even contradictory then we are free to &apos;fix&apos; it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19125</commentid>
    <comment_count>4</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2015-09-07 11:14:44 +0000</bug_when>
    <thetext>There is no TCK test for it, or if there is, it is broken.

I don&apos;t know if it&apos;s ambiguous, section 11.9 says has `ItemWriter.open` before `ItemReader.open`, but it does go against the convention every other time these interfaces are mentioned where the pattern is always `ItemReader.open`, `ItemWriter.open`, `ItemWriter.close`, `ItemReader.close`.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19787</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-10 22:15:07 +0000</bug_when>
    <thetext>(In reply to struberg from comment #3)
&gt; was there a test for it in the TCK or was it described that way in the API?
&gt; If so, then we need to keep it imo (according to JCP rules).
&gt; 
&gt; If it was ambiguous or even contradictory then we are free to &apos;fix&apos; it.

No, I&apos;m almost 100% certain there was no test specifically enforcing the relative order of reader vs. writer open() in &quot;Rollback Procedure&quot;.  (As there was no test enforcing the order during normal processing, given that the RI contained this bug in 1.0).    

So I think we&apos;re free to update the spec doc.  And we really should add some TCK test coverage too.

(This order still surprises me though.)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6457</bug_id>
          
          <creation_ts>2014-10-07 11:09:00 +0000</creation_ts>
          <short_desc>On retry with rollback, we only want to process the most recent chunk with item-size = 1, even with custom checkpoint algorithm</short_desc>
          <delta_ts>2015-01-05 19:31:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16986</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 11:09:27 +0000</bug_when>
    <thetext>At the end of Sec. 11.9 in &quot;Rollback Procedure&quot;

...
6. &lt;-&gt;ItemWriter.open // thread A, pass last committed checkpoint info
7. &lt;-&gt;ItemReader.open // thread A, pass last committed checkpoint info
...
it clearly says to call open with the last committed checkpoint (strikes me as odd that it would say to call the writer open first.

The RI doesn&apos;t do this.

Since the TCK is weak in this area let&apos;s also look over carefully the RI code with the text in &quot;8.2.1.4.4&quot; in mind:

When a retryable exception occurs, the default behavior is for the batch runtime to rollback the current chunk and re-process it with an item-count of 1 and a checkpoint policy of item. If the optional ChunkListener is configured on the step, the onError method is called before rollback.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16988</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 14:33:37 +0000</bug_when>
    <thetext>Sorry... the problem as I&apos;d originally written it up is not a problem.
I got confused unwrapping a pile of exceptions.. my mistake.

The RI does indeed call open with the last checkpoint on retry-with-rollback.   

One thing we&apos;re doing wrong though:  we should only be processing the last chunk of data, in one at a time in one-item chunks.   Instead we go and process the rest of the step in the one-item chunk mode.

It also looks like, from code inspection, that we fail to implement this behavior in the case of a custom checkpoint algorithm.  I read 8.2.1.4.4 to imply that we should use the single-item chunk even if there had been a custom checkpoint algorithm.  (This implies that we count the previous &quot;working chunk size&quot;.. I don&apos;t think anyone would suggest using another method to keep track of when we&apos;ve reprocessed the previous chunk.)

So I renamed the bug accordingly to capture this problem.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16992</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-10-07 21:38:32 +0000</bug_when>
    <thetext>I just checked what we did in JBeret chunk processing: during a retry, it doesn&apos;t use or modify itemCount value, since the retry is by single item. After the retry, it&apos;s back to normal phase and the original itemCount or checkpoint policy resumes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17025</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-23 16:26:00 +0000</bug_when>
    <thetext>So, getting back to this thread on retry-with-rollback.

A tricky point is how do we know when we&apos;re done processing the &quot;original chunk&quot;?   I.e. when should we stop processing the data in single-item chunks (one-at-a-time), and resume using the normal chunk boundary.

The custom CheckpointAlgorithm complicates things.   How do we know when the original chunk would have been checkpointed by the CheckpointAlgorithm?
---

Here&apos;s how I&apos;d naturally propose to solve this problem, (given that the RI has so far sidestepped this): 

  If you are using item-count to checkpoint, then, on retry-with-rollback, we read-process-write  (item-count)# of items one-at-a-time before reverting to normal (item-count)#-sized chunks.

  If you are using CheckpointAlgorithm, we use the number of items read up until the point the retryable exception occurred.   I.e. we read-process-write #read one-at-a-time before reverting to CheckpointAlgorithm-defined chunks.
--

How does that sound?   What are the other implementations doing?

Cheng, I don&apos;t think your response went into that level of detail, or if you meant it to I missed it.   (Thanks).

If this sounds good I could take a stab at writing this up more formally.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17027</commentid>
    <comment_count>4</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-10-23 17:08:13 +0000</bug_when>
    <thetext>org.jberet.runtime.runner.ChunkRunner has a couple of internal fields to track progress:

readPosition: Current position in the reader input data

checkpointPosition: the last checkpoint position in the reader intput data

failurePoint: Where the failure occurred that caused the current retry. The retry should stop after the item at failurePoint has been retried.

These 3 fields are synchronized with each other at various points. During a retry, readPosition rewinds to the last checkpointPosition and increments from there until it reaches the last failurePoint.  After that point, all items are back to normal treatment. So whether we use item-count or custom checkpointAlgorithm, we only retry failed items. I think that&apos;s the basic retry flow in JBeret.

In your proposal, if we read-process-write  (item-count)# of items one-at-a-time, that may result in many single-item checkpointing, especially if it fails early during a chunk (e.g., failed at 3rd item when item-count is 100).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17050</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 20:57:12 +0000</bug_when>
    <thetext>Thanks for your explanation Cheng. 

Agree your implementation is better. I just committed something similar in:

https://github.com/WASdev/standards.jsr352.jbatch/commit/1679181c55a5267a15feade1bba35fffd4d401c4
(this fixed a few other bugs too).

Doing so made me give up on the thought that we should amend the spec any here. 
Let&apos;s call it a day and let this stand as an RI bug.

There are still a couple small ambiguities... e.g. what happens if one of my 
items gets filtered (by the processor).. do I read another or immediately commit the tran (the MR update clarifies no writeItems is called if all items have been filtered)?  I&apos;d entertained the spec update idea thinking a change was relatively unlikely to break any app behavior.. but I don&apos;t want to get into a whole set of things..

So a retry-with-rollback exception on read and process only retries up until the last-read item 1-by-1 before reverting to normal chunk processing, though a retry-with-rollback exception on write retries the whole chunk.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17366</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-01-05 19:31:41 +0000</bug_when>
    <thetext>Consider if something like Roberto&apos;s suggestion would be helpful:

&quot;After the faulty chunk is retried, the 
implementation should/must return to the configured checkpoint policy. &quot;

See:
https://java.net/projects/jbatch/lists/public/archive/2014-12/message/13

Assigning to SPEC.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6458</bug_id>
          
          <creation_ts>2014-10-07 11:18:00 +0000</creation_ts>
          <short_desc>Should ItemReadListener get called after readItem() return null?</short_desc>
          <delta_ts>2014-10-22 20:16:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16987</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 11:18:30 +0000</bug_when>
    <thetext>When readItem() returns null to begin the end of the chunk loop, do we bother calling ItemReadListener.afterRead?

I think the afterRead() Javadoc sort of suggests we only call it if it&apos;s non-null: 
* The afterRead method receives control after an item
* reader reads an item.

The updated flow outline in Sec. 11.8 seems to suggest we call it with a null.

...
c. &lt;repeat until checkpoint criteria reached OR readItem returns &apos;null&apos;&gt; {
i. &lt;-&gt;[ItemReadListener.beforeRead] // thread A
ii. &lt;-&gt;ItemReader.readItem // thread A
iii. -&gt;[ItemReadListener.afterRead] // thread A

-----
I can see both sides:  It is nice to not have to check for null in afterRead().   OTOH, I suppose someone could come up with a case where it is nice to know the step is about to end (perhaps?)..and this is the precedent we&apos;ve put out there in the RI.

I guess I&apos;m ending up saying it&apos;s too late to change the behavior, and we should clarify the Javadoc.  Any thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16989</commentid>
    <comment_count>1</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-10-07 14:52:50 +0000</bug_when>
    <thetext>In JBeret, we always call ItemReader.afterRead(item), whether the item is null or not. I think a listener is primarily interested in an action being performed, more than the outcome of an action (the item returned from readItem). Since we already called beforeRead, it&apos;s good to be symmetrical by calling afterRead.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17022</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-22 20:16:58 +0000</bug_when>
    <thetext>This doesn&apos;t seem like such a big deal picking this up again.  Now the spec even seems clear enough to me.   Nice that JBeret and the RI are consistent.

I suppose we could consider adding a TCK test at some point so I&apos;ll leave it open for now.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6473</bug_id>
          
          <creation_ts>2014-10-21 19:20:00 +0000</creation_ts>
          <short_desc>AbstractItemWriteListener missing from spec.</short_desc>
          <delta_ts>2014-10-21 19:20:09 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17018</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-21 19:20:09 +0000</bug_when>
    <thetext>AbstractItemWriteListener is in the RI, and AbstractItemReadListener and AbstractItemProcessListener  are both in the spec.   

So clearly an omission from the spec document.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6490</bug_id>
          
          <creation_ts>2014-11-01 03:34:00 +0000</creation_ts>
          <short_desc>Add an API to get StepExecution for individual partitions</short_desc>
          <delta_ts>2016-02-09 15:13:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17059</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-01 03:34:54 +0000</bug_when>
    <thetext>As noted in the Bug 5675 discussion, it would be nice to perhaps get persistent user data for the individual partitions.

This would have to be added in a future spec update.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19691</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-02-09 15:13:07 +0000</bug_when>
    <thetext>I think another important use case to mention is using the reducer to compensate for missed calls to the analyzer (since the analyzer calls are not guaranteed to complete, and one might need to reconcile this fact on restart against persistent user data).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6509</bug_id>
          
          <creation_ts>2014-11-09 21:21:00 +0000</creation_ts>
          <short_desc>item-count text mentions &quot;number of items processed&quot; when EG had decided on &quot;number of items read&quot;</short_desc>
          <delta_ts>2014-11-09 21:21:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17101</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-09 21:21:51 +0000</bug_when>
    <thetext>The spec text, in describing &quot;item-count&quot; as 
&quot;Specifies the number of items to process per chunk&quot; 
is ambiguous. 

(That&apos;s one example.. the &quot;process&quot; verb is used in a few places in the spec.)

Cheng helpfully raised this exact point in this thread:
https://java.net/projects/jbatch/lists/public/archive/2013-04/message/88

In the thread it was decided that &quot;item-count&quot; was actually the number of items READ, not PROCESSED (which could be interpreted as not including filtered items).

-----
Anyway, I&apos;d like to update the spec in the next revision here.

I just got confused myself on this issue, and recently delivered a change (@1679181) to the RI which is excluding filtered items from being counted against the item-count checkpoint.    (I&apos;ll reference this bug to fix this recent &quot;fix&quot;).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6511</bug_id>
          
          <creation_ts>2014-11-10 17:38:00 +0000</creation_ts>
          <short_desc>improve working on &apos;skippable&apos; and &apos;retryable&apos; exceptions</short_desc>
          <delta_ts>2014-11-10 17:41:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>Other</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>BrentDouglas</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17105</commentid>
    <comment_count>0</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-11-10 17:38:07 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17106</commentid>
    <comment_count>1</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-11-10 17:41:58 +0000</bug_when>
    <thetext>See discussion at https://java.net/projects/jbatch/lists/public/archive/2014-11/message/4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6512</bug_id>
          
          <creation_ts>2014-11-10 17:46:00 +0000</creation_ts>
          <short_desc>Clarify if READ_RETRY_COUNT and onReadError (and corresponding for skip) get called on error in #checkpointInfo</short_desc>
          <delta_ts>2014-11-10 17:46:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>Other</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>BrentDouglas</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17107</commentid>
    <comment_count>0</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-11-10 17:46:56 +0000</bug_when>
    <thetext>See discussion at https://java.net/projects/jbatch/lists/public/archive/2014-11/message/4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6581</bug_id>
          
          <creation_ts>2014-12-15 03:46:00 +0000</creation_ts>
          <short_desc>Suppot script languages in certain batch artifacts</short_desc>
          <delta_ts>2015-09-02 16:45:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17278</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-12-15 03:46:44 +0000</bug_when>
    <thetext>Various script languages have extensive support for data procesing, which makes it easy to write batch components. It will be nice to support certain batch artifacts writting in scripting languages, and open up the Java batch framework to scripting developers as well.

For instance, a batchlet written as Groovy script to perform a short task. Or ItemReader, ItemProcessor, and ItemWriter written as JRuby script to process CSV resources.

JSR 223 Scripting for the JavaTM Platform (https://www.jcp.org/en/jsr/detail?id=223) may be leveraged to plugin in various scripting engine.

We may also need to adjust job xml schema to accommodate scripting-related configurations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17281</commentid>
    <comment_count>1</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-12-15 16:34:41 +0000</bug_when>
    <thetext>Is this really necessary? You can run Groovy batchlets the same way you would java batchlets, they are both going to produce regular class files. I just knocked up an example doing just that (https://github.com/BrentDouglas/groovy-batch-example) and it works as expected. Regarding scripts in other languages, it would be trivial to knock up a batchlet/other artifact that plugs a script loaded based on a property into a ScriptEngine as it it, it there really any need to change anything?

Regarding the job schema, section 10.6 is pretty clear that implementation specific loaders are allowed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17286</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-12-16 15:47:08 +0000</bug_when>
    <thetext>While it is certainly possible to achieve all these within application space with the current spec, it will be even better to avoid any intermediary if the spec can standardize it in future releases. This way any batch spec implementation can implement it in a portable way, without resorting to any implementation-specific loader.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6587</bug_id>
          
          <creation_ts>2014-12-16 20:13:00 +0000</creation_ts>
          <short_desc>Consider clarifying when ChunkListener#onError() is called</short_desc>
          <delta_ts>2015-10-19 20:23:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17290</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-12-16 20:13:00 +0000</bug_when>
    <thetext>See

https://java.net/projects/jbatch/lists/public/archive/2014-12/message/3

(It seems like the question re: afterStep has been settled).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19320</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-08 16:18:53 +0000</bug_when>
    <thetext>Maybe also just clarify that onError is NOT called in either of a skipped or no-rollback exception.  I think the outline and Javadoc together already implies this though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19351</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-19 20:23:43 +0000</bug_when>
    <thetext>See also Bug 7350.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6702</bug_id>
          
          <creation_ts>2015-02-03 17:29:00 +0000</creation_ts>
          <short_desc>skip and retry for exceptions from chunk listeners</short_desc>
          <delta_ts>2016-03-24 14:43:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17571</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-02-03 17:29:10 +0000</bug_when>
    <thetext>Section 8.2.1.4.1 Skipping Exceptions, has the following:

    It applies to exceptions thrown from the reader, processor,writer batch artifacts of a chunk type step. It also applies to exceptions thrown during checkpoint commit processing. A failed commit will be treated the same as a failed write.


It doesn&apos;t include exceptions from any chunk listeners.  For instance, will an exception from ItemReadListener.afterRead() method be eligible for skip or retry?  I think they should, as these listeners are extensions of their associated reader, writer, or processor artifact.

Thoughts? 

Spec group discussion thread:
https://java.net/projects/jbatch/lists/public/archive/2015-02/message/1</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19857</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-24 14:43:25 +0000</bug_when>
    <thetext>Noted that some related issues came up in:
https://issues.apache.org/jira/browse/BATCHEE-88</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6703</bug_id>
          
          <creation_ts>2015-02-03 17:33:00 +0000</creation_ts>
          <short_desc>To clarify the behavior after skip-limit and retry-limit are exceeded</short_desc>
          <delta_ts>2015-02-03 18:24:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17572</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-02-03 17:33:57 +0000</bug_when>
    <thetext>What will happen when skip-limit or retry-limit is exceeded?  The most logical result seems to be FAILED step. The current spec doesn&apos;t explicitly state that, though.

Do you think we should add that when skip-limit or retry-limit are exceeded, the step should be marked failed with FAILED batch status?

For a somewhat similar attribute, start-limit, we do have this sentense:

    If the limit is exceeded, the job is placed in the FAILED state. 

Spec group discussion thread:
https://java.net/projects/jbatch/lists/public/archive/2015-02/message/0</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17573</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-02-03 18:24:05 +0000</bug_when>
    <thetext>I think it&apos;s closely-related enough that I&apos;ll mention I might like to revisit the first paragraph in 8.2.1.4 which now strikes me as mildly confusing.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6790</bug_id>
          
          <creation_ts>2015-03-04 20:00:00 +0000</creation_ts>
          <short_desc>JavaDoc clarification for JobExecution getStartTime() and getEndTime() return values</short_desc>
          <delta_ts>2015-09-03 16:18:23 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jrperkinsjr</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17773</commentid>
    <comment_count>0</comment_count>
    <who name="">jrperkinsjr</who>
    <bug_when>2015-03-04 20:00:34 +0000</bug_when>
    <thetext>For JobExecution.getStartTime() [1] the date should only be set when the batch status has been set to STARTED. For JobExecution.getEndTime() [2] the date should only be set when the batch status is either COMPLETED, FAILED or STOPPED. The return type should clarify what value is returned if the batch status has not reached of the allowed states. JBatch returns null which seems like the most logical value to return.

[1]: http://docs.oracle.com/javaee/7/api/javax/batch/runtime/JobExecution.html#getStartTime()
[2]: http://docs.oracle.com/javaee/7/api/javax/batch/runtime/JobExecution.html#getEndTime()</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6796</bug_id>
          
          <creation_ts>2015-03-07 17:08:00 +0000</creation_ts>
          <short_desc>@BatchProperty injection should keep field default value in case of no matching batch property</short_desc>
          <delta_ts>2015-09-01 21:23:35 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17799</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-07 17:08:02 +0000</bug_when>
    <thetext>Section 9.3.1 states:

The value of the annotated field is assigned by the batch runtime if a corresponding property element with a matching name is specified in the JSL in the scope that applies to the batch artifact in question.


So if no matching batch property is found for a @BatchProperty field, batch runtime should not attempt to inject anything, and thus preserving the java default value for the field.

I did a quick test in GlassFish, and it shows a null value is injected, and the java default value is overwritten.

@Inject
@BatchProperty
String undefinedProperty = &quot;default value for undefinedProperty&quot;;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17800</commentid>
    <comment_count>1</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2015-03-07 18:41:01 +0000</bug_when>
    <thetext>If I&apos;m reading your post correctly then I disagree that this is a spec compliance issue. Later in section 9.3.1 is the following:

&gt; The resulting value might simply be the Java default value, however using
&gt; various dependency injection technologies may produce different results.
&gt; The resultant behavior may be defined by the particular dependency injection
&gt; technology used in the runtime environment and so is outside the scope of this &gt; specification.

And of particular relevance:

&gt; If no value is defined in JSL, the Java default (null) is assigned or
&gt; some other default is provided by a particular dependency injection technology.

So the behavior is:
- If &quot;undefinedProperty&quot; is not defined in your JSL &apos;the Java default (null) is assigned&apos; and the current behavior is compliant.
- If you have a property &quot;undefinedProperty&quot; defined in your JSL which resolves to &quot;&quot; then &apos;no assignment is made&apos;.

So if by &apos;no matching batch property is found&apos; you mean that &quot;undefinedProperty&quot; is not defined in your JSL then the behavior you have described is compliant with the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17801</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-07 19:16:10 +0000</bug_when>
    <thetext>I think the spec makes a distinction between: (1) a batch property is not defined in job xml at all; and (2) a batch property appears in job xml but resolves to non-meaningful value (empty string).  My reading is, what you&apos;ve quoted applies to the latter case.  The first sentense (see quote my original comment) establish the context for the subsequent long and detailed explanation.

For case 1, since the intended batch property does not exist, default java behavior should be preserved, and no batch property injection should be happening.  In my example above, undefinedProperty field should hold value &quot;default value for undefinedProperty&quot; (the java default value) after the artifact is created.

This is consistent with resource injections in Java EE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17802</commentid>
    <comment_count>3</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2015-03-07 20:20:05 +0000</bug_when>
    <thetext>&gt; I think the spec makes a distinction between: (1) a batch property is not
&gt; defined in job xml at all; and (2) a batch property appears in job xml but
&gt; resolves to non-meaningful value (empty string).

Yes.


&gt; My reading is, what you&apos;ve quoted applies to the latter case.

I quoted both cases.


&gt; The first sentense (see quote my original comment) establish the context for
&gt; the subsequent long and detailed explanation.

If you post the JSL document used it would remove any area for misinterpretation.


&gt; For case 1, since the intended batch property does not exist, default java
&gt; behavior should be preserved, and no batch property injection should be
&gt; happening.

From here down I will only be discussing case 1: &quot;a batch property is not defined in job xml at all&quot;

The spec does not require that &quot;no batch property injection should be happening&quot;. The spec area that applies is:

&gt; If no value is defined in JSL, the Java default (null) is assigned or
&gt; some other default is provided by a particular dependency injection
&gt; technology.

Which could also be expressed &quot;If you are using a DI framework the field can be anything at all but if not the field will be assigned null&quot;. Assuming you are not using a DI framework in your example, the value of null is the correct value to be assigned.


&gt; In my example above, undefinedProperty field should hold value
&gt; &quot;default value for undefinedProperty&quot; (the java default value) after the
&gt; artifact is created.

The spec clearly indicates that in this case the term &quot;Java default&quot; refers to null. I would say calling it the java default is a reference to section 4.12.5 of the JLS &quot;For all reference types (4.3), the default value is null&quot; (http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5).


&gt; This is consistent with resource injections in Java EE.

That sounds like you are arguing that the spec needs changing rather than the RI is not implementing it correctly which is a different issue.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17824</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-03-11 21:55:38 +0000</bug_when>
    <thetext>Cheng,

I&apos;d originally thought the spec wording was clear and covered all cases, and had the same interpretation that Brent suggested across all these cases.

But it sounds like you&apos;re taking words such as:
  &quot;If no value is defined in JSL, ...&quot;   (beginning of last sentence of 9.3.1)

to imply that we are already in the case where there is a JSL property, which has been &quot;resolved&quot; to the empty string.   It sounds like you&apos;re drawing a distinction between this case and the case where there is no JSL property name matching the @BatchProperty name.    

OK, let&apos;s assume the wording could have been clearer. 

As the next step, I&apos;d like to ask whether you are suggesting the spec should be updated or whether the RI behavior should be different?

You mentioned &quot;This is consistent with resource injections in Java EE.&quot;  Could you elaborate on that?

Thanks, Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17828</commentid>
    <comment_count>5</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-12 14:38:09 +0000</bug_when>
    <thetext>For Java EE resource injections, please see Java EE 7 Platform spec, section EE.5.4.1.3 Declaration of Simple Environment Entries.  To quote the relevant part:

&lt;quote&gt;
Its often convenient to declare a field or method as an injection target, but specify a default value in the code, as illustrated in the following example.

// The maximum number of tax exemptions, configured by the Deployer. 
@Resource 
int maxExemptions = 4; // defaults to 4

To support this case, the container must only inject a value for this resource if the deployer has specified a value to override the default value. 

&lt;/quote&gt;

I think that&apos;s the most intuitive defaulting behavior from a developer&apos;s perspective.  Of course, batch spec doesn&apos;t have to follow Java EE spec, especially it&apos;s something specific to batch domain.  But since this case is more about general property injection, my personal perference is to align with Java EE spec.  

The current batch spec gives quite some leeway for implementations in this area. I hope RI could be updated towards a more sensible injection default. To take it one step further, the spec could also benefit from some clarification and remove some ambiguity.

Related discussion on cdi-dev (using cdi as one mechanism of injection)
http://lists.jboss.org/pipermail/cdi-dev/2015-March/thread.html</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17866</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-03-18 21:19:34 +0000</bug_when>
    <thetext>(Sorry for dragging out the conversation here..)

OK, let&apos;s talk about the RI first then, and consider the spec later.

We tried to optimize our &quot;custom batch injection&quot; for compatibility with CDI.    (This in spite of the fact we didn&apos;t do some simple things like honoring the injection on fields defined on a batch artifact superclass).

Cheng, were you able to solve the problem of NOT having CDI overwrite the initializer value with a &apos;null&apos;?   I couldn&apos;t tell from the cdi-dev thread what the conclusion was.

Now I&apos;m realizing I&apos;d been reading the situation as &quot;CDI injects a null..&quot;.   Actually, of course, the CDI is acting through the batch implementation&apos;s producer, so maybe there&apos;s room for batch to be doing things differently.

If so, I think preserving the intializer value is clearly more useful in batch, in general, so would be interested to revisit.

I&apos;m also observing your EE platform quote referred to @Resource, not @Inject (not sure if that matters, just noting as I haven&apos;t had time to research myself).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17868</commentid>
    <comment_count>7</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-18 23:44:11 +0000</bug_when>
    <thetext>From cdi-dev discussion, it seems there is no portable way to opt out CDI injection within producer methods. Therefore, if we try to get property value for non-existent batch property (and we will get null), and if the producer method returns null to CDI, CDI will just inject null into that field, effectively overwriting whatever value is already in that field.

I recently added some fix to JBeret to get the field value (best-effort attemp) if the requested property does not exist, and have the producer method return that value to CDI to essentially let CDI to re-inject it. This is not as good as avoiding injecting, but still better than injecting null.

@Resource was introduced in Java EE 5, predating CDI. Now I think all injections in Java EE are trying to converge into CDI, at least it appears so.  So I would think the requirement for @Resource also apply to @Inject, however it is implemented.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19064</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:23:35 +0000</bug_when>
    <thetext>Whatever we decide for the RI, the spec should be amended to clarify that using the value of the Java initializer is allowed.

I think it is the most useful approach in the non-CDI case.  Plus it sounds like JBeret is doing this (in contrast to the RI).  WebSphere is keeping the initializer value as well.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6825</bug_id>
          
          <creation_ts>2015-03-19 16:51:00 +0000</creation_ts>
          <short_desc>Step failed with &lt;fail&gt; element not restartable</short_desc>
          <delta_ts>2016-02-10 17:01:35 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17871</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-19 16:51:04 +0000</bug_when>
    <thetext>This is an issue raised by Takashi, who described it very well in WildFly issue WFLY-4427.  I&apos;d like to discuss it here and see if the spec can be improved to better handle this case.

According to the current spec, &lt;fail&gt; element can appear inside a &lt;step&gt;, and when &lt;fail&gt; is triggered, the job will fail and this step&apos;s batch status is COMPLETED. During restart, that step will not re-execute as it had batch status COMPLETED, unless allow-start-if-complete is explicitly set to true.  But oftentimes, users tend to omit allow-start-if-complete attribute, thinking the default should work fine.

So we now have a failed job execution that cannot be restarted.  TCK contains some tests to enforce that the step containing &lt;fail&gt; element has COMPLETED batch status, and the step will not re-execute during subsequent restart.

So the main question is, do we want to change the spec to allow such step to re-execute during restart, even without specifying any allow-start-if-complete? 

See spec group discussion thread:
https://java.net/projects/jbatch/lists/public/archive/2015-03/message/23</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19694</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-02-10 17:01:35 +0000</bug_when>
    <thetext>Picking this thread up again, 

I think one of the proposal in the ML thread linked was to add a @restart to &lt;fail&gt; for something like:

 &lt;fail on=&quot;xx&quot; restart=&quot;step3&quot;/&gt;

(and I think similarly for &lt;end&gt; though I didn&apos;t follow that).

---

I think the downside of this is what if you really need step 1 to run every time... that&apos;s part of the rationale of &apos;allow-restart-if-complete&apos; to begin with.   So we&apos;ve lost that, and I hate to make someone restart on a decider to sort through all this.

Also not sure the other proposals addressed the use case I myself mentioned, where we throw an exc in step 2 thereby ending in FAILED, yet transition past it to step 3 with a &lt;next&gt; element, and wish to restart on step 3 WITHOUT re-executing step 2 (i.e. pick up where we left off).

To deal with both cases I can see conceptualizing something like an &quot;execute on restart&quot; policy associated with a given step.

So in 1.0, we could say we have two policies which I&apos;ll call:

1. IF NOT COMPLETED (this is the default)
2. ALWAYS (this is allow-restart-if-complete=&quot;true&quot;)

(Of course, we also only execute if we transition to this step upon restart to decide whether to rerun, but I&apos;ll take that for granted.)

So I think we could solve both use cases by adding to other &quot;policy&quot; choices:

3. NEXT_TIME   
4. NEVER 

E.g. for Takashi&apos;s original use case, we could have 

&lt;fail on=&quot;xx&quot; execute-on-restart=&quot;next-time&quot;/&gt;

Once this step is re-executed, the &quot;flag is removed&quot; you could say, and we revert to policies 1. or 2.  The allow-restart-if-complete=&quot;true&quot; setting would take precedence.    You could set this on &lt;fail&gt; and probably &lt;stop&gt; too I&apos;d think.


Then for my use case you could have:

&lt;end on=&quot;xx&quot; execute-on-restart=&quot;never&quot;/&gt;

There is no way to undo never... no way we will ever re-execute this step.  

I&apos;m not sure the need for this has been convincingly made, but again, it seemed worth considering both cases together.

It is maybe a bit odd to have the one policy choice triggered by a &lt;step&gt; attribute ( allow-restart-if-complete) and these other choices by transition elems.  But there is a precedence here and they&apos;re not symmetric.

...

Another idea I&apos;d raised is conceptualizing this as &quot;transition within&quot; vs. &quot;transition after&quot;.   The down side of this is that in my use case, the step has already FAILED.  Marking it as COMPLETED seems like erasing history.   Perhaps the analogous approach in Takashi&apos;s case wouldn&apos;t be so bad (even though the full step logic including afterStep() saw a normally-completing step maybe we could still get our heads around the step ending in a FAILED state because of the transition failure).    But it would bother me to not see the two cases behave somewhat symmetrically.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6828</bug_id>
          
          <creation_ts>2015-03-19 17:37:00 +0000</creation_ts>
          <short_desc>Change the words &quot;SkipListener&quot; and &quot;RetryListener&quot; to specific listener names</short_desc>
          <delta_ts>2015-03-19 17:37:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17874</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-19 17:37:40 +0000</bug_when>
    <thetext>Several places in the spec contain the words &quot;SkipListener&quot; and &quot;RetryListener&quot;, which may mislead readers to think there are so-named interfaces. It&apos;s better to use specific interface names like &quot;SkipReadListener&quot;, &quot;SkipProcessListener&quot;, &quot;SkipWriteListener&quot;, etc.

&quot;SkipListener&quot; is used in section 11.8 Chunk with Listeners (except RetryListener) flow diagram.

These 2 old interfaces were broken down in
Bug 4303 - Break RetryListener down into multiple interfaces?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6975</bug_id>
          
          <creation_ts>2015-05-05 19:26:00 +0000</creation_ts>
          <short_desc>Clarify timepoint and status of job when JobListener#afterJob() is called</short_desc>
          <delta_ts>2015-05-05 19:26:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>Turbokiwi</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>18275</commentid>
    <comment_count>0</comment_count>
    <who name="">Turbokiwi</who>
    <bug_when>2015-05-05 19:26:56 +0000</bug_when>
    <thetext>The spec is a bit unclear about the exact time, when JobListener#afterJob() is called. Point 9.2.1 of the spec says: &quot;A job listener receives control before and after a job execution runs&quot;. The JavaDoc of the interface says &quot;The afterJob method receives control after the job execution ends.&quot;

When no exception has been thrown during the job, which JobContext#getExitStatus()/JobContext#getBatchStatus() should an implementation deliver inside JobListener#afterJob(). Does an JobExecution#getEndTime() has to be availabe at this time or should the endTime be set after all JobListeners have returned normally?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7282</bug_id>
          
          <creation_ts>2015-09-03 15:23:00 +0000</creation_ts>
          <short_desc>Do we want to update XSD ?</short_desc>
          <delta_ts>2015-09-22 15:21:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>m_edgar</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19082</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 15:23:23 +0000</bug_when>
    <thetext>Opening this as a separate item.  

My thought is, if it seems there are enough interesting changes to require or suggest an XSD update, we do one.   OTOH, if there maybe are not, maybe we don&apos;t and just stay with the 1.0 XSD.

E.g. in
https://java.net/bugzilla/show_bug.cgi?id=5403
the idea is suggested to loosen the schema.   I don&apos;t think I&apos;d want a new version JUST for this, but if there are enough, will use this item to track the schema update.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19233</commentid>
    <comment_count>1</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-09-22 15:04:06 +0000</bug_when>
    <thetext>This may merit a separate bug entry, but it&apos;s related to your comments. 

Unlike many other JEE XML formats, the JSL approach is somewhat procedural, but without any code reuse mechanism. One feature that I would like to see in JSL is the ability to include fragments of reusable JSL. I haven&apos;t fully thought it out, but it seems reasonable for a JSL fragment to allow any complex type from JSL as its root. The result of the include would be the same as specifying the fragment directly in the parent XML, with any parameters resolved.

For example, if I find myself defining the same listeners on every step in every job, having the ability to include another file (with parameter passing) allows me to get some code reuse (see below). 

*** myjob.xml

&lt;step id=&quot;step1&quot; next=&quot;step2&quot;&gt;
  &lt;include name=&quot;common-listener-set&quot;&gt;
    &lt;properties&gt;
      &lt;property name=&quot;param1&quot; value=&quot;step1-listener1-value&quot; /&gt;
      &lt;property name=&quot;param2&quot; value=&quot;step1-listener2-value&quot; /&gt;
    &lt;properties&gt;
  &lt;/include&gt;

  &lt;batchlet ... /&gt;
&lt;/step&gt;

&lt;step id=&quot;step2&quot;&gt;
  &lt;include name=&quot;common-listener-set&quot;&gt;
    &lt;properties&gt;
      &lt;property name=&quot;param1&quot; value=&quot;step2-listener1-value&quot; /&gt;
      &lt;property name=&quot;param2&quot; value=&quot;step2-listener2-value&quot; /&gt;
    &lt;properties&gt;
  &lt;/include&gt;

  &lt;chunk ... /&gt;
&lt;/step&gt;

*** common-listener-set.xml

&lt;listeners&gt;
  &lt;listener ref=&quot;com.company.batch.listeners.Listener1&quot;&gt;
    &lt;properties&gt;
      &lt;property name=&quot;param&quot; value=&quot;#{fragmentParameters[&apos;param1&apos;]}&quot; /&gt;
    &lt;properties&gt;
  &lt;/listener&gt;
  &lt;listener ref=&quot;com.company.batch.listeners.Listener2&quot;&gt;
    &lt;properties&gt;
      &lt;property name=&quot;param&quot; value=&quot;#{fragmentParameters[&apos;param2&apos;]}&quot; /&gt;
    &lt;properties&gt;
  &lt;/listener&gt;
&lt;/listeners&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19234</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-22 15:21:51 +0000</bug_when>
    <thetext>Yes this is a separate topic (please open a new issue).

We had originally targeted this function for 1.0, calling it &quot;JSL inheritance&quot;.

As we got close to our deadline, we pulled it out, realizing that the rule set for resolving property substitution in inheritance cases had quite a few details left to completely specify.

Since the 1.0 EG had this is plan originally, I think it&apos;s a fair topic to consider again for 1.1.   

That said, I think I&apos;ll need help to resolve those issues, in order to actually get this in 1.1.   We know SpringBatch has support for this and it looks like JBeret does as well.   Not too familiar but I&apos;m sure they&apos;d be good starting points.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7284</bug_id>
          
          <creation_ts>2015-09-03 21:07:00 +0000</creation_ts>
          <short_desc>Standardize waiting/blocking for job termination</short_desc>
          <delta_ts>2015-09-05 09:11:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>rmannibucau</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19101</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 21:07:07 +0000</bug_when>
    <thetext>See some ideas discussed in Bug 5370, where we agreed that in 1.0 all we had was async start/restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19111</commentid>
    <comment_count>1</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:11:58 +0000</bug_when>
    <thetext>An interesting option would be to add a startWithHandler(jobName, props) - name is very bad - returning a Future or CompletableStage. This would keep current behavior the same but would allow to wait super easily on the end of the job as a user.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7288</bug_id>
          
          <creation_ts>2015-09-05 09:20:00 +0000</creation_ts>
          <short_desc>Define custom CDI scopes for batch (@StepScoped, @JobScoped), possibly @ChunkScoped along with initialized/destroyed events</short_desc>
          <delta_ts>2016-03-24 16:17:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19113</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:20:51 +0000</bug_when>
    <thetext>https://java.net/bugzilla/show_bug.cgi?id=5075 exists but doesnt go very far.

Here what a full CDI integration can look like IMO:

- Each &quot;granularity&quot; - job/step/chunk at least - can have its own scope: @JobScoped, @StepScoped, @ChunkScoped. This would include associated listener in the scope to let them share some bean instances
- JBatch events could be associated with synchronous - cause of the previous point - CDI events to let them be observed in a CDI fashion - @Observes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19202</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-11 15:44:06 +0000</bug_when>
    <thetext>First, to recap, at the moment Sec. 11.1 says there is basically one artifact instance per step (or per partition), except for job listeners where there&apos;s one per job.

So one view is to say that @JobScoped, @StepScoped, @ChunkScoped scopes would apply to other beans, but not the batch artifacts themselves.

A different interpretation of your idea would have these new proposed scopes apply the batch artifacts themselves.

I can certainly see some use cases where it would be nice to define scopes like these.   However, there are more interactions to think through completely from the spec perspective.  

Also adding CDI scopes to the artifacts themselves raises the question of how is this supposed to work in the non-CDI case?   Are we going to say that a batch container must honor the semantics from a purely batch perspective even if CDI is absent?   

Maybe just for simplicity I&apos;m leaning towards the scopes applying to only the other beans.

Will have to coordinate at some point with both the CDI 2.0 and EE 8 specs I&apos;d think.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19203</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-11 15:47:52 +0000</bug_when>
    <thetext>So the observer idea sounds like you&apos;re proposing we define some standard batch Event(s) (e.g JobCompletedEvent, JobFailedEvent) that someone could observe.

Do you know if there&apos;s any precedent for another EE technology defining standard Event(s)?  Not too familiar with the subject.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19206</commentid>
    <comment_count>3</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-11 16:20:51 +0000</bug_when>
    <thetext>Scopes are not intended to be used by jbatch components but by beans injected in jbatch components - directly or indirectly ie it can be nested as well. Agree the spec is pretty clear @Dependent should be used for jbatch components themself, maybe it could be reinforced. The nice thing is once you can inject MyInjection with a scope &quot;job&quot; you can have a striongly typed state of the batch during the runtime and event potentially serialize it in the job persistent state if needed. It is better than JobContext which is not typed and more common in term of API IMHO.

About events: CDI itself does it (when a scope is initialized/destroyed), other spec doesn&apos;t yet but I think it is because integration is still a &quot;small glue&quot; but it is often compensated but external projects. Needed code is very small and gain in term of API is quite important so I don&apos;t see why we couldn&apos;t get it in the spec. Side notes about that: CDI 1.2 has already CDI.current() which would make the integration smooth without the need of any new CDI API.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19858</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-24 16:17:38 +0000</bug_when>
    <thetext>&quot;CDI integration&quot; is going to be a big topic.  I think although the various CDI-related pieces will intersect we need to break it apart more.

Let&apos;s use this just for the scopes, building on the work in JBeret and BatchEE hopefully.

Some other quick thoughts:

* I&apos;d assume we start by continuing the pattern we established with JobContext/StepContext of having the &quot;thread local&quot;-like behavior, which forces you to code in a distributed partition-ready way.  I realize JBeret has a different take on this.

* Do we need our own @ChunkScoped when we already have @TransactionScoped?

* Will we be able to easily specify the order of the chunk scoped initialized/ destroyed event compared with the ChunkListener beforeChunk()/afterChunk()?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7289</bug_id>
          
          <creation_ts>2015-09-05 09:23:00 +0000</creation_ts>
          <short_desc>Implicit conversion in chunk steps</short_desc>
          <delta_ts>2015-09-05 09:23:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19114</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:23:40 +0000</bug_when>
    <thetext>Let take the case of a reader-&gt;processor-&gt;writer. I wonder if we couldnt add globally in the job some converters - a bit like JPA/JSF/... - to be able to respect the flow even if one &quot;-&gt;&quot; doesnt match.

if reader returns a Foo and processor processes a Bar and we have a converter Foo-&gt; Bar then the flow can be respected even if reader-&gt;processor types don&apos;t match.

Side note: this implies to be able to type components and not rely on &quot;Object&quot; which is good as well IMO.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7290</bug_id>
          
          <creation_ts>2015-09-05 09:30:00 +0000</creation_ts>
          <short_desc>parallel processing for processors</short_desc>
          <delta_ts>2015-09-05 09:30:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19115</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:30:49 +0000</bug_when>
    <thetext>If processing of an ItemProcessor is a bit long parallelizing it can be good. It means the processor can return a Future or CompletionStage and parallelization can be activated by @Parallelizable on the processor or a default method in ItemProcessor returning a boolean to say if it is or not parallelizable. Then we would need a BatchItemWriter { &lt;X&gt; void write(List&lt;Future&lt;X&gt;&gt; futures) } as writer to be able to work with it.

If the writer is not a BatchItemWriter then the framework would just wait for the end of all items of the chunk before calling the writer unwrapping futures.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7291</bug_id>
          
          <creation_ts>2015-09-05 09:34:00 +0000</creation_ts>
          <short_desc>Bean Validation integration</short_desc>
          <delta_ts>2015-10-06 21:26:18 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19116</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:34:09 +0000</bug_when>
    <thetext>As optional it would be nice to be able to validate parameters of all components using bean validation.

here few examples to make it concrete:

- chunk processor: Object process(@Valid MyItem item);
- chunk writer: &lt;X&gt; void writeItems(@Valid List&lt;X&gt; xs)
- etc...

Bean Validation 1.1 has the API to validate input parameters and returned values.

Side note: for CDI case it is supported out of the box if JBatch components are CDI beans and not JBatch beans supporting CDI injections - this can be a point to enhance/clarify maybe.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19307</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-06 21:26:18 +0000</bug_when>
    <thetext>Not sure if you already had covered this, but just to be clear:  it would be nice to validate the injected @BatchProperty values.

My (limited) understanding is that, even when the batch artifact is loaded as a CDI bean and the property injected via CDI, that the validation won&apos;t be done automatically already.

...

Like you said, it would be helpful to clarify whether we&apos;re defining this in the CDI integration space or the DI-neutral space.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7295</bug_id>
          
          <creation_ts>2015-09-07 08:18:00 +0000</creation_ts>
          <short_desc>typed ItemWriter, ItemReader, ItemProcessor, etc</short_desc>
          <delta_ts>2016-03-25 19:17:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>struberg</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>issues</cc>
    
    <cc>rmannibucau</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19122</commentid>
    <comment_count>0</comment_count>
    <who name="">struberg</who>
    <bug_when>2015-09-07 08:18:56 +0000</bug_when>
    <thetext>The APIs defined in the spec are currently purely dealing with Object.class. This is so 90s ;)

In Apache BatchEE we additionally introduced subclasses which use Generics for better user experience. 

A sample would be 
public abstract class TypedItemWriter&lt;R, C extends Serializable&gt; implements ItemWriter {

where R is the type of the item to Read and C is the type of the Checkpoint.


You can dig into our impls at 
https://github.com/apache/incubator-batchee/tree/master/extensions/extras/src/main/java/org/apache/batchee/extras/typed</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19128</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-08 15:31:56 +0000</bug_when>
    <thetext>For 1.0, we&apos;d originally used generics, and then removed them after deciding they weren&apos;t adding much value.  

Could you give some examples of what use cases and patterns this faciliates?

E.g. one I can think of is defining reader/processor/writer as inner classes of a single outer class.  Another would be unit test.

Might be difficult to revisit without breaking the API (e.g. the List&lt;Object&gt; on the Writer), but still would like to start by hearing the case in more detail.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19129</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-08 15:37:47 +0000</bug_when>
    <thetext>Went back to see the earlier discussion seems to have been in
Bug 4776, in case it&apos;s still interesting ( haven&apos;t read through recently).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19130</commentid>
    <comment_count>3</comment_count>
    <who name="">struberg</who>
    <bug_when>2015-09-08 16:12:02 +0000</bug_when>
    <thetext>The main benefit is that it makes the Readers/Processors/Writers much more readable. And you can see at compile time that you got something wrong.

Having to just look at the top of the class and seeing

  public class MyReader extends TypedReader&lt;MyCustomerDTO, Long&gt;

immediately tells me what happens: this piece reads MyCustomerDTOs and the checkpoint type is Long.

And if I connect this with a e.g.

public class SomeProcessor extends TypedProcessor&lt;SomeOtherDTO&gt; 

then it&apos;s obvious what is wrong, right?
It just makes the code SOOO much better to read!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19813</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-16 19:00:36 +0000</bug_when>
    <thetext>(In reply to struberg from comment #3)
&gt; The main benefit is that it makes the Readers/Processors/Writers much more
&gt; readable. And you can see at compile time that you got something wrong.
&gt; 
&gt; Having to just look at the top of the class and seeing
&gt; 
&gt;   public class MyReader extends TypedReader&lt;MyCustomerDTO, Long&gt;
&gt; 
&gt; immediately tells me what happens: this piece reads MyCustomerDTOs and the
&gt; checkpoint type is Long.
&gt; 
&gt; And if I connect this with a e.g.
&gt; 
&gt; public class SomeProcessor extends TypedProcessor&lt;SomeOtherDTO&gt; 

Still interested in this one.  

OK, I can appreciate the readability gains with respect to R the item type, especially since you need to chain these together with the other artifacts, reader/processor/writer, listeners.   

One point I was trying to make though is that I&apos;m not seeing how adding the generic types helps you at all in seeing at compile time if you&apos;ve chained a reader/processor/writer together wrong.  OK, it prevents you from returning the wrong type in readItem() but are you saying it prevents you from chaining reader/processor together with the wrong types?  If so, how?

Also I&apos;m not seeing as much readability gain for C, the checkpoint type.  If the type is internal to the one class, is it really that helpful?  Maybe if you get into creating reader/writer subclasses it becomes more useful but haven&apos;t thought it through.

So as far as all the write-related classes and methods, it seems like we should have used just &quot;List&quot; instead of &quot;List&lt;Object&gt;&quot;.   Not seeing how we could get to &quot;List&lt;R&gt;&quot; without breaking 1.0 writers, etc.   I wonder if we could have a TypedItemWriterXXXX set of classes extending ItemWriter ?   Haven&apos;t prototyped this out to see what the issues would be.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19814</commentid>
    <comment_count>5</comment_count>
    <who name="">struberg</who>
    <bug_when>2016-03-16 20:13:09 +0000</bug_when>
    <thetext>&gt; but are you saying it prevents you from chaining 
&gt; reader/processor together with the wrong types?

Nope, because there is XML inbetween. BUT tools could add support for that really easily if we introduce a typesafe interface!

&gt; Also I&apos;m not seeing as much readability gain for C, the checkpoint type.
That&apos;s also fairly easy. You don&apos;t need any upcast. You don&apos;t need any checks in the code. That can all be done in the impl. After all you need to store the checkpoint in the db, etc _with_ the type.

But it&apos;s mainly about readability. I&apos;m not quite sure if it was really designed for it, but the practical effect of the batch-jobs/*.xml is a really subtle one. 

It&apos;s a bit like maven pom.xml files. People now don&apos;t need to dig into a tons of source files for hourse to know where to get started. They just go to the batch-jobs XML files and voila. The next step is going to the reader, writer etc. 
And there is makes a _huge_ difference if the ItemReader returns Object and you need to dig for another hour to know what it does. Or if you see with a single glimpse that it returns a MedicalApplicationDTO and the Checkpoint is a LocalDate.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19838</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-21 17:51:12 +0000</bug_when>
    <thetext>Thinking about this more, to add a generic type for both item type and checkpoint data, the list would include:

a) core artifacts: ItemReader, ItemProcessor, ItemWriter

b) listeners: 
ItemReadListener, ItemProcessListener, ItemWriteListener
SkipProcessListener, SkipWriteListener
RetryProcessListener, RetryWriteListener

(Left off  SkipReadListener, RetryReadListener, since we never refer to the item type in those methods.   The only point leaving them in would be to add symmetry to the type hierarchy).

Sounds like there&apos;s no new proposal for introducing generics to reflect the &quot;user data&quot; types (mentioning since this was in the 1.0 spec, but I&apos;m not proposing anything for user data).

---

Now, in 1.0 we also provide a few abstract classes with no-op methods:

AbstractItemReader, AbstractItemWriter
AbstractItemReadListener, AbstractItemProcessListener, AbstractItemWriteListener


So it seems the most obvious way of moving forward is to create a new interface TypedXXXX for every interface XXX, and a new abstract class TypedAbstractXXXX for every existing abstract class AbstractXXX.

But I suppose there are also options, including adding the new TypedXXX constructs as abstract classes rather than interfaces (which BatchEE does).    Possibly use a Java 8 default impl (we&apos;ve indicated we&apos;ll probably require Java 8 but haven&apos;t firmly committed just yet).  

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19839</commentid>
    <comment_count>7</comment_count>
    <who name="">struberg</who>
    <bug_when>2016-03-21 17:54:59 +0000</bug_when>
    <thetext>I personally think it would be sensitive to use Java8 and might look if we can get away with default methods?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19840</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-21 18:07:38 +0000</bug_when>
    <thetext>(In reply to struberg from comment #7)
&gt; I personally think it would be sensitive to use Java8 and might look if we
&gt; can get away with default methods?

Default methods are added in Java 8.   I&apos;m not clear if you are saying it is a good idea or bad idea to assume/require Java 8 for Batch 1.1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19841</commentid>
    <comment_count>9</comment_count>
    <who name="">struberg</who>
    <bug_when>2016-03-21 19:07:54 +0000</bug_when>
    <thetext>+1 for Java8 as we are targeting Java EE8. Java7 will also be EOL soon.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19862</commentid>
    <comment_count>10</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2016-03-25 16:43:42 +0000</bug_when>
    <thetext>I&apos;ve read this thread a few times now and I still can&apos;t work out what benefits we get from this. Due to the XML between method calls the types we see at the moment are accurate as they are the Runtime type observed by the impl. As far a readability goes, I think the checkpoint example will provide no benefits. It is prefectly valid to return a narrower type  than declared on the interface so in the example we can go ahead and return a LocalDate with the spec as it is now. The only thing I can see us getting out of adding types is being able to narrow the types if the params however this basically means casting Object to T in the runtime as were still observing the runtime type as Object. The way I see it, this means either adding extensive type checking to batch artifacts, which i believe to be fairly infesible, or throwing a CCE in the runtime rather than in consumer code.

Imo these classes are not actually type safe, they should not be declared as if they are.

Am I missing something?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19863</commentid>
    <comment_count>11</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2016-03-25 17:19:14 +0000</bug_when>
    <thetext>@Brent: technically you are right: by design it is not typed but as a user having to cast by design is not satisfying today. Current API enforces casting in a lot of cases where you just want to implement smoothly in-&gt;out types. This issue means if you don&apos;t care (as today) you could return Object but if you care you can enforce it.

It is also insanely important for documentation since Object process(Object) doesn&apos;t document anything but Foo process(Bar) does. It also helps a lot when generating data and just maintaining the code.

This is really about make the API smooth for end users more than bringing anything technically - see how many users complain or just other abstractions cause the spec one is not matching a smooth and modern coding style.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19864</commentid>
    <comment_count>12</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-25 19:17:33 +0000</bug_when>
    <thetext>I&apos;ve come around to thinking we made the wrong decision in 1.0, and it&apos;s just a matter of where to go from here.  

The discussion I recall was limited to having to cast (or not) and the fact that generics weren&apos;t really providing any compile-time checking.   True, but the potential for introspection, gains in readibility, and ease in reverting to Object or raw types if you didn&apos;t care for this should have led us to use generics more. 

One can always use Object as the type argument or just use raw types if you don&apos;t care to specify a specific type.  (Or at least one could have done that if we didn&apos;t already have a List&lt;Object&gt; for ItemWriter.writeItems() and in another listener method or two, which leaves us a complication).

That said, I don&apos;t rank this quite as high a priority as Mark and Romain, so the more you guys can help with the details of a complete proposal which addresses backwards compatibility, the sooner we can resolve this for 1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7318</bug_id>
          
          <creation_ts>2015-09-23 19:21:00 +0000</creation_ts>
          <short_desc>Provider JobOperator-related DTOs</short_desc>
          <delta_ts>2015-09-23 19:21:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19241</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-23 19:21:06 +0000</bug_when>
    <thetext>See Bug 7287.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7337</bug_id>
          
          <creation_ts>2015-10-06 18:03:00 +0000</creation_ts>
          <short_desc>Allow override on JSL-defined &lt;plan&gt; (in addition to mapper-constructed plan)</short_desc>
          <delta_ts>2015-10-06 18:03:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19303</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-06 18:03:17 +0000</bug_when>
    <thetext>Seems potentially useful here as well, and straightforward to add.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7338</bug_id>
          
          <creation_ts>2015-10-06 19:21:00 +0000</creation_ts>
          <short_desc>JobOperator called from within existing global transaction</short_desc>
          <delta_ts>2015-10-06 21:10:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19305</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-06 19:21:23 +0000</bug_when>
    <thetext>I don&apos;t recall us discussing what&apos;s supposed to happen with JobOperator API calls from within an existing tran.

This is especially interesting in the case that the job repository is backed by something like a transactional database, (which of course is not required and just an impl detail).

I don&apos;t think we simply want to navely include the job repository DB in the caller&apos;s tran.  On start(), you could insert a new job instance row on the original calling thread, start executing the job in another thread, and then have to roll back the new job instance later on, leaving things in what seems like an inconsistent state.

The &quot;read&quot; operations are also interesting.  One could try to use a transactional scope to lock down the data (backed by a DB) across a series of &quot;read&quot; calls.

Not sure what to do or say here.   

In the RI we did nothing and just allowed the tran scope to continue on in in spite of the above issues.  In WebSphere Liberty, we went the complete opposite route and suspended the tran around every JobOperator API call.

I guess there&apos;s the option of saying that calling within an existing tran is impl-defined/undefined, (which is untestable, but could at least go into the spec).   

I wonder if any other EE APIs deal with similar issues.

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19306</commentid>
    <comment_count>1</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-10-06 21:10:24 +0000</bug_when>
    <thetext>In JBeret, we take the middle-point approach: suspend any existing transaction for start() and restart(). For batch runtime to manage chunk transactions, it&apos;s critical to avoid any interference with any existing transactions.  But for other operations, including read operations and short-lived action operations (stop, abandon), different applications may have different requirements, so we just leave the existing transaction as is.

I think it could benefit from some spec clarification, better than just saying undefined.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7342</bug_id>
          
          <creation_ts>2015-10-08 15:54:00 +0000</creation_ts>
          <short_desc>Clarify that analyzer calls from collector are in-order (per partition)</short_desc>
          <delta_ts>2015-10-08 15:54:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19319</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-08 15:54:10 +0000</bug_when>
    <thetext>I think it would only help to clarify that analyzer calls from collector are in-order (per partition), with analyzeStatus calls last.

So for partition 1, you&apos;d have:

 analyzeCollectorData // 1st chunk 
 analyzeCollectorData // 2nd chunk
 .. 
 analyzeCollectorData // Nth chunk 
 analyzeStatus        // Always called

Should be non-controversial, might seem obvious.. but it just clarifies that it&apos;s the implementation&apos;s job, not the application&apos;s job to worry about.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7350</bug_id>
          
          <creation_ts>2015-10-14 09:24:00 +0000</creation_ts>
          <short_desc>Consider adding onError to Batchlet</short_desc>
          <delta_ts>2016-04-22 18:11:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>wkcat</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19335</commentid>
    <comment_count>0</comment_count>
    <who name="">wkcat</who>
    <bug_when>2015-10-14 09:24:37 +0000</bug_when>
    <thetext>I think many jBatch artifact has &quot;thorws Exception&quot; signeture at many methods.
That mean jBatch has some error handling mechanism in the product.

At chunk some listener work very well.
But Batchlet has no error supporting Listener, even Batchlet#process method has &quot;throws Exception&quot; signeture on the method.

I think, jBatch should have a listener whitch support Batchlet error.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19350</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-19 20:22:48 +0000</bug_when>
    <thetext>It perhaps should be called after a failure in open() as well.

See also Bug 6587.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19995</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-04-22 18:11:39 +0000</bug_when>
    <thetext>Since Bug 6587 covers onError() on chunks, rewording this to just cover Batchlet.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7361</bug_id>
          
          <creation_ts>2015-10-22 18:25:00 +0000</creation_ts>
          <short_desc>Provide a stop() call for chunk steps</short_desc>
          <delta_ts>2015-10-22 18:25:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>Other</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19359</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-22 18:25:40 +0000</bug_when>
    <thetext>There are cases where it can be useful for an application to get control on an operator stop command when the app is stuck within one of the read/process/write methods.  

Not sure what the best place to hang this off of would be.   Maybe a new method on the ChunkListener.   An alternative would be to use StepListener (though then it would probably apply to Batchlet as well and we&apos;d need to define the order).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7368</bug_id>
          
          <creation_ts>2015-10-28 19:58:00 +0000</creation_ts>
          <short_desc>add javax.batch.operations.JobOperator#getJobExecutions(long)</short_desc>
          <delta_ts>2016-03-23 17:23:46 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19372</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-10-28 19:58:07 +0000</bug_when>
    <thetext>JobOperator currently has getJobExecutions(JobInstance) method to get all job executions belonging to the jobInstance passed in as param. Notice the param type is JobInstance instead of jobInstanceId as long, whereas the rest of JobOperator getter methods take long.

Apart from being consistent, passing a long jobInstanceId is also more natural.  JobInstance, being a simple interface with only 2 methods (getInstanceId and getJobName), doesn&apos;t offer much more value than a simple jobInstanceId.

In case of a remote client, sometimes all it has is just the job instance id, not a JobInstance.  And JobOperator does not have method to return a JobInstance by job instance id (the one we do have is getJobInstance(jobExecutionId)).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19812</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-16 16:13:44 +0000</bug_when>
    <thetext>So the history here is that the JobOperator API at one point presented a lot of opportunities for errors, given all the &apos;long&apos; values in batch:  job instance, job execution, step execution.   (Often in unit tests these weren&apos;t caught for awhile as the various values were incremented in parallel.)

The decision was made to only use job execution id as an input parm across all method.  We also mostly return the JobInstance, JobExecution objs rather than long values, (with the exception of start/restart).

So we avoid the previous bugs by instead using:

    getJobExecutions(JobInstance) 

So, I think that we have from a consistency standpoint we have a reasonable story.

But like you said, the problem is this assumes my entry point into the job repository is the job execution id.   If you are starting from an instance id, it&apos;s going to be convoluted.

Obviously we can&apos;t just add:

  JobInstance getJobInstance(long jobInstanceId)

it would need to be: 

  JobInstance getJobInstanceByInstanceId(long jobInstanceId)

Maybe also consider:

  StepExecution getStepExecutionByStepExecutionId(long stepExecutionId)

Other suggestions?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19852</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2016-03-23 17:23:46 +0000</bug_when>
    <thetext>A good descriptive method name should be able to convey the intent of the api, so we don&apos;t have to be limited by &quot;job execution ids in params only&quot; rule. I think the need for such API (getting JobInstance by its id) is pretty common and reasonable.

getJobInstanceByInstanceId seems a bit too long.  Maybe getJobInstanceById(long jobInstanceId), or getStepExecutionById(long stepExecutionId) is descriptive enough?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7374</bug_id>
          
          <creation_ts>2015-11-02 14:46:00 +0000</creation_ts>
          <short_desc>Give app (ChunkListener?) control at end of chunk step, but before close()</short_desc>
          <delta_ts>2015-11-02 14:46:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19383</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-11-02 14:46:03 +0000</bug_when>
    <thetext>The use case here is to write some trailer/footer record(s).  

Today of course this could be done in Writer.close().

We could preserve that option and offer a bit more cleanly separated one by having ChunkListener#endOfStep (or beforeClose, or whatever we call it).  This could be called in the close tran, before reader/writer close().</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7375</bug_id>
          
          <creation_ts>2015-11-02 15:04:00 +0000</creation_ts>
          <short_desc>Facilitate chunk artifacts&apos; awareness that they&apos;re in retry-with-rollback processing</short_desc>
          <delta_ts>2015-11-04 15:48:53 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19384</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-11-02 15:04:11 +0000</bug_when>
    <thetext>It may be helpful for a reader/writer to know that the close()/open() is being driven via retry with rollback vs. &quot;normal&quot; open/close.

Perhaps it might also help to know that you&apos;re in &quot;one at a time&quot; mode though I haven&apos;t seen that really myself.

Was thinking that adding a flag to the step context ( possibly an enum of multiple states) could be helpful.

Would be interested to hear others&apos; thoughts.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19391</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-11-04 15:48:53 +0000</bug_when>
    <thetext>A similar idea (though probably deserving of its own issue), is allowing the processor and writer to know that the reader has read its last item ( has returned &apos;null&apos;)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7473</bug_id>
          
          <creation_ts>2016-01-11 15:25:00 +0000</creation_ts>
          <short_desc>provide API for determining whether or not current execution, or given execution is a restart</short_desc>
          <delta_ts>2016-01-11 15:32:23 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19587</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-11 15:25:18 +0000</bug_when>
    <thetext>This could be useful for certain applications for both JobContext and JobExecution.  

It&apos;s something the app could figure out but why not have the runtime figure out and make available</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19588</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-11 15:32:23 +0000</bug_when>
    <thetext>obviously for the context-based API, it would be the current execution that we&apos;d be querying.  But for a JobExecution it would be any given execution.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7474</bug_id>
          
          <creation_ts>2016-01-11 16:07:00 +0000</creation_ts>
          <short_desc>Provide API to flush persistent user data (esp. for batchlet)</short_desc>
          <delta_ts>2016-02-07 16:24:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19589</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-11 16:07:06 +0000</bug_when>
    <thetext>The spec says (in the StepContext#getPersistentUserData() Javadoc at least), that persistent user data is persisted as part of a checkpoint and when the step ends.

It might be nice for a batchlet though to be able to trigger a save/persist of the persistent user data using an API call ( would save the developer from having to invent his own solution).

It seems like the complete phrasing would have to take into account the fact that there might or might not be a transaction active (for the batchlet, it would not be one started by the batch container).   E.g. when persistence is supplied by a transactional database, and we get the &quot;flush&quot; or &quot;persist&quot; call, do we write to the DB as part of the current tran ( letting the app decide whether to commit or rollback)?  Or do we want/need to provide the ability to suspend an active global tran and immediately commit the DB update.   The immediately commit option could even be useful in a chunk step.

Seems like we need to at least consider all these cases.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19686</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-02-07 16:24:15 +0000</bug_when>
    <thetext>Another use case potentially would be for partitions, for the mapper and the reducer&apos;s beginPartitionedStep().  Since there&apos;s no chunk on the top-level thread, this isn&apos;t guaranteed to persist until the step ends, which is of no use if the JVM blows up.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7475</bug_id>
          
          <creation_ts>2016-01-11 17:23:00 +0000</creation_ts>
          <short_desc>Provide ability to set property with output of some earlier portion of the execution.</short_desc>
          <delta_ts>2016-01-12 17:10:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19590</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-11 17:23:38 +0000</bug_when>
    <thetext>See for example the discussion in:
https://java.net/projects/jbatch/lists/public/archive/2015-12/message/2</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19598</commentid>
    <comment_count>1</comment_count>
    <who name="">cf126330</who>
    <bug_when>2016-01-12 03:54:09 +0000</bug_when>
    <thetext>Continue the discussion from mailing list, one potential drawback with Dmitry&apos;s approach (adding property to batch.xml) is users will have to deal with 2 separate xml files (job.xml and batch.xml) to get all properties, and this is not very user-friendly. 

A property, when defined as a sub-element of a batch artifact, people would naturally think it is scoped within that parent element, though it can also be extended to support some sort of exporting semantics.  But to which part of the job is the exported property visible?  Is the exported property visible to the subsequent step, all following steps?  Is it visible to the immediate enclosing component, or all enclosing components (e.g., a item reader inside a step inside a flow inside a split...)

Adding a new place like #{jobContext[&apos;step2.fileName&apos;]} seems a better fit but also has its own complications.  we need to be careful not to confuse users with the current javax.batch.runtime.context.JobContext#getProperties.

It also implies jobContext will have an additional data container besides job transient user data, which essentially has the same purpose as the existing transient data.  Or we could re-use the current job transient user data, like

#{jobTransientData[&apos;fileName&apos;]}, to refer to a fileName property of the data bean, or a fileName key of the map-type value.  Since it&apos;s transient user data, it implies the data is mutable and exported to the entire job.

Ideally, I would avoid adding a new place like jobContext just for the purpose that is already fulfilled by current design.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19604</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-12 17:10:22 +0000</bug_when>
    <thetext>Cheng,

Agree batch.xml is the wrong place to expand into.  

Agree that we should start with a job-level scope rather than defining the syntax for substituting an output or inout property at a more granular scope.

So yes, this is steering us to an additional function on JobContext, potentially creating the dilemma &quot;do I put this in transient data or these new output properties?&quot; (not to mention, like you noted, it&apos;s a bit surprising when you learn that JobContext#getProperties supplies only the non-writable children of the job-level properties.)

One more note:  given that JobContext is &quot;thread-local&quot; (in the parallel batch sense), setting transient data on the partitions and split-flow JobContexts don&apos;t propagate up.  This too could be a burden placed on the application to deal with if necessary, like it is for transient data.

I still think this is useful enough that all of those issues are worth considering and overcoming.   

If the property value were always coming from app code it&apos;s a stronger case that the 1.0 function is enough and do it yourself.

But the ability to supply defaults and overrides seems compelling to me..

E.g. calculate file from step 2 with job parm override:

  &lt;property name=&quot;fileName&quot; value=&quot;#{jobParameters[&apos;step2.fileName&apos;]}?#{jobContext[&apos;step2.fileName&apos;]}&quot; /&gt;
 

Maybe we can think up decent names to go along with this?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7479</bug_id>
          
          <creation_ts>2016-01-12 18:28:00 +0000</creation_ts>
          <short_desc>Disallow certain characters in job, step, flow, split &amp; decision id string values</short_desc>
          <delta_ts>2016-01-12 18:28:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19605</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2016-01-12 18:28:33 +0000</bug_when>
    <thetext>The spec should give a clear rules which chars are allowed and not allowed in job, step, decision, flow and split id string values. This will help apps save and exchange job data more easily and consistently.

The spec currently only says they are valid &quot;XML string value&quot; (more accurately ID).

Some obvious blacklist chars: whitespace anywhere \ / = , * # { } ? :

. (dot) should be allowed.

For instance, I need to store a list of job ids, separated by some delimiter. I should be able to pick one that is guaranteed will not appear in any job id.

A maximum length of id will also help.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7647</bug_id>
          
          <creation_ts>2016-04-25 15:52:00 +0000</creation_ts>
          <short_desc>NoSuchJobException vs. 0/empty results on getRunningExecutions() etc.</short_desc>
          <delta_ts>2016-04-25 15:52:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>20004</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-04-25 15:52:30 +0000</bug_when>
    <thetext>See discussions:
https://java.net/projects/jbatch/lists/public/archive/2016-04/message/4

https://java.net/projects/jbatch/lists/public/archive/2015-02/message/4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7656</bug_id>
          
          <creation_ts>2016-05-02 10:12:00 +0000</creation_ts>
          <short_desc>Add a progress API</short_desc>
          <delta_ts>2016-05-03 06:21:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>struberg</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>20031</commentid>
    <comment_count>0</comment_count>
    <who name="">struberg</who>
    <bug_when>2016-05-02 10:12:07 +0000</bug_when>
    <thetext>Got some interesting feature request from our ops team. 

They like to get some feedback about the &apos;progress&apos; of a current batch run. E.g. &quot;32500 of 248494 items processed&quot; 

While I can give them the current Metrics we still don&apos;t know what the total sum will be. 
Of course it&apos;s not always possible to provide the whole sum upfront, but sometimes it is.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>20032</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-05-02 19:54:14 +0000</bug_when>
    <thetext>So would you net this out into a proposal for a new metric: expectedCount?   

We&apos;d also have to invent an API for the app notifying the container what the value is (and constraining with any rules we&apos;d come up with).

Kind of an odd fit though with all the other metrics set by the container.   

Maybe a better fit would be to extend metrics with a set of app-provided key/value pairs?  Part of the rationale would be that it&apos;s a place to stuff things other than the persistent user data so you don&apos;t need to be able to deserialize the user data class to read it.

Probably should consider the behavior under rollback...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>20037</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2016-05-03 02:30:31 +0000</bug_when>
    <thetext>Some data sources do not support the notion of total number of items. For instance, an item reader pulling messages from a destination, where there may always be new messages coming in.  In other data sources, it&apos;s possible to get a total (for example, a CSV file), but it means the batch runtime will do extra loading-sensing first, which doesn&apos;t fit well with the current read-till-end approach.

Another way is to address it at application level. The app can get the total number of items in other means, even with a batchlet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>20042</commentid>
    <comment_count>3</comment_count>
    <who name="">struberg</who>
    <bug_when>2016-05-03 06:21:24 +0000</bug_when>
    <thetext>&gt; Some data sources do not support the notion of total number of items.
Yes of course. But in some cases it&apos;s very doable.

I hope the goal is clear now, and while it is not technically possible to know the sum count in all cases (e.g. streaming), it pretty often can be accomplished and is an important information for for Ops. They just need to have an idea if they should let a batch run for 5 further minutes (because it is almost done), or if they should better suspend it because it&apos;s not close to be finished.

I didn&apos;t liked to add my initial idea to the problem description because I&apos;m a big fan of separating the &apos;problem description&apos; from a &apos;possible solution&apos;. Most of the time this gets mixed up by analysts and you end up not knowing what the real goal is (and imo that separates the good from the bad ones), but anyway - different topic ;)


My first idea was to add an additional interface like which could be implemented by the either a Batchlet or a ItemReader. Something like

interface FiniteProcessing {
  long getSummaryCount();
}

Of course we need to define what number we return for a suspended or restarted step. The whole sum or just the sum at the step (re)start?

Of course only a rough idea up for discussion...</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7684</bug_id>
          
          <creation_ts>2016-05-25 20:45:00 +0000</creation_ts>
          <short_desc>Provide capability to avoid having a global transaction around open and close</short_desc>
          <delta_ts>2016-05-25 20:45:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>20105</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-05-25 20:45:26 +0000</bug_when>
    <thetext>The reasons for wanting to possibly avoid a global tran around open and close are distinct from each other, but it might be desirable to consider adding any new configuration in some similar, parallel way.

For close, just because we fail closing one of the reader/writer, do we really want to rollback any updates made to the other?  What are we trying to coordinate here?   Some overlap with Bug 5760. 

For open, the desire to avoid a global tran on open may extend to wanting to avoid a global tran during each chunk as well.   Not sure if we&apos;ll get to considering that.  Another more narrow case would be simply to bypass the normal transaction timeout which would otherwise hit.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>112710</bug_id>
          
          <creation_ts>2016-09-14 15:00:00 +0000</creation_ts>
          <short_desc>Clarify step exit status from batchlet process method return value and StepContext.setExitStatus</short_desc>
          <delta_ts>2016-09-14 15:00:35 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>NEW</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>129907</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2016-09-14 15:00:35 +0000</bug_when>
    <thetext>Applications can set step exit status by calling StepContext.setExitStatus(...).  And a batchlet process() method can return a string value as the step exit status, too.  We need to have rules how to reconcile the 2 sources of step exit status.

In testSplitFlowContextPropagation test, inside the test batchlet&apos;s process() method, it calls stepContext.setExitStatus() to record test data, and returns something else (GOOD_EXIT_STATUS).

The test expects the eventual step exit status to be the test data set to the stepContext inside batchlet process() method. 

But in JBeret, the step exit status is set to the return value of batchlet process() method, because the process method return value happens after setExitStatus() calls.

See spec list discussion:
https://java.net/projects/jbatch/lists/public/archive/2016-09/message/0</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4798</bug_id>
          
          <creation_ts>2013-03-15 03:28:00 +0000</creation_ts>
          <short_desc>SPEC - document concurrency and thread-safetyness requirement in JobOperator</short_desc>
          <delta_ts>2015-10-01 13:47:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>ASSIGNED</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12897</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-15 03:28:18 +0000</bug_when>
    <thetext>Should have some javadoc in JobOperator to cover concurrency and thread-safety aspect.

For example, is it supported if multiple client threads access the same JobOperator instance, starting/stopping/restarting the same or different job?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12902</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 17:50:32 +0000</bug_when>
    <thetext>For what it&apos;s worth we&apos;re not doing a whole lot in the RI.. even in the Glassfish environment where we&apos;ve introduced a purge.

The burden of consistency and synchronization is on the end user / batch admin... though we took another pass fixing our RI tables and at least have some DB-level consistency.

We won&apos;t have time to code anything else here.. so probably you&apos;ll have to use loose language (i.e. up to implementation) here.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12928</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:23:55 +0000</bug_when>
    <thetext>I need to think this one over a little more.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15137</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 13:12:33 +0000</bug_when>
    <thetext>Not committing to address in future, just listing as candidates and pointing out they&apos;re excluded from current Maintenance Rel.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4739</bug_id>
          
          <creation_ts>2013-03-08 20:30:00 +0000</creation_ts>
          <short_desc>SPEC - JSL does not refer to the interfaces required</short_desc>
          <delta_ts>2015-10-01 13:47:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>ASSIGNED</bug_status>
          <resolution></resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12763</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:30:03 +0000</bug_when>
    <thetext>Throughout section 8 where the various JSL elements are defined, most of those elements must be associated with an implementation of a particular interface.  While one could assume that association, it may be a bit more explicit to say in each section.  For example, 8.2.1.1 (Reader) would identify that the ref must refer to a class that implements the ItemReader interface.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12804</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:17:44 +0000</bug_when>
    <thetext>yeah, clarification does not hurt ...</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4518</bug_id>
          
          <creation_ts>2013-01-15 23:48:00 +0000</creation_ts>
          <short_desc>Both ItemReader and ItemWriter should extend AutoCloseable</short_desc>
          <delta_ts>2013-01-24 23:47:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P1</priority>
          <bug_severity>blocker</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>keilw</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>chrisschaefer</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12049</commentid>
    <comment_count>0</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-01-15 23:48:43 +0000</bug_when>
    <thetext>The interfaces 
javax.batch.api.ItemReader and
javax.batch.api.ItemWriter
contain identical copies of 
java.lang.AutoCloseable http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html

To allow &quot;try-with-resources statement.&quot; and generally integrate with Java EE 7 and SE 7 (according to EE 7 Umbrella Spec Lead Linda it shall be assumed as basis for EE 7) both interfaces should extend AutoCloseable, not redeclare the close() method with an identical signature.

Should I have overlooked any other part of the spec with a similar close() method, please act accordingly there.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12114</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 14:51:44 +0000</bug_when>
    <thetext>ItemReader and ItemWriter are the only interfaces that define a close method.  Both interfaces define a contract between application and container (batch runtime). The application never calls methods on these interfaces; only the container does. So while we can certainly change these interfaces to extend autocloseable(or closeable), it is important to recognize no user code will use implementations of either interface as a resource in a try-with-resources statement. Is extending autocloseable still the right thing to do?  Perhaps for consistency with other IO-oriented classes?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12134</commentid>
    <comment_count>2</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-01-17 16:42:24 +0000</bug_when>
    <thetext>Thanks for the update.
AutoCloseable is located in java.lang and is not directly related to IO, but any form of &quot;resource&quot; access where something that is opened by API (regardless of whether the user may call it directly or not) must be closed when it is no longer needed.

Unless you say, the close() methods on each of these two interfaces aren&apos;t necessary at all, I highly recommend extending AutoCloseable instead of reinventing the wheel in each of them.

Please see http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html for all subinterfaces, this goes as far as music clips in Java Sound, not just traditional IO.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12187</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 17:41:10 +0000</bug_when>
    <thetext>ItemReader and ItemReader will be changed to implement AutoCloseable in v1.1 of the proposed final draft.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12197</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 20:25:05 +0000</bug_when>
    <thetext>Chris,

I just saw this issue.  AutoCloseable is new as of 1.7.  Are we increasing the minimum JDK version supported for this JSR to 1.7 (it has been 1.6 up to now per section 3)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12203</commentid>
    <comment_count>5</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-19 17:53:16 +0000</bug_when>
    <thetext>FWIW I would suggest keeping the minimum JDK version at 6. New versions are adopted over a long period of time and most projects I come across are still on older versions and/or just making the migration to 6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12204</commentid>
    <comment_count>6</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-01-19 22:54:18 +0000</bug_when>
    <thetext>When I spoke to Linda, she said, Java 7 was basis for EE7. Ask her, what to do, but I would not use a JDK that&apos;s dead as of Feb 2013(!) in a JSR aiming for Final in April.
Backports for Java 6 may be worth a thought, but the EE 7 Version should allign with EE/SE7.
If IOException worked to be thrown, you may also consider Closeable from IO package, which exists since Java 6. And extends AutoCloseable as of 7.
After all Batch items normally could be considered File based;-)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12205</commentid>
    <comment_count>7</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-20 00:46:03 +0000</bug_when>
    <thetext>While JDK 6 may be &quot;dead&quot; in Feb 2013, the point is not everybody can just jump to another version for various reasons. I&apos;m still working on projects that use 1.4 with no plans to upgrade.

In regards to recent versions, 1.6 seems to be most prevalent. Unfortunately I haven&apos;t run into any projects in the enterprise space that are using 1.7 yet.

Obviously this is based on my experiences but I think requiring the use of 1.7 (just for AutoCloseable) may result in slow adoption. 

Just my 2c</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12206</commentid>
    <comment_count>8</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-20 04:40:41 +0000</bug_when>
    <thetext>I would argue that, as Chris brought up in his original response to this issue, the AutoClosable interface would be of limited (at best) usefulness for an ItemReader or ItemWriter.  As he points out, the open and close methods are not called as part of the public API, and even if it was, there isn&apos;t a concrete association with an ItemReader/ItemWriter with a resource.  It could be accessing a file, a database, a method on an object, a web service, etc.  The coupling of this to a resource like this doesn&apos;t make sense to me.

However, the cost of adding it and changing the required JDK version to 1.7 is huge IMHO.  I&apos;d vote for not implementing this interface and keeping the JDK requirement at 1.6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12268</commentid>
    <comment_count>9</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 01:49:50 +0000</bug_when>
    <thetext>Reopening for Java 1.6 consideration.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12302</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 23:09:32 +0000</bug_when>
    <thetext>Comments #1 and #8 make it clear there is no application developer benefit to implementing AutoCloseable.  

Comment #7 and correspondence on the JSR 352 EG mailing list offer emperical evidence that it will take time before SE7 usage is pervasive. We want this JSR to have as broad a base as possible as soon as possible. 

Since implementing the AutoCloseable interfaces on ItemReader/ItemWriter is the ONLY thing that would force JDK 7 to be the minimum level,  I believe the right trade off in light of these considerations is to NOT implement AutoCloseable afterall. 

The redundancy of the close() signature on ItemReader/ItemWriter seems a small sacrifice for the benefit derived.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12305</commentid>
    <comment_count>11</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-01-24 23:26:43 +0000</bug_when>
    <thetext>If neither ItemReader nor ItemWriter are part of the public API to be called by a Batch application, then please explain, why they are located in
javax.batch.api
not
javax.batch.runtime?

If they&apos;re only called by the container, that other than different packages would seem like a more logical place. As API should be reserved for the Public API users of the Spec and their applications would actually call.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12307</commentid>
    <comment_count>12</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 23:47:12 +0000</bug_when>
    <thetext>(In reply to comment #11)

That&apos;s a good question. Maybe we can reason together to come up with the right answer.  I put them in the javax.batch.api package because the application developer does implement those interfaces.  However, the application developer does not invoke those methods directly,  the container does.  

For example, the developer implements an item reader that reads postings from a file:

public PostingReader implements ItemReader &lt;Posting&gt; { 
   @Override
   public void open() throws Exception { 
      // logic to open some file 
   }
   @Override
   public Posting readItem() throws Exception { 
      // read next record from file and return domain object 
   }
   public void close() throws Exception { 
      // logic to close file 
   }
}

This item reader could then be used in a job:

&lt;job id=&quot;PostingJob&quot;/&gt;
    &lt;step id=&quot;DoPostings/&gt;
    &lt;chunk item-count=100&gt;
       &lt;reader id=&quot;PostingReader&quot;/&gt;        
       &lt;processor id=&quot;PostingProcessor&quot;/&gt;
       &lt;writer id=&quot;PostingWriter&quot;/&gt;
    &lt;/chunk&gt;
    &lt;/step&gt;
&lt;/job&gt;

Some application would then use JobOperator to run the job:

JobOperator jobOp= JobOperatorFactory.getJobOperator();
jobOp.start(&quot;PostingJob&quot;);

FYI, JobOperator is in package javax.batch.operations; 


The result would be the batch runtime would start the job named PostingJob and while processing step &quot;DoPostings&quot; would invoke open() on both PostingReader and PostingWriter, then enter the read/process/write loop (i.e. container invokes PostingReader.readItem/PostingProcessor.processItem/PostingWriter.writeItem repetively) until all items are processed, and then invoke close() on both PostingReader and PostingWriter.

So what package would you put ItemReader/ItemWriter in?

&gt; If neither ItemReader nor ItemWriter are part of the public API to be called by
&gt; a Batch application, then please explain, why they are located in
&gt; javax.batch.api
&gt; not
&gt; javax.batch.runtime?
&gt; If they&apos;re only called by the container, that other than different packages
&gt; would seem like a more logical place. As API should be reserved for the Public
&gt; API users of the Spec and their applications would actually call.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6105</bug_id>
          
          <creation_ts>2014-05-29 21:24:00 +0000</creation_ts>
          <short_desc>Couldn&apos;t run &quot;mvn clean install&quot; on JSR352.API direcotyr</short_desc>
          <delta_ts>2015-05-22 13:59:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P2</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mk111283</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15933</commentid>
    <comment_count>0</comment_count>
    <who name="">mk111283</who>
    <bug_when>2014-05-29 21:24:00 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15935</commentid>
    <comment_count>1</comment_count>
      <attachid>138</attachid>
    <who name="">mk111283</who>
    <bug_when>2014-05-29 21:25:19 +0000</bug_when>
    <thetext>Created attachment 138
output from running &quot;mvm clean install&quot; using JDK 8

output from running &quot;mvm clean install&quot; using JDK 8</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15937</commentid>
    <comment_count>2</comment_count>
    <who name="">mk111283</who>
    <bug_when>2014-05-29 21:28:08 +0000</bug_when>
    <thetext>This issue occurs only on jdk8 and not on jdk7.
Steps to reproduce:

Set JAVA_HOME to a JDK installation.

1. get the latest sources from the git repo
2. cd JSR352.API
3. mvm clean install

You will see the attached errors during javadoc generation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15953</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-05-30 22:08:34 +0000</bug_when>
    <thetext>Seems that Java 8&apos;s Javadoc has gotten more strict:

  http://blog.joda.org/2014/02/turning-off-doclint-in-jdk-8-javadoc.html

  http://stackoverflow.com/questions/22528767/jdk8-and-javadoc-has-become-very-strict

but there&apos;s a simple way to turn this off in Maven.

Hesitating while I think which way I want to fix this..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18415</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-05-22 13:58:59 +0000</bug_when>
    <thetext>Brent fixed this in 
https://github.com/WASdev/standards.jsr352.jbatch/pull/13

Thanks!</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>138</attachid>
            <date>2014-05-29 21:25:00 +0000</date>
            <delta_ts>2014-05-29 21:25:19 +0000</delta_ts>
            <desc>output from running &quot;mvm clean install&quot; using JDK 8</desc>
            <filename>javadoc.errors.txt</filename>
            <type>text/plain</type>
            <size>11516</size>
            <attacher>mk111283</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>6680</bug_id>
          
          <creation_ts>2015-01-26 16:12:00 +0000</creation_ts>
          <short_desc>jbatch RI doesn&apos;t work with Oracle Database</short_desc>
          <delta_ts>2015-05-22 13:41:59 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P2</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mk111283</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17515</commentid>
    <comment_count>0</comment_count>
    <who name="">mk111283</who>
    <bug_when>2015-01-26 16:12:16 +0000</bug_when>
    <thetext>While running GlassFish with batch 1.0.1 with Oracle Database, the following is thrown:

&quot;SQLException: ORA-00933: SQL command not properly ended&quot;



I added the System property, oracle.jdbc.Trace=true and also set com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl logger to FINEST.


[2015-01-25T18:16:28.159-0800] [glassfish 4.1] [CONFIG] [] [oracle.jdbc.driver] [tid: _ThreadID=27 _ThreadName=http-listener-1(1)] [timeMillis: 1422238588159] [levelValue: 700] [[
  609B1BA0 SQL: select A.jobexecid, A.jobinstanceid, A.createtime, A.starttime, A.endtime, A.updatetime, A.parameters, A.batchstatus, A.exitstatus, B.name from executioninstancedata as A inner join jobinstancedata as B ON A.jobinstanceid = B.jobinstanceid where A.jobinstanceid = ?
java.lang.Throwable: No Error
        at oracle.jdbc.driver.OracleStatement.doExecuteWithTimeout(OracleStatement.java:1279)
        at oracle.jdbc.driver.OraclePreparedStatement.executeInternal(OraclePreparedStatement.java:4485)
        at oracle.jdbc.driver.OraclePreparedStatement.executeQuery(OraclePreparedStatement.java:4566)
        at oracle.jdbc.driver.OraclePreparedStatementWrapper.executeQuery(OraclePreparedStatementWrapper.java:5251)
        at com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.executeQuery(PreparedStatementWrapper40.java:642)
        at com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl.jobOperatorGetJobExecutions(JDBCPersistenceManagerImpl.java:1382)
        at com.ibm.jbatch.container.api.impl.JobOperatorImpl.getJobExecutions(JobOperatorImpl.java:176)
....


Throwing SQLException: ORA-00933: SQL command not properly ended</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17518</commentid>
    <comment_count>1</comment_count>
    <who name="">mk111283</who>
    <bug_when>2015-01-26 16:29:18 +0000</bug_when>
    <thetext>This issue has been reported in GLASSFISH-21022 also. Since, this issue is really an RI issue, I am filing here.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17519</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-01-26 20:33:17 +0000</bug_when>
    <thetext>Hmmm...  I guess we missed some AS usages in the earlier commit.  Sorry about that.

I released 1.0.1-b07 of the RI to fix this.  I&apos;m not testing against Oracle DB myself, note, just inspecting the code for AS instances.

Fixed in GitHub at commit f64f19035868cca8ea98dad61742080d2919be5e</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18413</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-05-22 13:41:59 +0000</bug_when>
    <thetext>Marking resolved, soon to be released as 1.0.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7481</bug_id>
          
          <creation_ts>2016-01-14 05:51:00 +0000</creation_ts>
          <short_desc>The BatchUtils doesn&apos;t purge data in all tables</short_desc>
          <delta_ts>2016-01-14 15:11:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P2</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>haotian</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>haotian</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19611</commentid>
    <comment_count>0</comment_count>
    <who name="">haotian</who>
    <bug_when>2016-01-14 05:51:00 +0000</bug_when>
    <thetext>When using BatchSPIManager.getInstance().getBatchJobUtil().purgeOwnedRepositoryData(tagName);

Then &quot;CheckPoint&quot; table was never cleared, although this table is for batch internal use, but it will leave a lot of garbage data over the time.

So this table should also be cleared after calling the API.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19614</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-01-14 15:11:07 +0000</bug_when>
    <thetext>Since this is a pure impl issue (not spec), moving to:
https://github.com/WASdev/standards.jsr352.jbatch/issues/44

Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4589</bug_id>
          
          <creation_ts>2013-01-24 23:45:00 +0000</creation_ts>
          <short_desc>Wrong license header in all Spec (API) files and License.txt</short_desc>
          <delta_ts>2013-02-22 20:56:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P4</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>keilw</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12306</commentid>
    <comment_count>0</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-01-24 23:45:17 +0000</bug_when>
    <thetext>When looking into files like ItemReader, ItemWriter, etc. I stumbled over a wrong License header in all files under the JSR352.API module.

That module is the &quot;Spec&quot; as far as one can see, no TCK or RI included. 
Thus the Spec License like in the JSR page applies and an appropriate header should declare that. Currently all files say they&apos;re licensed under Apache 2.0 which is incorrect.

Same goes for the Licence.txt file in the top level Maven project, this shall be moved into appropriate sub-modules like JSR352.Tests.TCK or similar. And JSR352.API get a License.txt with the right license, like found in http://jcp.org/aboutJava/communityprocess/licenses/jsr352/352-spec-license.pdf</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12317</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 17:04:11 +0000</bug_when>
    <thetext>Noted. We will resolve before final approval ballot.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12660</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-22 17:40:08 +0000</bug_when>
    <thetext>I consulted my legal team and they inform me all content delivered in the RI, including the javax.batch.* files, must carry the RI license.  Only the spec carries the spec license.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12664</commentid>
    <comment_count>3</comment_count>
    <who name="">keilw</who>
    <bug_when>2013-02-22 19:51:52 +0000</bug_when>
    <thetext>(In reply to comment #2)
&gt; I consulted my legal team and they inform me all content delivered in the RI,
&gt; including the javax.batch.* files, must carry the RI license.  Only the spec
&gt; carries the spec license.

Well, there&apos;s a wide misunderstanding on what is &quot;Spec&quot; and what is &quot;API&quot;, the latter legal departments not just yours seems to consider identical to RI.

The argument is taken and carried into the relevant JSR 358 JIRA ticket and WG discussion. 
See http://java.net/jira/browse/JSR358-49 for your info and reference. Feel free to share with legal, though there might be someone by IBM in the 358 WG anyway.

Most recent Red Hat proposal looks closest to resolving this issue and possibly eliminating or simplifying that &quot;Spec&quot; license dilemma, a license effectively just for a piece of paper that&apos;s worthless and irrelevant when the API and Spec are really consumed in every day life. Nobody even cares about that Spec license once the Spec/API RI or TCK are used out there either via Maven or inside a Java EE based product.

Thanks for your input.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12665</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-22 20:56:31 +0000</bug_when>
    <thetext>Keil, thanks for the additional information.  It is interesting to see this issue is more wide spread than just JSR 352.   I am glad to see you have initiated action to resolve this globally.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4171</bug_id>
          
          <creation_ts>2012-09-28 15:43:00 +0000</creation_ts>
          <short_desc>ChunkContext is missing</short_desc>
          <delta_ts>2013-02-05 20:09:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11194</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:43:52 +0000</bug_when>
    <thetext>There are places where a ChunkContext would be useful.  Spring Batch does have this context.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11217</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:11:30 +0000</bug_when>
    <thetext>Why is step context insufficient?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12080</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:17:32 +0000</bug_when>
    <thetext>chunk context was not added</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12162</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 14:45:41 +0000</bug_when>
    <thetext>After reviewing the current version of the spec, I&apos;d like to reopen this issue.  A ChunkContext would be very valuable in the context of a partitioned step.  I would expect since there is a single step involved, that there would be one StepContext.  This potentially can lead to issues of partitions stepping on each other during it&apos;s use.  Introducing a ChunkContext would make sense in at least this scenario.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12163</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-18 14:49:13 +0000</bug_when>
    <thetext>Michael,

In 6.4.1.1 it does say for each of JobContext/StepContext that each thread gets its own copy of the context...e.g.:

 &quot;For a partitioned step, there is one StepContext for the parent step/thread; there is a distinct StepContext for each sub-thread.&quot;

Does that address your concern?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12165</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 14:57:48 +0000</bug_when>
    <thetext>And to add to Scott&apos;s comment.  Each partition has access to a cloned copy of the job and step context so there are no synchronization concerns.  The partitions are free to write into their copy of the context,  but  those changes are not coalesced in any form into the original contexts.  The developer can use the PartitionCollector to pass data from each partition to the PartitionAnalyzer,  which in turn can coalesce store that data in the original contexts.  The collector runs on a partitions thread;  the analyzer runs on the step main thread.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12280</commentid>
    <comment_count>6</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 04:24:41 +0000</bug_when>
    <thetext>To Comment#4:  This might satisfy the concern but I&apos;m realizing I didn&apos;t quite understand the relationship of stepExecutionContexts to partitioning.  For example, in SB you can see that we do create separate step execution contexts for each partitioned step (see http://static.springsource.org/spring-batch/reference/html-single/index.html#partitioning).  I&apos;m realizing that this probably corresponds to a partition plan + the cloned step context but how we inject the key and name into the context in translating this to jsr352 isn&apos;t quite clear yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12287</commentid>
    <comment_count>7</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 15:52:20 +0000</bug_when>
    <thetext>Chris&apos;s clarification of Scott&apos;s comment is actually my concern.  If I am processing within a chunk and I make a change to the StepContext, I would expect that to be available to everyone within the step.  Yet according to Chris&apos;s clarification, it would not be because I&apos;d only be updating a clone.  In SB, having a separate ChunkContext allows us to not run into this confusing scenario.  Taking the cloned context approach as Chris proposes, this allows for no shared state across partitions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12290</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 19:28:36 +0000</bug_when>
    <thetext>(In reply to comment #6)

To what key and name do you refer?  

&gt; To Comment#4:  This might satisfy the concern but I&apos;m realizing I didn&apos;t quite
&gt; understand the relationship of stepExecutionContexts to partitioning.  For
&gt; example, in SB you can see that we do create separate step execution contexts
&gt; for each partitioned step (see
&gt; http://static.springsource.org/spring-batch/reference/html-single/index.html#partitioning).
&gt;  I&apos;m realizing that this probably corresponds to a partition plan + the cloned
&gt; step context but how we inject the key and name into the context in translating
&gt; this to jsr352 isn&apos;t quite clear yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12292</commentid>
    <comment_count>9</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 19:55:40 +0000</bug_when>
    <thetext>(In reply to comment #7)

Questions of my own:

1) what is in a chunk context?
2) what is the advertised purpose of the chunk context?
3) what is the cardinal relationship of a chunk context with a partition?
4) what is the sharing scope of a chunk context?
5) are chunk contexts available to non partitioned steps?

The following must be said about the partition model currently in the spec to continue this discussion:

1) It is designed so the programming model at the reader/writer/processor level is no different for partitioned vs non-partitioned execution. So StepContext is available whether partitioned or not. 

Note not all chunk type steps write to their step context - remember, the checkpointing model specified by the JSR persists checkpoint data via an explicit contract between runtime and reader/writer,  not by persisting a context.

Now that is not to say the step context does not have a persistent field. It does, which batch artifacts may optionally use.  It is stored at each checkpoint or end of step, whichever comes first. However, this persistent field is not part of the checkpoint/restart contract of the reader/writer. It is for other data the step implementation may which to persist and get back upon restart - e.g. user-defined metrics, interrim calculations, other. 

2) Partitions can contribute information to the overall step outcome. 

Partitioned steps may push data from each partition to a step-level coalescing point using PartitionCollector/PartitionAnalyzer artifacts. This makes it possible to take data from each partition&apos;s step context copy and send it to a consistent point for merger into the master copy step context.  

This allows for sharing in a thread safe manner without the user writing thread safe code with synchronizations.  All of which would violate principle #1 above.
Moreover, the PartitionCollector/PartitionAnalyzer artifacts can be added when and if needed without disturbing the core reader/processor/writer logic. You would need them if the step artifacts were writing to the step context that needed to be collected together for the entire step.  

&gt; Chris&apos;s clarification of Scott&apos;s comment is actually my concern.  If I am
&gt; processing within a chunk and I make a change to the StepContext, I would
&gt; expect that to be available to everyone within the step.  Yet according to
&gt; Chris&apos;s clarification, it would not be because I&apos;d only be updating a clone. 
&gt; In SB, having a separate ChunkContext allows us to not run into this confusing
&gt; scenario.  Taking the cloned context approach as Chris proposes, this allows
&gt; for no shared state across partitions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12472</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 17:47:11 +0000</bug_when>
    <thetext>Let me summarize my position on this subject:

Chunk context will not be added.

Each partition has a step context clone. The scope of this clone is partition-local.  The reason is so partition vs non-partition programming model is the same.   

A step that needs to coalesce partition-local values to the master step context may do so by using partition collector/analyzer pair.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12499</commentid>
    <comment_count>11</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 20:09:24 +0000</bug_when>
    <thetext>Didn&apos;t mean to reopen this one.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4174</bug_id>
          
          <creation_ts>2012-09-28 16:03:00 +0000</creation_ts>
          <short_desc>Missing XSD for batch.xml</short_desc>
          <delta_ts>2013-02-22 17:35:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11197</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 16:03:16 +0000</bug_when>
    <thetext>The spec identifies two different types of XML files.  One to configure a job in (via the JSL) and another to configure the artifact factory and transaction manager (batch.xml).  Previous issues have identified that the spec needs an XSD for the job one and issues have been logged about the one included in the RI.  However, the batch.xml also needs an XSD included in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11236</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:00:57 +0000</bug_when>
    <thetext>True enough.  It will be added.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12076</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:12:07 +0000</bug_when>
    <thetext>argh, still missing it in the proposed final draft.   we will add to an interim update before final approval ballot</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12192</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:36:13 +0000</bug_when>
    <thetext>Reopened for tracking purposes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12659</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-22 17:35:39 +0000</bug_when>
    <thetext>batch.xml XSD is in PFD v4.1</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4284</bug_id>
          
          <creation_ts>2012-11-09 21:45:00 +0000</creation_ts>
          <short_desc>Do we need skip/retry or at least callback w/ exception for error on chunk commit?</short_desc>
          <delta_ts>2013-02-05 22:18:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11492</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 21:45:58 +0000</bug_when>
    <thetext>This just restates my email on the subject.

To summarize:  I think for JPA, writes typically will get flushed on commit, not writeItems(), upon which the user might want to progammatically react to an exception involving his application code, like he would via a skip listener for an error on writeItems().

Should we extend skip/retry to  this case?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11589</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:45:09 +0000</bug_when>
    <thetext>Flush is the call to ItemWriter.  You can explicitly control flush and commit behavior as follows:

checkpoint-algorithm=item
commit-interval=10
buffer-size=10

That flushes after 10 items and commits.  However, it is valid to flush multiple times before a commit - think of JDBC batching, for instance.  

Skip/retry is available after read, process, and write,  so I think we&apos;re covered.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11961</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-03 16:55:53 +0000</bug_when>
    <thetext>Chris,

I don&apos;t think I made my point clear...

So if I have:

 checkpoint-algorithm=item
 commit-interval=10
 buffer-size=10

then yes I am flushing and committing at the same time.   That&apos;s not the problem.

The problem is that writeItems() might not really do anything because of some buffering downstream... e.g. I used the example of a JPA scenario where write might update some Java fields but the database doesn&apos;t get touched until the tran commits.

It is only on tran commit that the database throws an exception that I wish I could recover from (skip/retry), but I can&apos;t...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11975</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-04 19:33:11 +0000</bug_when>
    <thetext>Ok, now I see your point. The declarative retry specification in a job definition currently applies to exceptions thrown by only reader, processor, and writer artifacts.  We should consider having it apply to exceptions thrown by exception that occurs during step processing. If the exception happens to be thrown by reader, processor, or writer,  there is a matching retry listener that the developer can supply. All other exceptions should probably go through a separate, &quot;retry step&quot; listener.  I also see a need for a point of control after rollback and before starting a new tran to allow for custom processing - e.g. inserting a retry delay.  I further see a need for a callback that receives control when retry is abandoned - e.g. retry limit is up.  The purpose of such a callback would be for things like compensation logic.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12037</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-14 13:49:36 +0000</bug_when>
    <thetext>onException methods were added to StepListener and JobListener to cover this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12310</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-25 03:55:53 +0000</bug_when>
    <thetext>Chris,  for the new Job/StepListener.onException() methods... 

1. Do we intend that they be called on any exception?   Or only on exceptions that are not thrown on read/process/write?   Or.. for read/process/write exceptions.. only those that are not caught/handled by skip/retry listeners?

Any ordering required to be specified if multiple listeners are involved?  Otherwise this is undefined which may be OK...

2. It seems you decided for them not to participate in skip/retry.   I know there are some details to pin down and it wouldn&apos;t be trivial to do so, but that was my original question/suggestion.. so I wanted to make sure that you didn&apos;t intend but forget to include this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12312</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-25 05:40:52 +0000</bug_when>
    <thetext>I think I&apos;m seeing now where this wording is found.. you can probably ignore this one now.. I imagine the XSD at least still needs an update if you want to keep this open to remind us.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12473</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 18:32:28 +0000</bug_when>
    <thetext>The spec introduced StepListener.onException and JobListener.onException as an initial response to this bug.  Those callbacks are overly broad in scope. We need something like ChunkListener.onCommitError.  

I propose we remove StepListener.onException and JobListener.onException and add ChunkListener.onCommitError.  

It was intended all the while that Skip and exclude classes should apply also to chunk commit.  That didn&apos;t make it into the last spec update.  It will be PFD v1.3.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12480</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 23:26:24 +0000</bug_when>
    <thetext>*** Bug 4548 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12481</commentid>
    <comment_count>9</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 23:27:57 +0000</bug_when>
    <thetext>The method name will be onError and it will be invoked for any failure in chunk processing that results in the chunk transaction getting rolled back.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12504</commentid>
    <comment_count>10</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 22:18:50 +0000</bug_when>
    <thetext>I had a question about this one.  For the onError, how are we providing the method with some form information on what the error was?  In Spring Batch we provide the ChunkContext (which contains the exception that caused the error) in the ChunkListener#afterChunkError().</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4294</bug_id>
          
          <creation_ts>2012-11-12 14:46:00 +0000</creation_ts>
          <short_desc>Batch status should be an enum</short_desc>
          <delta_ts>2013-01-17 14:39:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11505</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-12 14:46:24 +0000</bug_when>
    <thetext>Batch status has a finite number of state, so why is it implemented as a string and not as an enum (see JobExecution, StepExecution, etc)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11585</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:03:40 +0000</bug_when>
    <thetext>It is implemented as string for consistency with exit status, which is user defined and a string for readability on Job XML elements such as end, stop, and fail.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12104</commentid>
    <comment_count>2</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2013-01-16 21:37:08 +0000</bug_when>
    <thetext>Why is it needed to have consistency between batch status and exit status? They are quite different, one is user defined and is implemented as a string and the other is a predefined status and would logically be implemented as an enum.

I also think that the batch status has to be defined as an enum is the job xml XSD (with a restriction on the xsd:string type).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12107</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-16 22:50:23 +0000</bug_when>
    <thetext>I think we need the spec to define the String values for batch status.    That&apos;s because the default value of exit status is batch status, and because we can transition using pattern matching.

But that doesn&apos;t prevent us from defining an enum for Java code, along with the corresponding String values.   That does seem to be the more typical thing to expect.. in fact the difference in type could even be a nice reminder to someone first learning JSR 352 that the batch statuses are predefined while the exit status is user-defined.

---

As far as the XSD, though... we&apos;re currently using all xsd:string types because of the need to allow for JSL property substitution.   Any JSL value which logically is constrained to be an enum, int, or boolean value after substitution must still use the xsd:string type.. or else the JSL document can&apos;t be validated when authored and when initially parsed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12111</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 13:32:03 +0000</bug_when>
    <thetext>We will add a Java enum only.  This will appear in v1.1 of the proposed final draft.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12112</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 14:39:19 +0000</bug_when>
    <thetext>Changes are:

JobOperator:  

	/**
	 * BatchStatus enum defines the batch status values
	 * possible for a job.
	 */
	enum BatchStatus {STARTING, STARTED, STOPPING, STOPPED, FAILED, COMPLETED, ABANDONED }

All occurrences of method signature:   

String getBatchStatus();

change to: 

BatchStatus getBatchStatus(); 

These interfaces are affected:  

FlowResults
JobContext
StepContext
JobExecution (note:  change method name from getStatus to getBatchStatus for consistency)
StepExecution (note:  change method name from getStatus to getBatchStatus for consistency)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4520</bug_id>
          
          <creation_ts>2013-01-16 21:47:00 +0000</creation_ts>
          <short_desc>Exit status wildcards</short_desc>
          <delta_ts>2013-01-17 14:40:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12105</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2013-01-16 21:47:36 +0000</bug_when>
    <thetext>Is there any reason not relying on a standard regex (very easy to implement with String.matches) instead of a custom matching system?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12106</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-16 22:39:29 +0000</bug_when>
    <thetext>The current behavior is a form of globbing, so it&apos;s not as if it&apos;s uniquely custom to JSR 352. 

Glob patterns seem simpler to work with for simple cases 

E.g.
 A*B 
instead of 
 A.*B

so if you&apos;re not expecting JSL authors to take full advantage of regex(s), then 
I can see an advantage with globbing.   

I&apos;d actually originally suggest we be explicit that there would be no backslash escaping, which isn&apos;t in the spec. 

Wikipedia has a nice breakdown of different globbing patterns:
 http://en.wikipedia.org/wiki/Glob_%28programming
and does show that there isn&apos;t a single, standard &quot;glob&quot; behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12113</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 14:40:44 +0000</bug_when>
    <thetext>We&apos;re sticking with the globbing approach.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4523</bug_id>
          
          <creation_ts>2013-01-17 15:00:00 +0000</creation_ts>
          <short_desc>Spec coding conventions</short_desc>
          <delta_ts>2013-01-25 18:04:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12115</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:00:52 +0000</bug_when>
    <thetext>This is just a small suggestion.  In the spec, interface methods are sometimes defined with the optional public modifier and some are not (since all interface methods are public by default).  Can we clean this up to be consistent across the document one way or the other?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12324</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:04:02 +0000</bug_when>
    <thetext>Affects StepContext, FlowContext (both of which maybe deleted from spec) and JobOperator.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4524</bug_id>
          
          <creation_ts>2013-01-17 15:12:00 +0000</creation_ts>
          <short_desc>JobInstance definition clarification</short_desc>
          <delta_ts>2013-01-24 00:14:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12116</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:12:16 +0000</bug_when>
    <thetext>In the second from last sentance before 4.1.2. on page 11, can we replace &quot;will be used&quot; to &quot;will be available to the new run&quot;.  It&apos;s really up to the implementations of things like ItemReader on how restart is handled.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12266</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 00:14:03 +0000</bug_when>
    <thetext>Agreed. Done.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4525</bug_id>
          
          <creation_ts>2013-01-17 15:18:00 +0000</creation_ts>
          <short_desc>JobInstance completion clarification</short_desc>
          <delta_ts>2013-01-24 19:24:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12117</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:18:26 +0000</bug_when>
    <thetext>The section 4.1.3 (page 12), is a bit confusing and vague.  A JobInstance is not considered complete unless ONE execution completes successfully.  That paragraph feels like it dances around that fact without just coming out and saying it.  It states that a JobExecution cannot be restarted but then again, a JobExecution isn&apos;t restarted (A new JobExecution is created on a restart of a JobInstance).  The point about a JobInstance being complete may really belong in section 4.1.1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12258</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 22:26:01 +0000</bug_when>
    <thetext>I found of those details to be unnecessary in this section and removed them.  I considered adding some to the JobInstance explanation (4.1.1) but felt it unnecessary.  

Section 4.1.3 JobExecution was revised to say simply:

A JobExecution refers to the technical concept of a single attempt to run a Job. Each time is job is started or restarted, a new JobExecution is created,  belonging to the same JobInstance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12281</commentid>
    <comment_count>2</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 05:19:55 +0000</bug_when>
    <thetext>I like it but there&apos;s a typo - &quot;Each time is job is started or restarted&quot; should be &quot;Each time a job ...&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12289</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 19:24:42 +0000</bug_when>
    <thetext>(In reply to comment #2)

Think I was staring too long at the document yesterday :)   Thanks, Wayne.  I corrected it in v1.2, which I&apos;m posting this week.

&gt; I like it but there&apos;s a typo - &quot;Each time is job is started or restarted&quot;
&gt; should be &quot;Each time a job ...&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4526</bug_id>
          
          <creation_ts>2013-01-17 15:21:00 +0000</creation_ts>
          <short_desc>Step&apos;s next attribute clarification</short_desc>
          <delta_ts>2013-01-25 00:03:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12118</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:21:40 +0000</bug_when>
    <thetext>Section 5.2 in the table describing the step element&apos;s attributes (page 17), the next attribute&apos;s default is that this is last step in a job/flow (it is missing the flow part of it).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12309</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 00:03:44 +0000</bug_when>
    <thetext>Ok. Update in Proposed Final Draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4527</bug_id>
          
          <creation_ts>2013-01-17 15:24:00 +0000</creation_ts>
          <short_desc>Missing reference</short_desc>
          <delta_ts>2013-01-23 22:28:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12119</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:24:19 +0000</bug_when>
    <thetext>In section 5.2.1 on page 17, there is a reference to a section of the spec that is missing so the text &quot;Error! Reference source not found.&quot; is displayed.  I actually think that the sentence that makes this reference may be able to be removed since transaction configuration should be an implementation detail.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12259</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 22:28:02 +0000</bug_when>
    <thetext>thanks.  fixed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4528</bug_id>
          
          <creation_ts>2013-01-17 15:26:00 +0000</creation_ts>
          <short_desc>Document abstract class methods are &quot;default&quot; not &quot;optional&quot;</short_desc>
          <delta_ts>2013-01-24 22:44:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12120</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 15:26:50 +0000</bug_when>
    <thetext>I was aware of the existing abstract classes but that&apos;s a good point about just the way we are thinking about it.  Updating the javadoc makes sense to follow other places in the JDK.  Thanks!


Thanks,
Michael Minella
michael@michaelminella.com
http://www.michaelminella.com



On Thu, Jan 17, 2013 at 9:14 AM, Christopher Vignola &lt;cvignola@us.ibm.com&gt; wrote:

There are plenty of examples of abstract classes in the JDK.   What&apos;s missing is an example of an abstract class  that explicitly states a method is optional.   What they do have is default implementations of certain methods.  So maybe the mistake we&apos;re making in the batch spec is calling these methods &quot;optional&quot;.   Maybe what we should be saying is they are default implementations and the default implementation just happens to be a no-op. 

Chris Vignola, STSM, IBM
JSR 352 Spec Lead
WebSphere Systems Management Architect
phone: 1+(720) 396-7501
email: cvignola@us.ibm.com

http://chris.vignola.googlepages.com


Michael Minella ---01/17/2013 10:05:47 AM---I just finished reading through the new version of the spec.  I know that it was agreed upon that th

From: Michael Minella &lt;michael@michaelminella.com&gt;
To: public@jbatch.java.net
Date: 01/17/2013 10:05 AM
Subject: [jsr352-public] Abstract classes for optional methods precedent



--------------------------------------------------------------------------------




I just finished reading through the new version of the spec.  I know that it was agreed upon that the method for making methods optional was through no-op base classes, however I wanted to find out if there was any precedent in the JDK for this approach.  I honestly can&apos;t think of another place where methods are made optional via this technique.  My understanding is that more finely grained interfaces have been typically preferred.  

Is this something that is done elsewhere in the JDK and if so where?

Thanks,
Michael Minella
michael@michaelminella.com
http://www.michaelminella.com</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12300</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 22:44:19 +0000</bug_when>
    <thetext>fixed in proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4529</bug_id>
          
          <creation_ts>2013-01-17 15:26:00 +0000</creation_ts>
          <short_desc>Confusing description for checkpointing</short_desc>
          <delta_ts>2013-01-24 01:46:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12121</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:26:56 +0000</bug_when>
    <thetext>In section 5.2.1 on page 17, the verbiage is confusing.  It sounds like checkpointing occurs throughout a chunk instead of defining the beginning and ending of a chunk.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12232</commentid>
    <comment_count>1</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-23 19:42:18 +0000</bug_when>
    <thetext>I think the confusing sentence is &quot;A chunk may be configured so the batch runtime periodically checkpoints the progress of the step by committing the current transaction and starting a new transaction scope.&quot;  I think adding the text &quot;The default is that transaction boundary is aligned with the item-count, meaning that the transaction is demarcated at the beginning and ending of the chunk boundary&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12243</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:58:54 +0000</bug_when>
    <thetext>Point taken.

I reworded from this:

A chunk runs in the scope of a transaction.  A chunk may be configured so the batch runtime periodically checkpoints the progress of the step by committing the current transaction and starting a new transaction scope.

to this: 


A chunk type step is periodically checkpointed by the batch runtime according to a configured checkpoint policy. Items processed between checkpoints are referred to as a &quot;chunk&quot;. Each chunk is processed in a separate transaction. See section 6.7 for more details on transactionality.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12267</commentid>
    <comment_count>3</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 01:46:10 +0000</bug_when>
    <thetext>I&apos;m good with the change.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4530</bug_id>
          
          <creation_ts>2013-01-17 15:40:00 +0000</creation_ts>
          <short_desc>item-count is confusing</short_desc>
          <delta_ts>2013-01-23 21:30:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12122</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:40:26 +0000</bug_when>
    <thetext>In section 5.2.1 on page 18, the item-count attribute for a chunk&apos;s description is confusing checkpointing (the act of saving the current state of a step/job) and chunk completion (the committing of a transactional unit of work that will contain the items processed in the current chunk and a checkpoint) and makes it sound confusing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12245</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 21:30:21 +0000</bug_when>
    <thetext>Ok, reworded from:

Specifies the number of items to process before taking a checkpoint for the item checkpoint policy.

to:

Specifies the number of items to process per chunk when using the item checkpoint policy.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4531</bug_id>
          
          <creation_ts>2013-01-17 15:46:00 +0000</creation_ts>
          <short_desc>remove time-limit from chunk configuration</short_desc>
          <delta_ts>2013-01-24 20:18:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12123</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:46:05 +0000</bug_when>
    <thetext>In section 5.2.1  on page 18, the time-limit attribute on a chunk should be removed since the only two checkpoint policy options are item or custom.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12129</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 16:07:01 +0000</bug_when>
    <thetext>When policy=item,  item-count specifies the (desired maximum) number of items per chunk - i.e. after item-count items have been read,  take a checkpoint.  So it&apos;s like SpringBatch&apos;s commit-interval.  The time-limit is a qualifier for policy=item to allow the job developer to configure a time-limit on the chunk to help it avoid unexpected transaction timeouts.  The item-count and 
time-limit always work together when policy=item.  

The effect of item-count and time-limit is that you can optionally end the chunk and checkpoint when either:  item-count items have been processed or time-limit is reached.  

Defaults:

item-count=10
time-limit=0 (unlimited)

Result is that chunk size is consistently 10. 

Some examples:

item-count=10
time-limit=30

Result is chunk size is variably 10,  because a checkpoint is taken after every 10 items or 30 seconds, whichever comes first. 

I think avoiding transaction timeout via deterministic configuration is better than trial and error and hoping for no surprises during production runs.  I think not having to implement a custom policy for this is a nice feature.

Now one might claim variable chunk size is a bad idea.  Or  that time-limit over reaches and concepts like that should be relegated exclusively to custom policies.  Or perhaps there are other concerns not yet raised.  

Where do you side?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12138</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 17:32:35 +0000</bug_when>
    <thetext>Instead of having another configuration facet like this, I&apos;d rather handle that with composition (that&apos;s the way we handle it in SB).  if you want to add a timeout to your chunk completion policy, you can create a composite custom policy that handles both of these scenarios.

With regards to not needing to implement this as a nice feature, there is nothing to preclude an implementer to provide a composite policy and a timeout implementation as well with their distribution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12142</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 18:09:20 +0000</bug_when>
    <thetext>What you say is true. But why shouldn&apos;t the spec include time-limit? I think the use case it covers is pervasive enough to warrant it being an intrinsic behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12145</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 19:29:36 +0000</bug_when>
    <thetext>With this attribute being re-inroduced, does that mean that leaving item-count off and configuring time-limit=30 is acceptable?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12295</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:18:10 +0000</bug_when>
    <thetext>(In reply to comment #4)

It is valid syntax.  Remember the default for item-count is 10.  So specifying time-limit=30 alone would mean checkpoint chunk every 10 items or 30 seconds, whichever comes first. 

&gt; With this attribute being re-inroduced, does that mean that leaving item-count
&gt; off and configuring time-limit=30 is acceptable?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4532</bug_id>
          
          <creation_ts>2013-01-17 15:50:00 +0000</creation_ts>
          <short_desc>buffer-items should be about reading and not writing</short_desc>
          <delta_ts>2013-02-01 23:23:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>blocker</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12124</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 15:50:21 +0000</bug_when>
    <thetext>In section 5.2.1 on page 18, the buffer-items attribute talks about buffering the items to be written, however this is incorrect.  This is probably my fault, but this attribute (assuming it&apos;s intended to replace the is-reader-transactional-queue attribute in SB) should indicate if the input is transactional and therefore should not be bufferednot about how many items to buffer before a write.  The item-count handles the buffer size for writing.  If you don&apos;t want to buffer items to be written, item-count=1 should address this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12130</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 16:16:44 +0000</bug_when>
    <thetext>Yes, buffer-items is like SB is-reader-transactional-queue.  It indicates whether to buffer items read and pass a list to ItemWriter or to call ItemWriter one item at a time.  

The item-count is like SB commit-interval - it specifies the chunk size and therefore the commit frequency.   So you wouldn&apos;t want to specify item-count=1 just to avoid buffering because you&apos;d get the unwanted side effect of checkpointing (commiting) every item.  

So the intended behavior is:

1) 

item-count=10
buffer-items=true

Result is read and buffer 10 items,  call ItemWriter with list of 10,  then commit checkpoint.

2) 

item-count=10
buffer-items=false

Result is read item, write item one item at a time for 10 items, then commit checkpoint. 

---------------------

Do you agree/disagree we need those two behaviors?

Now I&apos;ll concede my description in the spec may or may not convey those facts,  but that was the intention.  For convenience,  here&apos;s what the spec says about buffer-items:

&quot;Specifies whether items are buffered until it is time to take a checkpoint.  It must be the value &apos;true&apos; or &apos;false&apos;. It is an optional attribute.  The default is true. When items are buffered, a single call to the item writer is made to write the items immediately before the next checkpoint is taken.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12137</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 17:25:37 +0000</bug_when>
    <thetext>&quot;Yes, buffer-items is like SB is-reader-transactional-queue.  It indicates whether to buffer items read and pass a list to ItemWriter or to call ItemWriter one item at a time.&quot;

That is my point.  SB&apos;s is-reader-transactional-queue does not have any impact on when the items are passed to the writer.  This is controlled solely by the item-count attribute.

Internally as we read items, by default, we buffer them to save the I/O work from rereading them on a retry (among other reasons).  So in your example, regardless of if the is-reader-transactional-queue flag is true or false, the ItemReader will always get 10 items.

The purpose of this flag is when reading from a JMS queue.  Most ItemReaders can improve performance by caching the items read when a rollback occurs and we need to reread them.  However, with a JMS queue, we can&apos;t do that because the items will be put back on the queue automatically (if we were to buffer these items, they would end up being read twice...once on the retry and once when we resumed reading from the queue).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12141</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 18:05:16 +0000</bug_when>
    <thetext>Ok, so is_reader_transactional_queue is really just a way to control a retry optimization. is_reader_transactional_queue=false and you retry items from the buffer; is_reader_transactional_queue=false and you retry by re-reading items from the resource.

So here&apos;s where I think this leaves us:

1) What you&apos;re really saying is that ItemWriter should always be called once with a list of all items in the current chunk.  

2) If that&apos;s is indeed what you&apos;re saying that would imply we don&apos;t need the buffer-items option at all.  We could remove it.  

3) Whether retry reads from a buffer or from a resource is an implementation decision and if it needs any external control, that too should be implementation specific. An implementation could define a step-level property for such purposes.  


Please indicate agreement/disagreement with points 1-3 above.  Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12144</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 19:16:20 +0000</bug_when>
    <thetext>I agree with all three of those points.  Sorry for the confusion about this attribute..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12457</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 23:23:26 +0000</bug_when>
    <thetext>Changes to spec resulting from this bug are:

1) The buffer-items attribute has been removed.

2) Section 5.2.1 states &quot;A single call is made to the ItemWriter to per chunk.&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4533</bug_id>
          
          <creation_ts>2013-01-17 15:57:00 +0000</creation_ts>
          <short_desc>Fix Javadoc for getStepExecutions</short_desc>
          <delta_ts>2013-01-25 18:49:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>htavarez</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12125</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-17 15:57:32 +0000</bug_when>
    <thetext>+++ This bug was initially created as a clone of Bug #4051 +++

We at least need to fix the Javadoc since there&apos;s an extra parm mentioned.

Note I added some suggested wording saying an ordering wasn&apos;t implied...

------------------------------------------------------------------------------

/**
* Return StepExecutions for specified execution id.
*
* @param executionId
* specifies the job execution.
* @return a list of step executions (no particular ordering guaranteed)
* @throws NoSuchJobExecutionException
*/
List&lt;StepExecution&gt; getStepExecutions(long executionId) throws NoSuchJobExecutionException;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12127</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-17 16:02:23 +0000</bug_when>
    <thetext>Also the parm should be named &apos;jobExecutionId&apos; to more obviously distinguish from step execution id.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12331</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:49:40 +0000</bug_when>
    <thetext>javadoc updated for proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4534</bug_id>
          
          <creation_ts>2013-01-17 16:00:00 +0000</creation_ts>
          <short_desc>What is the purpose of the save-as attribute on a property?</short_desc>
          <delta_ts>2013-01-24 20:30:11 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12126</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 16:00:00 +0000</bug_when>
    <thetext>In each of the property configuration sections there is a new attribute, save-as.  Two questions here:
1.  Why is there a need for a secondary name when we already have a name?
2.  Is this to imply that properties configured with the save-as attribute will be persisted in some way from execution to execution?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12135</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 16:56:04 +0000</bug_when>
    <thetext>More on saved batch properties is explained (perhaps not clearly) in section 5.9.  The reason for another name is because saved properties (which are persisted) are saved for the entire job. Properties can be defined on any artifact and the names are therefore non-unique.  Saved properties provides a way via substitution (#{saved[&lt;property-name&gt;]}) for property value from one step to be shared with another.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12150</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 20:19:33 +0000</bug_when>
    <thetext>With regards to section 5.9:
1.  Why isn&apos;t this behavior part of the job repository implementation?  I would expect parameters to be saved every time.  Now the question of what is used during the next execution is the next step.  I would expect that the user be required to re-pass in parameters every time the job is rerun.  If not, how do you remove a parameter on a subsequent run?
2.  Just to confirm, parameters are immutable through out a job execution, correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12298</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:30:11 +0000</bug_when>
    <thetext>(In reply to comment #2)

1. These are not job parameters.  They are job properties.  The purpose is so that step2 can use a property value produced by step1 without having to write code in step1 to do it and without having the runtime automatically save every property to the repository. 

2. Parameters are immutable through out a job execution.



&gt; With regards to section 5.9:
&gt; 1.  Why isn&apos;t this behavior part of the job repository implementation?  I would
&gt; expect parameters to be saved every time.  Now the question of what is used
&gt; during the next execution is the next step.  I would expect that the user be
&gt; required to re-pass in parameters every time the job is rerun.  If not, how do
&gt; you remove a parameter on a subsequent run?
&gt; 2.  Just to confirm, parameters are immutable through out a job execution,
&gt; correct?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4535</bug_id>
          
          <creation_ts>2013-01-17 16:04:00 +0000</creation_ts>
          <short_desc>next element should not allow looping (5.2.5)</short_desc>
          <delta_ts>2013-01-23 22:12:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12128</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 16:04:12 +0000</bug_when>
    <thetext>Section 5.2.5 on page 28 does not explicitly disallow the ability to loop back to a previously executed step.  We should update this section to state that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12257</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 22:12:22 +0000</bug_when>
    <thetext>agreed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4536</bug_id>
          
          <creation_ts>2013-01-17 16:19:00 +0000</creation_ts>
          <short_desc>PartitionReducer seems redundant</short_desc>
          <delta_ts>2013-02-01 23:51:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12131</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 16:19:12 +0000</bug_when>
    <thetext>Since the PartitionReducer is only executed at the beginning and end of a step (just happens to only be used in a partitioned step), why can this functionality not be handled with a regular StepListener?  What is the difference in execution between this and a StepListener?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12140</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 17:50:26 +0000</bug_when>
    <thetext>The key role of the reducer is to facilitate control of completion/compensation logic for a partitioned step.  It receive control for things like:

1) partitions complete/step is rolling back 
2) partitions not started/step is restarting 
3) partitions are complete

I concede all these things could be discerned in the StepListener.  

The only other difference is that as currently defined in the spec,  StepListener methods do not get invoked in the scope of a global tran (see section 8.6), while reducer methods do. That could be important for executing compensation logic against multiple transactional resource managers.  Of course, a StepListener could manage its own tran if necessary. 

So I suppose the best we could say about PartitionReducer is it is a fit-for-purpose interface that (in a sense) specializes what could be accomplished in a less obvious way via StepListener.

So I suppose we could eliminate PartitionReducer in the interest of a leaner programming model or keep it for the value of its specialization.  

I think I could be persuaded either way.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12460</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 23:51:36 +0000</bug_when>
    <thetext>My present intention is to keep PartitionReducer in the spec because of its specialization for partition processing.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4537</bug_id>
          
          <creation_ts>2013-01-17 16:21:00 +0000</creation_ts>
          <short_desc>How are flows identified within a split?</short_desc>
          <delta_ts>2013-02-02 01:19:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12132</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 16:21:37 +0000</bug_when>
    <thetext>In section 5.4 on page 37, how are flows identified within the split?  Inline only (this prevents reuse of flows)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12136</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 16:58:18 +0000</bug_when>
    <thetext>Well, I suppose there are two ways:

&lt;split&gt;
&lt;!- inline --&gt;
&lt;flow&gt;
    &lt;step&gt;
    &lt;/step&gt;
&lt;/flow&gt;
&lt;!- inheritance --&gt;
&lt;flow parent= /&gt;
&lt;/split&gt;

What&apos;s missing?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12139</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 17:35:47 +0000</bug_when>
    <thetext>The flow element (as defined in 5.3 of the spec) doesn&apos;t have a parent attribute as you show in your example and since jobs don&apos;t inherit steps, I wouldn&apos;t expect flows to as well...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12143</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-17 18:15:05 +0000</bug_when>
    <thetext>My mistake.  I thought there was a parent attribute defined on flow in the spec.  There is not.  

Do you propose we add a parent attribute to flow?  

If yes, what do you propose a child flow inherits from its parent?  The steps?  Everying but the steps?  Other?  Please elaborate.  Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12282</commentid>
    <comment_count>4</comment_count>
      <attachid>68</attachid>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 05:45:23 +0000</bug_when>
    <thetext>Created attachment 68
flowType has parent</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12283</commentid>
    <comment_count>5</comment_count>
      <attachid>68</attachid>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 05:45:56 +0000</bug_when>
    <thetext>Comment on attachment 68
flowType has parent

Just exposing our design for FlowType having a parent.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12288</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 16:10:16 +0000</bug_when>
    <thetext>In SB, there are two different types of flows defined in the XSD.  A flowType which is for defining an inline flow.  There is also an external flow that allows the configuration to reference an externally defined flow.  The external version has a ref attribute that allows you to refer to a flow defined elsewhere (same way we are referring to readers/writers/etc.  The other one does have a parent attribute for inheritance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12294</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:11:42 +0000</bug_when>
    <thetext>(In reply to comment #6)

The spec presently defines the inline flow.  The spec does not presently have a provision for external flows or flow inheritance.  Are those the same or different concepts?  I can&apos;t quite tell.




&gt; In SB, there are two different types of flows defined in the XSD.  A flowType
&gt; which is for defining an inline flow.  There is also an external flow that
&gt; allows the configuration to reference an externally defined flow.  The external
&gt; version has a ref attribute that allows you to refer to a flow defined
&gt; elsewhere (same way we are referring to readers/writers/etc.  The other one
&gt; does have a parent attribute for inheritance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12301</commentid>
    <comment_count>8</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 22:57:47 +0000</bug_when>
    <thetext>2 things here in response to comment #7:
1.  I was incorrect on the configuration of an external flow.  An external flow would be configured as follows (our error message is inconsistent with what we actually accept...the below configuration works):

	&lt;flow id=&quot;externalFlow&quot;&gt;
		&lt;step id=&quot;flow.step1&quot; parent=&quot;parentStep&quot;/&gt;
	&lt;/flow&gt;

	&lt;job id=&quot;splitDecider&quot; incrementer=&quot;incrementer&quot;&gt;
		&lt;split id=&quot;step1&quot;&gt;
 			&lt;flow parent=&quot;externalFlow&quot;/&gt;
			&lt;flow&gt;
				&lt;step id=&quot;step2b&quot; parent=&quot;parentStep&quot;/&gt;
			&lt;/flow&gt;
		&lt;/split&gt;
	&lt;/job&gt;

2.  A job in SB actually does not allow for inline flows at the job level.  For example, the following configuration is invalid in SB:

	&lt;flow id=&quot;externalFlow&quot;&gt;
		&lt;step id=&quot;flow.step1&quot; parent=&quot;parentStep&quot;/&gt;
	&lt;/flow&gt;

	&lt;job id=&quot;splitDecider&quot; incrementer=&quot;incrementer&quot;&gt;
		&lt;flow parent=&quot;externalFlow&quot;&gt;
			&lt;step id=&quot;step1b&quot; parent=&quot;copyFileStepScrewedUp&quot;/&gt;
		&lt;/flow&gt;
	&lt;/job&gt;

With regards to if they are different concepts, they really are not.  It&apos;s just two different ways of referencing a flow.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12462</commentid>
    <comment_count>9</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-02 01:19:19 +0000</bug_when>
    <thetext>We would like to add parent= to flow,  but we are running out of time.  I propose we stick with inline flows for v1.0 and attempt to add external flows in v1.1.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>68</attachid>
            <date>2013-01-24 05:45:00 +0000</date>
            <delta_ts>2013-01-24 05:45:23 +0000</delta_ts>
            <desc>flowType has parent</desc>
            <filename>Screen Shot 2013-01-23 at 9.44.42 PM.png</filename>
            <type>image/png</type>
            <size>98269</size>
            <attacher>waynexlund</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>4538</bug_id>
          
          <creation_ts>2013-01-17 16:26:00 +0000</creation_ts>
          <short_desc>Double period at end of bullet.</short_desc>
          <delta_ts>2013-01-24 01:56:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12133</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 16:26:12 +0000</bug_when>
    <thetext>Page 39, bullet 2 (first bullet on the page) ends in a double period.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12269</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 01:56:36 +0000</bug_when>
    <thetext>fixed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4539</bug_id>
          
          <creation_ts>2013-01-17 19:54:00 +0000</creation_ts>
          <short_desc>Exit Status verbiage misleading</short_desc>
          <delta_ts>2013-01-23 23:22:08 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12146</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 19:54:13 +0000</bug_when>
    <thetext>In section 5.5.1, page 39, the spec states that the exit status may be set by any batch artifact.  While that is technically true, we should clarify what that means.  If an ItemReader sets an exit status...does processing continue (it should)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12262</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 23:22:08 +0000</bug_when>
    <thetext>The paragraph has been reworked as follows:

Step batch status is set by the batch runtime at the conclusion of the step.  Step exit status may be set by any batch artifact configured to the step by invoking the exit status setter method in the StepContext object. See section 6.4 for further information about the StepContext object. Setting the step exit status does not alter the execution of the current step, but rather, is available to influence the execution of subsequent steps via the next element on steps (see 5.2.5) and deciders (see 5.6.4). If no batch artifact sets the exit status,  the batch runtime will default the value to the string form of the batch status value.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4540</bug_id>
          
          <creation_ts>2013-01-17 20:08:00 +0000</creation_ts>
          <short_desc>Batch and Exit status for splits</short_desc>
          <delta_ts>2013-01-23 21:25:09 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12147</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 20:08:20 +0000</bug_when>
    <thetext>In section 5.5.3 on page 41, the spec defines batch and exit statuses for a split.  There are a couple issues with this:
1.  Who provides the exit status for a Split?
2.  A split is not a single unit of work to be restarted, etc. so what does giving it it&apos;s own status add (you restart the steps within a split but not the split as a whole)?

Since a Split is just a way to parallelize step execution, I would expect it to behave as if it didn&apos;t exist and delegate to the steps it wraps for things like statuses.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12244</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 21:25:09 +0000</bug_when>
    <thetext>The only batch or exit status a split could have is derived from the flows (steps, really) that comprise the split.  

I agree the spec offers no way to set an exit status for the split.  The SplitAnalyzer did,  but we did away with that after the public draft. 

Batch status could be &quot;calculated&quot; based on the outcome of the flows, but ends up being either COMPLETED, FAILED, or STOPPED.  But none of these are interesting, because the job will only continue if the status is COMPLETED. 

So section 5.5.3 will be deleted.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4541</bug_id>
          
          <creation_ts>2013-01-17 20:10:00 +0000</creation_ts>
          <short_desc>Incomplete sentence in 5.8</short_desc>
          <delta_ts>2013-02-04 20:03:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12148</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 20:10:08 +0000</bug_when>
    <thetext>In section 5.8, the very last sentence before 5.8.1 is incomplete: &quot;Note: a single Job XML file may contain&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12322</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 17:50:37 +0000</bug_when>
    <thetext>Turns out we haven&apos;t resolved what a Job XML file can contain with regard to inheritance.  There are some open question. What we&apos;ve said is we want to support two patterns: 

1. Separate Files 

I.e. child job in file1 and parent job in file2 or step in file1 inherits step from file2 

Question:  what root element can be in file2?  Job only?  Job or step?  (maybe flow?)

2. Same File 

I.e. child job and parent job in same file 

We have discussed allowing a single concrete (abstract=no) and multiple abstract jobs (abstract=yes) in the same file.     A well-formed XML document has a single root element.  

Question:  What is the root element when there are multiple jobs in the same file?   &lt;jobs&gt; ?  E.g.

&lt;jobs&gt;
&lt;job id=&quot;job1&quot; abstract=&quot;yes&quot; ... /&gt;
&lt;job id=&quot;job2&quot; abstract=&quot;yes&quot; ... /&gt;
&lt;job id=&quot;job3&quot; parent=&quot;job1&quot; abstract=&quot;no&quot; ... /&gt;
&lt;/jobs&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12475</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 20:03:26 +0000</bug_when>
    <thetext>For now, the sentence in 5.8.1 will be stricken. Other issues concerning inheritance will be dealt with separately.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4542</bug_id>
          
          <creation_ts>2013-01-17 20:12:00 +0000</creation_ts>
          <short_desc>Merge examples of merge=false would be helpful</short_desc>
          <delta_ts>2013-01-25 18:36:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12149</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 20:12:37 +0000</bug_when>
    <thetext>In section 5.8.1, examples are shown where merge=true.  It would be helpful to display the same configuration examples with merge=false as well to clarify expected behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12329</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:36:44 +0000</bug_when>
    <thetext>will appear in proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4543</bug_id>
          
          <creation_ts>2013-01-17 21:19:00 +0000</creation_ts>
          <short_desc>checkpointInfo should take a context of some kind</short_desc>
          <delta_ts>2013-02-02 01:22:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12152</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 21:19:27 +0000</bug_when>
    <thetext>In SB, there is an ExecutionContext associated with a JobExecution and a StepExecution.  The ExecutionContext is used to store information during the given scope (it is persisted and referred to on restarts).  We pass that context into each of the open and update methods on the ItemStream (ItemReader/ItemWriter&apos;s open/checkpointInfo methods).

open accepts an Externalizable which is the closes the spec comes to the ExecutionContext so that is ok.  However, the checkpointInfo does not take any type of context.  This means that the ItemReader/ItemWriter needs to be statefull so that it can provide a new Externalizable with each call.  This gets ugly at best when used in multiple threads.

I would say that since we are not binding the Externalizable to a given type, we should at least allow it to be passed to the checkpointInfo method to provide context.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12250</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 21:49:25 +0000</bug_when>
    <thetext>JobContext and StepContext play the role of that JobExecution and StepExecution seem to in SB.  Note StepContext holds persistent user data.   The spec relegates JobExecution and StepExecution strictly to being repository objects and not available at runtime except if an application explicitly uses JobOperator to retrieve them.  

ItemReader/ItemWriter can manage their state without being stateful by using StepExecution, which they can access via field injection.  So there is no need to pass the context object.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12286</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 15:11:52 +0000</bug_when>
    <thetext>I&apos;m not clear on the last comment:

1.  You state that the JobExecution and StepExecution are strictly repository objects and not available at runtime and are only accessible via the JobOperator.
2.  Yet you then say that an ItemReader/ItemWriter can manage their state via the StepExecution via injection.  

Do you mean the StepContext can be used for state management?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12308</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 23:51:59 +0000</bug_when>
    <thetext>(In reply to comment #2)

Yes, I meant StepContext.  Sorry.

&gt; I&apos;m not clear on the last comment:
&gt; 1.  You state that the JobExecution and StepExecution are strictly repository
&gt; objects and not available at runtime and are only accessible via the
&gt; JobOperator.
&gt; 2.  Yet you then say that an ItemReader/ItemWriter can manage their state via
&gt; the StepExecution via injection.  
&gt; Do you mean the StepContext can be used for state management?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12463</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-02 01:22:40 +0000</bug_when>
    <thetext>As I said,

ItemReader/ItemWriter can manage their state without being stateful by using
StepContext, which they can access via field injection.  So there is no need
to pass the context object.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4544</bug_id>
          
          <creation_ts>2013-01-17 21:21:00 +0000</creation_ts>
          <short_desc>Syntax highlighting missing for AbstractItemWriter</short_desc>
          <delta_ts>2013-01-25 17:52:47 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12153</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 21:21:54 +0000</bug_when>
    <thetext>All of the other code examples use syntax highlighting (which is appreciated).  The code example for the AbstractItemWriter in Section 6.1.1.3 page 57 is missing that highlighting.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12323</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 17:52:47 +0000</bug_when>
    <thetext>updated for proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4545</bug_id>
          
          <creation_ts>2013-01-17 21:32:00 +0000</creation_ts>
          <short_desc>Not all listener methods define their transactional scope</short_desc>
          <delta_ts>2013-01-23 19:59:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12154</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 21:32:22 +0000</bug_when>
    <thetext>Some of the listener methods explicitly document if they are executed within a transaction or not.  This should be explicitly defined.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12233</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 19:59:30 +0000</bug_when>
    <thetext>Agreed.  Will be proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4546</bug_id>
          
          <creation_ts>2013-01-17 21:42:00 +0000</creation_ts>
          <short_desc>Passing the BatchContext where apropriate instead of relying solely on injection</short_desc>
          <delta_ts>2013-02-02 00:16:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12155</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 21:42:08 +0000</bug_when>
    <thetext>We have chosen to inject the BatchContext via an annotation but on event based calls like the listeners, I think it makes more sense to pass it in as a parameter. It&apos;s not something that we can set once on object creation and then forget; it will need to be passed each time the method is called.  Because of that, I would expect each of the listeners methods (where appropriate) to accept the context as a parameter.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12236</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:14:10 +0000</bug_when>
    <thetext>It&apos;s a reasonable suggestion. But actually context is something you can set once on a batch artifact instance and then forget.  This is because batch artifacts and batch contexts have the same life cycle.  E.g. a job level artifact exists for the life of the job;  there is one and only one job context and it also exists for the life of the job.  Same applies to step level batch artifacts and the step context - they both exist for the life of the step.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12284</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 14:24:27 +0000</bug_when>
    <thetext>That makes sense.  My only other thought is that it is (at least to me) more intuitive if the context is passed in as a parameter than being injected.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12461</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-02 00:16:03 +0000</bug_when>
    <thetext>I thought about this suggestion further and indeed found the proposition tempting. However, as I considered it, I decided against it.  The reason I decided against it is because parameters represent data on which a method is expected to operate.  It&apos;s part of the contract.  In no case that I can think of is a context object an intentional part of a method contract; in other words, there is no case in which a batch artifact is expected to operate on a context.  It may be true that a developer chooses to operate on a context in some cases,  maybe even in many cases,  but that is developer prerogative and not an inherent part of any one of the batch artifacts contracts.  Context objects are available to those batch artifacts that choose to operate on them via injection. I consider that both appropriate and sufficient.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4547</bug_id>
          
          <creation_ts>2013-01-17 22:04:00 +0000</creation_ts>
          <short_desc>ChunkListener execution is not clear via the description (6.2.3)</short_desc>
          <delta_ts>2013-01-23 20:23:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12156</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 22:04:02 +0000</bug_when>
    <thetext>The first sentence of section 6.2.3 on page 65 makes it sound like the listener is executed twice per chunk (once around the chunk itself and once after the checkpoint is taken).  This should be reworded to be more clear.  Something along the lines of &quot;A chunk listener receives control at the start of processing a chunk and at the end of the processing for a given chunk, after the checkpoint has been taken&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12238</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:23:15 +0000</bug_when>
    <thetext>Agreed.  Update coming in v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4548</bug_id>
          
          <creation_ts>2013-01-17 22:11:00 +0000</creation_ts>
          <short_desc>Add onError to ChunkListener</short_desc>
          <delta_ts>2013-02-04 23:26:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>DUPLICATE</resolution>
          <dup_id>4284</dup_id>
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12157</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 22:11:55 +0000</bug_when>
    <thetext>I know this interface was intended to mirror SB&apos;s.  SB recently added (it&apos;s in the nightly build) an afterChunkError method that is called once a chunk has been marked for rollback.  It handles the scenario where a chunk is rolled back (since afterChunk is not called in that scenario).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12240</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:35:57 +0000</bug_when>
    <thetext>Will take into consideration.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12476</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-04 20:24:26 +0000</bug_when>
    <thetext>Given where Bug 4284 has ended up, we could close this one 4548 as a dup I think.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12479</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 23:26:24 +0000</bug_when>
    <thetext>But http://java.net/bugzilla/show_bug.cgi?id=4284 proposes to add onCommitError to ChunkListener, to be invoked if the transaction commit fails.  That&apos;s a narrow case resulting in rollback.  So let&apos;s call the method onError and invoke it in response to any condition that causes the rollback.

*** This bug has been marked as a duplicate of bug 4284 ***</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4549</bug_id>
          
          <creation_ts>2013-01-17 22:28:00 +0000</creation_ts>
          <short_desc>Listener Error method naming consistency</short_desc>
          <delta_ts>2013-02-04 23:13:34 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12158</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 22:28:28 +0000</bug_when>
    <thetext>Some listener methods are named on*Exception (Job and Step for example) and others are on*Error (ItemRead and ItemWrite for example).  We should standardize on one convention unless there is a reason that I can&apos;t see for the naming inconsistency.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12241</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:41:24 +0000</bug_when>
    <thetext>Agreed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12478</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 23:13:34 +0000</bug_when>
    <thetext>on*Error will be the standard.  StepListener.onException and JobListener.onException are being removed by http://java.net/bugzilla/show_bug.cgi?id=4284.  All other methods conform to on*Error.  So there is actually nothing further that needs to be done.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4550</bug_id>
          
          <creation_ts>2013-01-17 22:29:00 +0000</creation_ts>
          <short_desc>Odd highlighting in the syntax highlighting</short_desc>
          <delta_ts>2013-01-24 01:59:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12159</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 22:29:50 +0000</bug_when>
    <thetext>On page 70 in the afterProcess method definition, the word result is highlighted in yellow for no apparent reason.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12270</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 01:59:03 +0000</bug_when>
    <thetext>Ffixed (I think). It was a mystery to me, too.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4551</bug_id>
          
          <creation_ts>2013-01-17 23:02:00 +0000</creation_ts>
          <short_desc>Parameter scoping</short_desc>
          <delta_ts>2013-01-18 20:03:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12160</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-17 23:02:27 +0000</bug_when>
    <thetext>In section 6.3 on page 75, the spec notes that batch properties are scoped (visible only within the scope they are defined).  This introduces a number of questions/issues:

1.  How does inheritance work with that?  
2.  How are parameters scoped when provided to the JobOperator#start()?
3.  This is also vastly different from the previous version of the spec (we previously never explicity said that parameters would be scoped like that).

It has always been my assumption that parameters were global and the user could use naming conventions for scoping if they desired.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12161</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-18 04:07:55 +0000</bug_when>
    <thetext>Michael, since this wording came partially at my request, let me jump in. 

The fact that you would even have a question at this point to me suggests the spec could use an example here.. 

Let&apos;s be clear about the difference between parameters and properties.  

Job parameters are passed in on JobOperator.start() as the 2nd parameter on method:
   JobOperator.start(String jobXMLName, Properties jobParameters)

Batch properties in Sec 6.3 are defined in JSL to be injected into batch artifacts (on fields annotated with @Inject @BatchProperty).

A batch property can get its value either as a JSL literal, or through any of the substitution mechanisms defined in Sec. 5.7.
 - job parameters
 - job properties
 - system properties, etc.
Further &quot;job properties&quot; is explained to encompass properties defined at any scope of JSL .. i.e. they could have been called &quot;JSL properties&quot; maybe...

So job parameters are indeed global.   

The point of the language I request here is to make clear the following use case:

Say I have passed in a jobParameters Properties object with Property of name=A and one with name=B into JobOperator.start().    Then for a JSL like:

&lt;step ...&gt;
  &lt;properties&gt;
     &lt;property name=&quot;A&quot; value=&quot;#{jobParameters[&apos;A&apos;]}&quot;/&gt;     
  &lt;/properties&gt;
 &lt;batchlet... &gt;
     &lt;properties&gt;
       &lt;property name=&quot;B&quot; value=&quot;#{jobParameters[&apos;B&apos;]}&quot;/&gt;     
     &lt;/properties&gt;


I can do:

 public class MyBatchlet extends AbstractBatchlet
  @Inject @BatchProperty(name=&quot;B&quot;)

but not:

 public class MyBatchlet extends AbstractBatchlet
  @Inject @BatchProperty(name=&quot;A&quot;)

The fact that there&apos;s a step property named A, which &quot;contains&quot; the batchlet 
definition, is irrelevant.   There is no @BatchProperty named &quot;A&quot;...

If you wanted to define one, you could use the &apos;jobProperties&apos; syntax for
a value via property substitution... but you&apos;d have to define one AT THE BATCHLET LEVEL in JSL.

As far as inheritance... please give a bit more detail what you think is ambiguous.

Thanks..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12190</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 19:19:28 +0000</bug_when>
    <thetext>Scott,

1.  I was unaware that batch properties and parameters were two different things.  I had the understanding that a job property (as defined in 6.3) was just a way to inject a parameter.
2.  While your description confirms my understanding of parameters as a global thing, it introduces the concept of properties (at least to me).  It sound like (from your description) that a batch property is nothing more than a way to inject a string value into a instance of a class with the sources of that string being the JobXML, job parameters, system properties, etc.  Is that correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12191</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:21:48 +0000</bug_when>
    <thetext>Yes, that is correct.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12195</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 19:40:12 +0000</bug_when>
    <thetext>Ok...I guess if DI is not required, then this is a necessary evil.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4552</bug_id>
          
          <creation_ts>2013-01-18 14:51:00 +0000</creation_ts>
          <short_desc>Mention examples of implementation-specific loaders</short_desc>
          <delta_ts>2013-01-25 18:19:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12164</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 14:51:39 +0000</bug_when>
    <thetext>In section 7.5 on page 87, the spec describes an &quot;implementation-specific loader&quot;.  Can we add to the spec an example of what that may be (I&apos;m assuming CDI and Spring would be two options).  Also, can we specify somewhere that the main goal of the &quot;implementation-specific&quot; loader is to allow the loading of the JobXML files from outside of the archive?  Leaving that out makes it sound like the JSR is endorsing a non compliant method of artifact loading.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12327</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:19:13 +0000</bug_when>
    <thetext>ok - will appear in proposed final draft v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4553</bug_id>
          
          <creation_ts>2013-01-18 14:58:00 +0000</creation_ts>
          <short_desc>Functionality for instance creation using batch.xml</short_desc>
          <delta_ts>2013-01-24 23:12:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12166</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 14:58:34 +0000</bug_when>
    <thetext>In section 7.7.1 on page 89, the spec outlines the batch.xml as a way to map names used in the Job XML to class types.  While the spec is still missing the XSD (as noted in issue 4174), how does the batch.xml file provide enough information for a non DI container to create the required objects?  The spec (from what I can find) does not require no arg constructors for the classes defined in the batch.xml and provides no way from what I can see to manage object dependencies in any other way.  While I understand how this will work in a DI scenario (With Spring for example, the names in the Job XML will refer to bean ids), I don&apos;t see how the batch.xml provides enough information to create the artifacts needed for batch processing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12221</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:37:42 +0000</bug_when>
    <thetext>Section 7.7.1 while not an XSD,  shows the complete syntax of batch.xml:

&lt;batch-artifacts xmlns=&quot;http://jcp.org.batch/jsl&quot;&gt;
    &lt;ref id=&quot;&lt;reference-name&gt;&quot; class=&quot;&lt;impl-class-name&gt;&quot; /&gt;
&lt;/batch-artifacts


So it&apos;s a simple map of logical name to implementation class name.  The default ctor is assumed.  The spec needs to say that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12246</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-23 21:34:09 +0000</bug_when>
    <thetext>How are dependencies handled?  Since the classes defined by the batch.xml are instantiated via the batch runtime via a default constructor and there is no additional hook to perform any other type of initialization, there needs to be some way to handle object dependencies.  What am I missing?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12277</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 02:54:18 +0000</bug_when>
    <thetext>The spec doesn&apos;t require DI.  So the way you handle dependencies is dependent on your runtime environment.  If know you can count on DI,  you can use DI for dependencies.  If you&apos;re using plain SE,  you have to instantiate your own dependent objects.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4554</bug_id>
          
          <creation_ts>2013-01-18 15:08:00 +0000</creation_ts>
          <short_desc>Passing data around during a batch run and BatchContext&apos;s transient data</short_desc>
          <delta_ts>2013-03-01 18:50:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12167</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:08:09 +0000</bug_when>
    <thetext>In section 7.8.1 on page 90, the BatchContext is defined.  Is there any way for me to store information in it?  Say for example, I have a job that I want to pass information from one step to the next in.  In Spring Batch, you can do that by using the ExecutionContext on the JobExeuction.  Also, what is the intended use of the &quot;transient user data&quot;?  If this is intended as a way for users to store information during a run, I would think that you would set some form of key/value relationship and retrieve that data via a key...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12172</commentid>
    <comment_count>1</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-01-18 15:50:58 +0000</bug_when>
    <thetext>I also feel key-value pair is the common mechanism for storing and passing contextual information.  Examples in EE are ServletContext.setAttribute, getAttribute.  So a Map&lt;?, ?&gt; in BatchContext would be nice.

In the current form, BatchContext&lt;T&gt; lets user choose the actual T type for transient data, and P type for persistent data. As a result any impl classes would also bear these user defined types, which I think is a bit too tight coupled.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12252</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 21:51:41 +0000</bug_when>
    <thetext>1) Yes, the batch context transient data is intended for sharing between steps.

2) I agree changing it to Map&lt;?,?&gt; is a good idea.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12737</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:12:19 +0000</bug_when>
    <thetext>Let me clarify:  The JobContext transient area is meant for sharing among steps.

For transient data, the user must still specify type &lt;T&gt;,  but user can choose the convention and specify Java types, such as HashMap&lt;String,String&gt;.

For persistent data, the user must specify &lt;P extends Serializable&gt;, which allows more choices, including simple types, HashMap, and even Externalizable.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12741</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:50:03 +0000</bug_when>
    <thetext>Changing this bug resolution &quot;worksforme&quot; since no change is being made in response to this bug.  The change of Externalizable to Serializable is already being done by Bug 4679.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4555</bug_id>
          
          <creation_ts>2013-01-18 15:11:00 +0000</creation_ts>
          <short_desc>Remove FlowContext interface</short_desc>
          <delta_ts>2013-01-23 22:09:55 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12168</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:11:54 +0000</bug_when>
    <thetext>Section 7.8.4 on page 94 defines a FlowContext, however it is an empty interface that doesn&apos;t seem to have any value as a marker interface.  If we don&apos;t have a need for this interface, we should remove it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12256</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 22:09:55 +0000</bug_when>
    <thetext>Agreed - we don&apos;t need it.  And we don&apos;t need section 5.5.2 either.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4556</bug_id>
          
          <creation_ts>2013-01-18 15:16:00 +0000</creation_ts>
          <short_desc>Syntax highlighting for SplitContext (7.8.5)</short_desc>
          <delta_ts>2013-02-28 01:27:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12169</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:16:36 +0000</bug_when>
    <thetext>Page 94 - 7.8.5 - syntax highlighting for the SplitContext is broken.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12318</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 17:05:30 +0000</bug_when>
    <thetext>I suspect we may remove splitcontext from the specification.  We will resolve that question via http://java.net/bugzilla/show_bug.cgi?id=4557</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12711</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 01:27:44 +0000</bug_when>
    <thetext>This issue is no longer valid because we have removed SplitContext due to Bug 4557.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4557</bug_id>
          
          <creation_ts>2013-01-18 15:19:00 +0000</creation_ts>
          <short_desc>Is SplitContext necessary?</short_desc>
          <delta_ts>2013-02-27 21:14:20 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12170</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:19:58 +0000</bug_when>
    <thetext>Section 7.8.5 on page 94 defines a SplitContext.  I don&apos;t see the explicit need for this context or the need to be able to get distinct flow results since both constructs are nothing more than grouping options for steps.  I would expect the only thing of importance here to be the step statuses themselves.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12237</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:21:11 +0000</bug_when>
    <thetext>The main purpose of the split context is to expose a list of statuses from the flows comprising the split so a decider can make a decision based on the outcome of one or more flows.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12285</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 15:02:49 +0000</bug_when>
    <thetext>I&apos;m looking at the Decider interface and it seems that since it only accepts a single BatchContext (SB explicitly receives a JobExecution and a StepExecution), that component becomes less reusable than it could be (since the implementation will need to know what type of context it is receiving and cast accordingly).  

That being said, wrapping the flow statuses in a single package makes sense.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12293</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:08:30 +0000</bug_when>
    <thetext>(In reply to comment #2)

I&apos;m curious:  

1) What does the StepExecution contain when the Decider follows a Flow?

2) What does the StepExecution contain when the Decider follows a Split?


&gt; I&apos;m looking at the Decider interface and it seems that since it only accepts a
&gt; single BatchContext (SB explicitly receives a JobExecution and a
&gt; StepExecution), that component becomes less reusable than it could be (since
&gt; the implementation will need to know what type of context it is receiving and
&gt; cast accordingly).  
&gt; That being said, wrapping the flow statuses in a single package makes sense.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12482</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-05 01:38:18 +0000</bug_when>
    <thetext>SplitContext will be removed.  However,  decider still needs a way to know what happened to the flows in a split.  So the proposal is:

1) Decider artifact supports two signatures:

String decide(StepStatus)
String decide(StepStatus[])


2) StepStatus includes two values;  step id and step exit status


3) Decider is invoked as follows:

a) if preceded by a step, with the StepStatus of that step;
b) if preceded by a flow, with the StepStatus of the last step that executed as part of that flow;
c) if preceded by a split, with an array of StepStatus, one StepStatus for the last step that executed as part of each flow in the split.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12505</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 22:25:46 +0000</bug_when>
    <thetext>Adding an id to the StepStatus doesn&apos;t make sense to me.  Then it isn&apos;t a status anymore.  Why not just pass the StepExecutions to the Decider (they contain both the BatchStatus and ExitStatus so all information needed would be available)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12519</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-07 15:00:57 +0000</bug_when>
    <thetext>BTW.. we still don&apos;t have spec text mandating that deciders rerun on restart.   I&apos;d suggested it be mentioned as part of a more general discussion of restart (I could look up the bug).    I think that last discussion, btw, got lost in the details of pathological property substitution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12542</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 18:55:43 +0000</bug_when>
    <thetext>(In reply to comment #5)

You&apos;re right.  The StepStatus is just a stripped down StepExecution.  So let&apos; define decider as:

String decide(StepExcution)
String decide(StepExecution[])

or do we prefer simply: 

String decide(StepExecution[])

And the array size is exactly 1 when decider follows a step or flow.  The array size would be &gt; 1 if and only if decider follows a split - i.e. one StepExecution for the final step in each flow. 

&gt; Adding an id to the StepStatus doesn&apos;t make sense to me.  Then it isn&apos;t a
&gt; status anymore.  Why not just pass the StepExecutions to the Decider (they
&gt; contain both the BatchStatus and ExitStatus so all information needed would be
&gt; available)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12709</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-27 21:14:20 +0000</bug_when>
    <thetext>We have settled on having only:

String decide(StepExecution[]) (to be amended in PFD v1.5)

and SplitContext was removed in an earlier PFD draft.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4558</bug_id>
          
          <creation_ts>2013-01-18 15:39:00 +0000</creation_ts>
          <short_desc>Using getter/setter standards for PartitionPlan (7.8.8)</short_desc>
          <delta_ts>2013-01-18 17:35:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12171</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:39:44 +0000</bug_when>
    <thetext>In section 7.8.8 on page 95, the PartitionPlan defines the methods setPartitions(int) and int getPartitionCount().  Why is this not setPartitions(int) and int getPartitions()?  The same thing goes for the number of threads.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12186</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 17:35:22 +0000</bug_when>
    <thetext>I missed an edit.  They now agree as you suggest.  Change is in v1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4559</bug_id>
          
          <creation_ts>2013-01-18 15:51:00 +0000</creation_ts>
          <short_desc>How does JobOperator#getJobNames() work?</short_desc>
          <delta_ts>2014-05-11 07:24:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>hbeto</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12173</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 15:51:16 +0000</bug_when>
    <thetext>In section 7.8.10 on page 98, the JobOperator defines a method, getJobNames().  How can the runtime be aware of more than one job if jobs are loaded only when launched (per section 7.6.  Section 7.6 should actually be clarified to include JobOperator.restart as well).  Is this a list of all jobs that have run/been run?  In SB, it is the list of all jobs that can be launched via the start method, however that depends on a JobRegistry backing it (which is not a feature defined in the spec).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12227</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:49:15 +0000</bug_when>
    <thetext>It returns a list of unique job names from across all JobInstances stored in the job repository.  Section 4.4 identifies that the job repository contains JobInstances.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12248</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-23 21:42:55 +0000</bug_when>
    <thetext>To clarify, since we do not prescribe what the repository is (persistent or not, etc) in the spec, this means that JobOperator#getJobNames() would return at least the names of any Jobs that have run since the runtime was bootstrapped.  We cannot guarantee anything more than that.  Is that correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12274</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 02:13:32 +0000</bug_when>
    <thetext>(In reply to comment #2)

Yes, I would say that is correct.

&gt; To clarify, since we do not prescribe what the repository is (persistent or
&gt; not, etc) in the spec, this means that JobOperator#getJobNames() would return
&gt; at least the names of any Jobs that have run since the runtime was
&gt; bootstrapped.  We cannot guarantee anything more than that.  Is that correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15571</commentid>
    <comment_count>4</comment_count>
    <who name="">hbeto</who>
    <bug_when>2014-04-15 12:06:21 +0000</bug_when>
    <thetext>If JobOperator#getJobNames() returns &quot;... at least the names of any Jobs that have run since the runtime was bootstrapped&quot;, we won&apos;t be able to do simple things like enabling the user/admin to chose which job he/she wants to start from the user interface. We would need to hardcode the names in the application, which is not elegant.

It&apos;s also weird that the method JobOperator#getJobNames() is named like that when it actually returns ids, not names.

It would be interesting to have the API extended to show jobs&apos; metadata, as described in the XML files.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15572</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-04-15 13:47:38 +0000</bug_when>
    <thetext>The values returned by JobOperator#getJobNames() are &quot;job names&quot;, not &quot;Job XML names&quot;.   And yes, &quot;job name&quot; = job @id value.

Given that the &quot;jobXMLName&quot; parameter passed to JobOperator.start() is resolved in an implementation-specific way (except for the META-INF/batch-jobs usecase), the two values aren&apos;t necessarily going to have affinity in the general case (the common denominator imposed by the spec).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15626</commentid>
    <comment_count>6</comment_count>
    <who name="">hbeto</who>
    <bug_when>2014-04-19 15:55:08 +0000</bug_when>
    <thetext>I believe that&apos;s semantically incorrect when an API names a method getNames() when it actually returns ids.

You say that &quot;the values returned by JobOperator#getJobNames() are &apos;job names&apos;, not &apos;Job XML names&apos;&quot;, but I don&apos;t see the difference because right after you say that the &quot;jobXMLName&quot; parameter is passed to JobOperator.start(). However, when the method JobOperator#getJobNames() eventually works, returning &quot;job names&quot; not &quot;job XML names&quot;, we can use those names in the method JobOperator.start().

As a user, it&apos;s very frustrating when we call JobOperator#getJobNames() and don&apos;t get any result sometimes. I would like to give this feedback here to help on the maintenance release that is on going.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15627</commentid>
    <comment_count>7</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-04-19 18:33:21 +0000</bug_when>
    <thetext>I would look at it like JobOperator#getJobNames() returns a set of the result of calling JobInstance#getJobName() for each JobInstance persisted in the underlying job repository. I also wouldn&apos;t go passing them into #start(...) as these values are in no way required to be related to the name of the jobXML file (as Scott said).

If you have been observing that this &apos;works&apos; it is probably because you have been following a naming convention of &lt;job id=&quot;blah&quot;&gt;...&lt;/job&gt; goes in blah.xml. If you want to determine the names of the XML files in the batch-jobs directory you should read them directly. Something like this but with more thought and less typos:

public static Set&lt;String&gt; getJobXmlNames() {
    final ClassLoader loader = ClassFromYourJar.class.getClassLoader();
    URL url = loader.getResource(&quot;META-INF/batch-jobs&quot;);
    if (url == null) {
        url = loader.getResource(&quot;WEB-INF/classes/META-INF/batch-jobs&quot;);
    }
    if (url == null) {
        return Collections.&lt;String&gt;emptySet();
    }
    final Set&lt;String&gt; names = new HashSet&lt;String&gt;();
    for (final String filename : new File(url.toURI()).list()) {
        if (filename.endsWith(&quot;.xml&quot;) {
            names.add(filename.substring(0, filename.length() - 4);
        }
    }
    return names;
}

Of course implementations are required to provide their own job loader as well so to get job XML names from them you would need to consult their documentation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15638</commentid>
    <comment_count>8</comment_count>
    <who name="">hbeto</who>
    <bug_when>2014-04-21 18:52:17 +0000</bug_when>
    <thetext>Thanks for the clarification.

Indeed, I&apos;m lucky that I&apos;ve named XML files the same way I&apos;ve set ids parameters. Otherwise, JobOperator#start() wouldn&apos;t work. 

But I&apos;m still wondering why the API works with two distinct names, using jobXMLName to start a job and jobName to get job instances or number of instances or running executions. It&apos;s confuse that we load a job with the name of the XML file and we end up with another name (id) during runtime.

Btw, I have tried the method to retrieve the list of XML files. That&apos;s cool, but it&apos;s not portable. Here is the most portable code I could get: https://github.com/htmfilho/yougi/blob/master/src/main/java/org/cejug/yougi/business/JobSchedulerBean.java#L83, but still not sure it is 100%. This portability issue would be perfectly addressed by different implementations, where each provider would implement their getJobXmlNames() according to the peculiarities of their app servers.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15802</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-05-09 17:29:31 +0000</bug_when>
    <thetext>(In reply to hbeto from comment #8)

hbeto, 

I just wanted to note that I&apos;m not planning on including this in the current maintenance release, which I&apos;ve been presenting in terms of &quot;clarifying existing behaviors without introducing new APIs&quot;.   

I think the API behavior is clear enough (not the most straightforward to begin with) for now.  Introducing a more standard way to get at the Job XML name would then be something for &quot;later&quot;, potentially.

Just as a process note:  I don&apos;t mind having a conversation on a &quot;RESOLVED&quot; bug, but if we need to keep something open for the future it&apos;s best to open a new one, so I don&apos;t filter it out going forward.

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15810</commentid>
    <comment_count>10</comment_count>
    <who name="">hbeto</who>
    <bug_when>2014-05-11 07:24:15 +0000</bug_when>
    <thetext>That&apos;s ok Scott. Thanks for your feedback.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4560</bug_id>
          
          <creation_ts>2013-01-18 16:05:00 +0000</creation_ts>
          <short_desc>JobOperator#getRunningInstances is confusing.</short_desc>
          <delta_ts>2013-03-01 18:00:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12174</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:05:05 +0000</bug_when>
    <thetext>In section 7.8.10 on page 98 the JobOperator defines a method JobOperator#getRunningInstances(String jobName).  I see two issues with this:

1. An instance doesn&apos;t runan execution does so it doesn&apos;t make much sense to get running instances (The SB JobOperator has a getRunningExecutions).  
2. SB just returns the ids instead of the full objects.  I know there was a conversation about consistency on whether to use ids vs full objects on this interface but I don&apos;t remember where it ended up (and it isn&apos;t consistent on the interface so wanted to double check).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12242</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:47:45 +0000</bug_when>
    <thetext>The id vs full object discussion concluded with the following principle:  executionId would be the only id passed on JobOperator methods - primarily on methods centered around start/restarting/stopping a job.  Objects would be passed in all other cases.  

getRunningExecutions morphed into getRunningInstances somewhere along the way. 

The signature should probably be:

List&lt;JobExecutions&gt; getRunningExecutions</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12736</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:00:24 +0000</bug_when>
    <thetext>Actual signature is:

	public List&lt;Long&gt; getRunningExecutions(String jobName)

Update in PFD v1.5</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4561</bug_id>
          
          <creation_ts>2013-01-18 16:10:00 +0000</creation_ts>
          <short_desc>Parameters apply to a JobExecution</short_desc>
          <delta_ts>2013-01-23 18:57:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>DUPLICATE</resolution>
          <dup_id>4562</dup_id>
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12175</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:10:06 +0000</bug_when>
    <thetext>In section 7.8.10 on page 99, a method JobOperator#getParameters(JobInstance instance) is defined.  However, per the spec, job parameters are associated with a JobExecution, not an instance.  How does this work?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12229</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:57:45 +0000</bug_when>
    <thetext>This bug is just a different perspective on the same issue raised in http://java.net/bugzilla/show_bug.cgi?id=4562

A little history: 

The public draft defined restart parameters and therefore parameters were per execution.

There was some uproar over restart parameters,  so it was removed in the proposed final draft. The parameters should have moved from JobExecution to JobInstance as part of that update, but did not.  That was an oversight. 

Let&apos;s allow resolution of Bug 4562 to determine whether or not the spec defines restart parameters and expect that resolution to also address the placement of getJobParameters() on JobExecution vs JobInstance.

*** This bug has been marked as a duplicate of bug 4562 ***</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4562</bug_id>
          
          <creation_ts>2013-01-18 16:17:00 +0000</creation_ts>
          <short_desc>JobParameters on restart</short_desc>
          <delta_ts>2013-02-14 18:51:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12176</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:17:11 +0000</bug_when>
    <thetext>In section 7.8.10 on page 100, the JobOperator#restart(long executionId) is defined.  Since JobParameters are at the execution level and can be changed from execution to execution, how are JobParameters handled on restart?  In the current version of SB, you can&apos;t change parameters from one execution to the next so that isn&apos;t an issue.  We are in the process of adding that feature (to be more in line with the spec).  We are currently proposing that any non-identifying parameters (all parameters from the JSR&apos;s viewpoint) would be required to be repassed in with each restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12218</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:28:07 +0000</bug_when>
    <thetext>So what are you proposing?  That the spec reinstate restart parameters or that getJobParameters() move from JobExecution to JobInstance?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12230</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:57:45 +0000</bug_when>
    <thetext>*** Bug 4561 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12458</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 23:44:23 +0000</bug_when>
    <thetext>We agree to add back restart parameters.  This change may not make it into the final approval ballot due to time constraints.  If we can&apos;t add it in time for the FAB,  we will add it before final release. 

The spec will say (roughly) that:

1) Job parameters may be specified on restart.

2) Whether a job parameter is required or not (on start or restart) depends on the job design.  

For example,

&lt;property name=&quot;inputFile&quot; 
             value=#{jobParameters[&apos;step1.inputFile&apos;]?:&quot;input.txt&quot;;}/&gt;

Implies job parameter &quot;step1.inputFile&quot; is optional because there is a default.

Whereas: 

&lt;property name=&quot;inputFile&quot; 
             value=#{jobParameters[&apos;step1.inputFile&apos;]}/&gt;


Implies job parameter &quot;step1.inputFile&quot; is required.  Although, in fact, the substitution reference will resolve to null and that may be an acceptable value to the property consumer.

So whether a job parameter is or is not required depends on the job design and should be documented as part of the job definition.   

The runtime makes no requirement on which job parameters, if any, are passed in on start or restart.  

If a job parameter is used in a position without a default such that it is effectively required, for example:

&lt;chunk item-count=&quot;#{jobParameters[&apos;itemCount&apos;]}&quot; ... /&gt;

the runtime will still not require that the job parameter be passed in. If a required job parameter is not passed in, it may result in an invalid job, which will terminate in error. 

3) Whether or not jobParameters may be used in substitution on attributes that affect job flow (such as &apos;on&apos; and &apos;to&apos; attributes) is still be studied and may be restricted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12459</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 23:50:58 +0000</bug_when>
    <thetext>(In reply to comment #3)

I neglected to add item #4 to the list.

4) job parameters (from start or restart) will be stored on the JobExecution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12464</commentid>
    <comment_count>5</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-02-02 03:39:54 +0000</bug_when>
    <thetext>(In reply to comment #3)

&gt; For example,
&gt; 
&gt; &lt;property name=&quot;inputFile&quot; 
&gt;              value=#{jobParameters[&apos;step1.inputFile&apos;]?:&quot;input.txt&quot;;}/&gt;
&gt; 

I think the value should be formated as:
              value=&quot;#{jobParameters[&apos;step1.inputFile&apos;]}?:input.txt;&quot;/&gt;

Note the position of }. I hope it&apos;s just a typo, and the syntax has not changed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12495</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 19:47:29 +0000</bug_when>
    <thetext>I&apos;d like to vote for not allowing parameters to have an impact on the flow of a job (for example, using them in the on attribute of a next tag).  It opens up a level of ambiguity that is unreasonable IMHO.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12496</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-05 19:53:45 +0000</bug_when>
    <thetext>Michael, I agree completely.  I believe we have to choose between disallowing substitution altogether on attributes that govern flow vs disallowing re-substitution on those same attributes during restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12497</commentid>
    <comment_count>8</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 19:55:11 +0000</bug_when>
    <thetext>I&apos;d vote for not allowing substitution on those attributes all together both for simplicity and consistency.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12500</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 20:13:28 +0000</bug_when>
    <thetext>So Michael, good point that it&apos;s cleaner and more obvious to ban substitution completely than to only ban it on restart.  

Two counterpoints maybe; 

1) assuming a decider is going to re-execute on restart, we&apos;re still open to a different execution sequence.

2) the easiest way to restrict this, banning all substitution, also eliminates the possibility of substitution with &apos;jobProperties&apos;.   Maybe this isn&apos;t as big a deal for exit status matching against @on attributes, but there could be examples (I&apos;m thinking partition plan @partitions) where it would be useful to have a job-level property that steps can reuse... but it gets awfully complicated to say you can do one substitution but not the other.

But still, let&apos;s build the prohibited (or questionable) substitution list:

We&apos;ve got @on attributes for next, end, stop, fail elements.

How about @abstract (job/step) and @restartable (job) as well... and partition plan @partitions.

Any more?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12544</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 19:38:47 +0000</bug_when>
    <thetext>(In reply to comment #5)

value=&quot;&quot; is the correct syntax.  What you saw is a typo.

&gt; (In reply to comment #3)
&gt; &gt; For example,
&gt; &gt; 
&gt; &gt; &lt;property name=&quot;inputFile&quot; 
&gt; &gt;              value=#{jobParameters[&apos;step1.inputFile&apos;]?:&quot;input.txt&quot;;}/&gt;
&gt; &gt; 
&gt; I think the value should be formated as:
&gt;               value=&quot;#{jobParameters[&apos;step1.inputFile&apos;]}?:input.txt;&quot;/&gt;
&gt; Note the position of }. I hope it&apos;s just a typo, and the syntax has not
&gt; changed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12579</commentid>
    <comment_count>11</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-14 18:51:02 +0000</bug_when>
    <thetext>Restart parameters added back to JobOperator in PFD v1.4.  More work is required to explain what attributes can&apos;t be changed (e.g. sequence related). That update will be tracked separately.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4563</bug_id>
          
          <creation_ts>2013-01-18 16:23:00 +0000</creation_ts>
          <short_desc>A JobExecution should be abandoned, not a JobInstance</short_desc>
          <delta_ts>2013-02-14 18:47:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12177</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:23:47 +0000</bug_when>
    <thetext>In section 7.8.10 on page 100, JobOperator#abandon(JobInstance instance) is defined.  A JobExecution should be what is being abandoned.  This method in SB is used to mark a job that didn&apos;t exit gracefully as abandoned so that it can be restarted (job instances that have an execution in something other than stopped or abandoned cannot be restarted). Abandoned provides a way of indicating a job was stopped but not gracefully for historic reasons.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12249</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 21:44:26 +0000</bug_when>
    <thetext>Your comment is confusing to me.  You seem to be saying that a failed job execution is not restartable until you first mark it abandoned.  That does not make sense.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12254</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-23 21:56:53 +0000</bug_when>
    <thetext>A JobInstace should not be able to be run if it has a JobExecution in a state other than STOPPED, ABANDONED or FAILED.  In Spring Batch, JobOperator#abandon() used to mark JobExecutions that are stuck in the STOPPING status to ABANDONED since a JobInstance cannot be retried with a JobExecution still in the STOPPING state.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12296</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:22:34 +0000</bug_when>
    <thetext>(In reply to comment #2)

That almost makes sense.  I thought you were going to say that a job with an ABANDONED execution could not be restarted.  Since it had an execution that never exited STOPPING state,  I would think the potential for integrity loss to great to allow restart. 

&gt; A JobInstace should not be able to be run if it has a JobExecution in a state
&gt; other than STOPPED, ABANDONED or FAILED.  In Spring Batch,
&gt; JobOperator#abandon() used to mark JobExecutions that are stuck in the STOPPING
&gt; status to ABANDONED since a JobInstance cannot be retried with a JobExecution
&gt; still in the STOPPING state.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12578</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-14 18:47:07 +0000</bug_when>
    <thetext>Changed in PFD v1.4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4564</bug_id>
          
          <creation_ts>2013-01-18 16:30:00 +0000</creation_ts>
          <short_desc>Clarify exception definition</short_desc>
          <delta_ts>2013-01-23 23:47:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12178</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:30:27 +0000</bug_when>
    <thetext>In section 7.8.14 on page 104 there are nine different exceptions defined.  The package they live in are not defined (someone could dig through the previous code examples but that doesn&apos;t seem like the right way to document that).  The spec also does not define if they are runtime or checked exceptions (we could assume checked because they are in various throws clauses in the spec, but the previous version of the spec had them extending RuntimeException so this is unclear).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12264</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 23:47:58 +0000</bug_when>
    <thetext>The intro to the section now says:

&quot;This specification defines the following java.lang.Exception subclasses in package javax.batch.operations.exception:&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4565</bug_id>
          
          <creation_ts>2013-01-18 16:34:00 +0000</creation_ts>
          <short_desc>SPEC Use diagrams instead of text based flows</short_desc>
          <delta_ts>2015-09-03 14:30:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>suggestion</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12179</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:34:50 +0000</bug_when>
    <thetext>Section 8.1 is an important section in the spec and clarity of how these flows work is vital.  Can we get something more clear than the text based flows currently in the spec (sequence diagram, flow chart, etc)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12272</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 02:03:54 +0000</bug_when>
    <thetext>I cannot promise this in time for final approval ballot.  They are time consuming to create. I will make a best effort.  Artwork donations accepted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19081</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 14:30:58 +0000</bug_when>
    <thetext>I&apos;m closing this, reflecting the fact that I have no plans to produce anything better.

Open any suggestions or assistance here, but no point in leaving this open indefinitely since the desirability of this is pretty obvious.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4566</bug_id>
          
          <creation_ts>2013-01-18 16:44:00 +0000</creation_ts>
          <short_desc>Batchlet partitioning should be removed</short_desc>
          <delta_ts>2013-02-27 21:10:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>
    
    <cc>ScottKurz</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12180</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 16:44:07 +0000</bug_when>
    <thetext>Section 8.5 on page 105 introduces the concept of a partitioned batchlet.  A Batchlet is a single task based concept.  If multithreading is needed for the execution of the task the Batchlet is written to do, I would expect that to be the responsibility of the Batchlet writer and not the batch runtime.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12226</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:45:56 +0000</bug_when>
    <thetext>I disagree. A batchlet is a processing task that does not use runtime-managed checkpoint/restart. There is nothing inherent in  that limiting such a task to being a singleton. A trivial example is a step that needs to FTP N files and wishes to both reuse an existing FTP batch step and reduce elapsed time through parallelization. The task at hand is inherently partitionable into N units of work. I see no reason to restrict partitioning to chunk type steps.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12247</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-23 21:40:22 +0000</bug_when>
    <thetext>A Batchlet, by definition is intended to be a single task (per 6.1.2, &quot;this batch pattern is invoked once, runs to completion and returns an exit status&quot;).  In a partitioned version, what is the exit status?  

I&apos;m not arguing against your use case, what I&apos;m saying is that parallelization within a Batchlet should be the developer&apos;s responsibility and not that of the framework.  Otherwise, how does restart work?  What was or was not done (since there is no checkpointing that occurs per your note)?  

By requiring this functionality we open up a large can of worms that I don&apos;t see the benefit to.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12271</commentid>
    <comment_count>3</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-24 02:02:26 +0000</bug_when>
    <thetext>This is a new thought for me since SB doesn&apos;t have the concept of parallel Tasklets (Batchlets).  In the simple example wondering about the restart topic how would you know that the files were processed?  I&apos;ve seen strategies where you rename the file to &quot;file1.something&quot; to &quot;file1.processed&quot; or move them to a new location but I&apos;m not seeing how the framework would know how to do that.  Per an early day discussion we typically advise this scenario to be done with a combination of an EIP endpoint pattern to SB rather than do this in a batchlet but I understand the issue of what if a client is not using and EIP / Integration technology.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12273</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 02:12:36 +0000</bug_when>
    <thetext>Aren&apos;t non-partitiond batchlets (or SB tasklets) restartable?  The batchlet has to decide on restart whether it repeats its work or not.  In the case of a partitioned batchlet, any partitions that completed would not be re-executed on restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12275</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 02:27:44 +0000</bug_when>
    <thetext>A non partitioned Tasklet in Spring Batch is restartable.  However, since it is a single method, it&apos;s just recalled.  The only checkpointing that would occur is that either the step (and therefor the method) started or finished.  

Since there is no checkpointing with regards to a Batchlet beyond either the step started or finished, there would be no way to know what partitions completed, etc.  The only way we know this with a regular step is via the data (it&apos;s the implementer&apos;s responsibility for keeping track of what data has been processed and which has not).  Keep in mind that partitioning is about data, not threading explicitly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12276</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 02:51:00 +0000</bug_when>
    <thetext>In the partition execution model we have in the spec, the batch runtime tracks the progress of each partition and does not restart those that have completed when the job restarts.  That applies to chunk type steps as well as batchlets.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12278</commentid>
    <comment_count>7</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-24 03:02:03 +0000</bug_when>
    <thetext>Where is the tracking indicated in the spec and how is that done?  Remember, partitioning is about data.  In SB, the framework does not maintain any information about partitions.  We allow the configuration of threads and provide a hook for the implementer to identify what data exists within a partition.  It is up to the implementers to track what partitions are complete (typically via a staging table/column).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12279</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 03:15:52 +0000</bug_when>
    <thetext>I now see this behavior is insufficiently specified.  The intention is the plan established the number of partitions and the parameters to pass to each (e.g. line number ranges,  key ranges, etc).  The partitions receive their unique parameters to influence what data they process.  The runtime tracks the execution of each partition.  Knows which ones have completed and which have not. Upon restart, the runtime starts any incomplete partition, passing it its original parameters, which were persisted.  The fact that the PartitionAnalyzer receives the result of each partition is an indicator of this behavior, but does not tell enough of the story by itself.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12349</commentid>
    <comment_count>9</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-29 19:10:42 +0000</bug_when>
    <thetext>Chris,

Along the thoughts mentioned in comment #8, what is the difference between a split executing batchlet steps in parallel and a partitioned batchlet?  It sounds like the same thing.  If that&apos;s the case, what benefit does this add?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12394</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 15:36:56 +0000</bug_when>
    <thetext>(In reply to comment #9)

Mike,

The difference is a split is static and partitioning is optionally dynamic.

&gt; Chris,
&gt; Along the thoughts mentioned in comment #8, what is the difference between a
&gt; split executing batchlet steps in parallel and a partitioned batchlet?  It
&gt; sounds like the same thing.  If that&apos;s the case, what benefit does this add?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12474</commentid>
    <comment_count>11</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 18:42:39 +0000</bug_when>
    <thetext>Batchlet partitioning is a valid use case.  It cannot be completely covered by splits.  It should stay.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12498</commentid>
    <comment_count>12</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 20:08:14 +0000</bug_when>
    <thetext>A couple other questions about this behavior:

1.  In SB, we return a RepeatStatus from the Tasklet#execute() method because a Tasklet can be repeated until that status says otherwise (a chunk based step is really just a tasklet step that executes a special tasklet repeatedly until the input is exhausted for example).  Is it the intention of the spec to not allow this behavior and only allow a tasklet to be executed once in sequence, but as many as the user wants in parallel?

2.  When partitioning a Batchlet, how is the ExitStatus calculated?  Since each batchlet could return it&apos;s own exit status, how are those automatically aggregated into a single BatchStatus?  What happens if one partition returns one thing and another returns a different one?  In SB, since a tasklet only returns a RepeatStatus, there is only one ExitStatus in play.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12501</commentid>
    <comment_count>13</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 20:31:12 +0000</bug_when>
    <thetext>I&apos;ll let Chris speak to the first point, but to the 2nd, I wanted to interject with what the RI currently does in case it needs adjustment. 

We would simply let the exit status default to the batch status.

The app would have to make use of a partition analyzer to set an explicit exit status for the step.... currently the return value of the batchlet process() is ignored.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12502</commentid>
    <comment_count>14</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-05 20:39:16 +0000</bug_when>
    <thetext>I hope we aren&apos;t saying that ignoring the ExitStatus of the Batchlet in a partitioned environment is an acceptable approach...

So the only way to use the ExitStatus on a Batchlet would be to use a PartitionAnalizer?  I know in the issue that discusses the addition of a ChunkContext, Chris points out that we want to have the same programming semantics in both a partitioned and non-partitioned environment.  This would seem to contradict that approach...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12503</commentid>
    <comment_count>15</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-02-05 20:51:38 +0000</bug_when>
    <thetext>The exit status of a batchlet is only ignored in the partitioned case. The batch container doesn&apos;t make an attempt to merge the multiple exit statuses. It leaves that up to the partition analyzer to handle that. 

The non-partitioned case still propagates the exit status of the step to any control elements such as next, end, fail..etc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12513</commentid>
    <comment_count>16</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-06 22:39:44 +0000</bug_when>
    <thetext>To Michael&apos;s point.. would it make sense to say:

A) If every partition returns the same exit status, that becomes the default step exit status.   

B) If not, then the step exit status defaults to the batch status.

-------

Another variant of B) would be to leave it undefined I guess....

None of this effects that explicitly setting exit status in StepContext would trump the default.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12539</commentid>
    <comment_count>17</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 18:52:12 +0000</bug_when>
    <thetext>I do not think we should ignore the batchlet exit status.  I think we should:

1) define that a batchlet that returns null exit status accepts the batch status as the exit status (i.e. accepts the default exit status)

2) when a partitioned batchlet returns non-null exit status, the last partition to end, sets the final exit status.

3) #2 may be non-deterministic,  in which case  a  partition analyzer can be added to coalesce the individual exit statuses from each partition.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12708</commentid>
    <comment_count>18</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-27 21:10:28 +0000</bug_when>
    <thetext>We are planning to go with the approach outlined in comment #17.  BTW, the same issue applies to partitioned chunk steps, too, insofar as a chunk partition can set the exit status on the StepContext.  Update will appear in PFD v1.5.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4567</bug_id>
          
          <creation_ts>2013-01-18 17:09:00 +0000</creation_ts>
          <short_desc>Open and Close are executed in their own transaction?</short_desc>
          <delta_ts>2013-01-28 22:51:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12181</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 17:09:29 +0000</bug_when>
    <thetext>In many of the flows described in section 8 wrap the open and close methods with their own transaction.  Why are these methods executed within their own transaction?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12184</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 17:27:18 +0000</bug_when>
    <thetext>So they don&apos;t contribute time to the first and last chunk&apos;s transaction time.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12196</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 20:16:57 +0000</bug_when>
    <thetext>I&apos;m not implying that they be included in the chunk&apos;s transaction...I&apos;m wondering why they get their own transaction at all?  Since open and close are intended to be used for resource management (and not for business processing which would be assumed to be the transactional work), why do they need to be wrapped in their own transaction?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12207</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-21 14:26:34 +0000</bug_when>
    <thetext>It is necessary so open can do rational things in open like create a db connection.  You cannot create a connection in local mode and then enlist in global trans.  So you need a consistent transaction mode else you impose unreasonable restrictions on the use of open.  You might be able to get away with always running close in local mode, but it&apos;s probably better for open and close to be consistent.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4568</bug_id>
          
          <creation_ts>2013-01-18 17:11:00 +0000</creation_ts>
          <short_desc>SplitCollector and SplitAnalyzer should be removed</short_desc>
          <delta_ts>2013-01-18 17:31:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12182</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 17:11:49 +0000</bug_when>
    <thetext>We had previously agreed to remove the SplitCollector and SplitAnalyzer yet it is still in the spec in section 8.1.1 on page 114.  This should be removed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12185</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 17:31:33 +0000</bug_when>
    <thetext>Yes, I missed those references.  They will be removed in v1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4569</bug_id>
          
          <creation_ts>2013-01-18 17:15:00 +0000</creation_ts>
          <short_desc>Note that stopping a job is a request</short_desc>
          <delta_ts>2013-01-23 20:34:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12183</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-18 17:15:29 +0000</bug_when>
    <thetext>In section 8.13 on page 114 the different methods to stop a job are identified.  We should note in the spec that these calls are purely a request and a successful/graceful stop cannot be guaranteed by the batch runtime.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12239</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 20:34:50 +0000</bug_when>
    <thetext>Agreed. Update will be in v1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4570</bug_id>
          
          <creation_ts>2013-01-18 19:14:00 +0000</creation_ts>
          <short_desc>Remove @BatchContext</short_desc>
          <delta_ts>2013-01-18 19:14:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12188</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:14:19 +0000</bug_when>
    <thetext>Batch context injection is discernable based on context type:  JobContext,etc. A qualifier is not required and should be removed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12189</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:14:51 +0000</bug_when>
    <thetext>@BatchContext will be removed from v1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4571</bug_id>
          
          <creation_ts>2013-01-18 19:38:00 +0000</creation_ts>
          <short_desc>Delete getExecutions method (redundant)</short_desc>
          <delta_ts>2013-01-18 19:39:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12193</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:38:26 +0000</bug_when>
    <thetext>Delete getExecutions method on JobOperator because it is redundant with getJobExecutions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12194</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-18 19:39:32 +0000</bug_when>
    <thetext>change made to v1.1 of proposed final draft</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4575</bug_id>
          
          <creation_ts>2013-01-19 04:47:00 +0000</creation_ts>
          <short_desc>Spec should say to use TCCL for artifact loading rather than System CL (SE) or EE CL</short_desc>
          <delta_ts>2013-01-25 18:46:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12202</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-19 04:47:39 +0000</bug_when>
    <thetext>Sorry for not thinking of this before, as given that the RI is not following the spec here it should have occurred to me already.

In Sec. 7.4 we have:

---

The batch runtime and the batch artifacts it loads execute in the class loader scope of the their invoker. This means if a typical Java main program starts a job through the JobOperator interface, the batch runtime and the batch artifacts it loads are loaded by the JVM system class loader. If a Java EE application starts a job, the Java EE application class loader hierarchy does the loading.

---

This sounds like we&apos;re saying the current classloader of the invoker of JobOperator.start() should be the starting classloader for artifact loading.   

Maybe it&apos;s my lack of imagination, but the only way I can see implementing this, and the way I&apos;ve seen it done in comparable situations, is to start from the thread context class loader (TCCL), not the current classloader of the invoker.   That&apos;s how the RI is currently implemented in fact (I don&apos;t want to sidetrack the discussion but there is a clear bug in the RI right now for artifact loading in an EE environment so don&apos;t take the RI as a complete example of what should work !)

Use of the TCCL should also work fine in SE, and in fact the same way as currently stated (since I believe the system CL is set as the TCCL by default, but yet we could use a single set of words to describe both environments).

Besides it being hard for imagine how to implement with the current classloader in EE, using the TCCL leads to more flexibility down the road.... if some piece of code on top of the JSR352 impl wants to use a different starting point for classloading, and they have access to set the TCCL to something else.. then we should use that TCCL value as the starting point.    

I know I should be able to dig up some precent but it&apos;s late so I&apos;ll postpone that for the case anyone disagrees...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12326</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:13:46 +0000</bug_when>
    <thetext>I think the spec should be less prescriptive in this section. What&apos;s important is to make clear that batch artifacts are loaded according to the class loader hierarchy is effect when JobOperator.start is invoked.

The updated section 7.4 now states only:

&quot;The batch runtime, and the batch artifacts it loads, execute in the class loader scope of the the JobOperator invoker.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12328</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-25 18:20:07 +0000</bug_when>
    <thetext>Chris,

I think your wording is unintentionally too prescriptive.

That could easily be read as &quot;the current classloader of the JobOperator invoker&quot;.... which is not what you want.

How about:  

&quot;The batch runtime will use standard techniques for selecting a classloader to load a given batch artifact, starting from a given JobOperator invocation.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12330</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:46:48 +0000</bug_when>
    <thetext>That&apos;s basically the same as saying it&apos;s implementation-specific.  Given the section on batch artifact loading (immediately follows) class loader section, I think we can delete the class loader section entirely.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4578</bug_id>
          
          <creation_ts>2013-01-21 22:07:00 +0000</creation_ts>
          <short_desc>JobOperator.getJobInstances()  ordering?  zero-based vs. one-based</short_desc>
          <delta_ts>2013-01-28 18:56:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12210</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-21 22:07:30 +0000</bug_when>
    <thetext>For:
List&lt;JobInstance&gt; getJobInstances(String jobName, int start, int count

Two things:

the Javadoc currently states: 

* @param start
* specifies the relative starting number to return from the
* maximal list of job instances.

1) Probably should be clear that &apos;start&apos; is zero-based rather than one-based.

2) If a specific order is intended (e.g. start=0 corresponds to the first JobInstance and the List is in order of time of JobInstance created ... then this should be stated in the spec.    Otherwise an implementation is free to use a &quot;random&quot; order or also to pick the reverse order (most recent corresponds to start=0).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12338</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-28 18:56:29 +0000</bug_when>
    <thetext>There is an issue with number two here.  We can&apos;t order JobInstances in chronological order since the JobInstance does not have any type of creation date (and really doesn&apos;t have much of a use for one).  The best we could do is go by the first execution date, but that seems messy.  The reason Spring Batch can guarantee the order is that we also control the layout of the repository (we require the use of sequences in the repository so we can order by that).  The spec does have that type of control since we did not provide any specifics on the underlying repository implementation.  I would recommend not providing an order guarantee on the instances.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4579</bug_id>
          
          <creation_ts>2013-01-22 22:56:00 +0000</creation_ts>
          <short_desc>Should we say anything about resolution of systemProperties value</short_desc>
          <delta_ts>2013-02-04 22:14:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12211</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-22 22:56:41 +0000</bug_when>
    <thetext>Though in bug 4350, we solved a related problem, we left unstated when exactly 
a &apos;systemProperties&apos; resolution happens in JSL substitution.

It would seem that there&apos;s room now for an implementation to offer a backdoor method for doing the equivalent of supplying restart parameters... that&apos;s simply because you could set a system property to one value initially and then to a later value before restart.

Did the move to disallow restart parameters intend to prevent this type of usage as well?   If so, I think this should be stated... 

Actually I&apos;d go further and say the most obvious interpreation is that the systemProperties value should in fact be read anew with each restart.   Would there be any objections say on having a TCK test depending on this behavior?

Looking at the same properties from another end of the spectrum... one could imagine implementation A doing a resolution at job start time, i.e. &quot;upfront&quot;... while implementation B defers resolution until that exact step is ready to execute.   Does this ambiguity too need to be closed down?  

I&apos;m not as worried about this latter case... implementation B in this example is getting into complicated territory regarding the entirety of property substitution and inheritance... and getting into corner cases probably too complex to spend too much time worrying about.   I was just mentioning this for completeness.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12228</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 18:52:46 +0000</bug_when>
    <thetext>What additional we say about resolving property substitution from system properties must align with resolution of http://java.net/bugzilla/show_bug.cgi?id=4562

If Bug 4562 reinstates restart parameters, then I don&apos;t think anything special need be said concerning substitution from system properties.

If Bug 4562 reaffirms having NO restart parameters,  then I think the spec needs to say that substitutions are not reprocessed on restart.  I.e. the original post-substitution Job XML is what gets used on restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12477</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-04 22:14:43 +0000</bug_when>
    <thetext>We are adding back restart parameters:  http://java.net/bugzilla/show_bug.cgi?id=4562 

So this bug is no longer vald.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4582</bug_id>
          
          <creation_ts>2013-01-23 02:57:00 +0000</creation_ts>
          <short_desc>Property default value expression may not contain default value expression</short_desc>
          <delta_ts>2013-01-26 20:05:53 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12214</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-01-23 02:57:13 +0000</bug_when>
    <thetext>The default value of a property can be another value expression, which theoretically may contain its own default value expression.  But I don&apos;t think that&apos;s common use, and would like to propose to disallow the default value expressing having its own default.  

For example, the following expression would be considered illegal:

&quot;#{systemProperties[&apos;foo&apos;]}?:#{systemProperties[&apos;bar&apos;]}?:1.0;&quot;

If the spec does want to support this structure, it should explicitly state so.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12265</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 00:08:12 +0000</bug_when>
    <thetext>Ok, that was not the intent. One attribute value should have one default. I rewrote the syntax to make that true:

&lt;attribute-value&gt; ::= &apos; &quot; &apos; &lt;value-expression&gt; [ &quot;?:&quot; &lt;value-expression&gt; &quot;;&quot;] &apos; &quot; &apos;

&lt;value-expression&gt; ::= &quot;#{&quot;&lt;operator-expression&gt;&quot;}&quot; | &lt;string-literal&gt; [ &lt;value-expression&gt; ]</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12334</commentid>
    <comment_count>2</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-01-26 20:05:53 +0000</bug_when>
    <thetext>The intent of the previous grammar in the spec was to associate each default value expression with one operator expression. This way it is unambiguous as to which part of a value expression did not resolve if there are multiple operator expressions or literals. If we have one default value for an entire attribute we have to create a more complex definition of what unresolved means and it restricts the number of operator expressions that can effectively be used within an attribute.

I agree that we probably shouldn&apos;t allow recursive substitutions. The grammar below should achieve the effect of not allowing recursive default substitution expressions while still keeping the grammar unambiguous. We just need to introduce a new symbol &quot;default-value-expression&quot; that does not allow substitutions within itself.

&lt;attribute-value&gt; ::= &apos; &quot; &apos; &lt;value-expression&gt; &apos; &quot; &apos;

&lt;default-value-expression&gt; ::= &quot;#{&quot;&lt;operator-expression&gt;&quot;}&quot; | &lt;string-literal&gt; [ &lt;default-value-expression&gt; ]

&lt;value-expression&gt; ::= &quot;#{&quot;&lt;operator-expression&gt;&quot;}&quot; [ &quot;?:&quot; &lt;default-value-expression&gt; &quot;;&quot;] | &lt;string-literal&gt; [ &lt;value-expression&gt; ]</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4586</bug_id>
          
          <creation_ts>2013-01-23 23:15:00 +0000</creation_ts>
          <short_desc>Removing Language of EE in Lifecycle flows</short_desc>
          <delta_ts>2013-01-24 20:26:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>waynexlund</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12260</commentid>
    <comment_count>0</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-23 23:15:19 +0000</bug_when>
    <thetext>I think we should replace all of the references in the process flows from &quot;[&lt;begin transaction&gt; EE only]&quot; with  [&lt;begin transaction&gt; global transacdtion only].  My reasoning is that you can have JTA in JSE through libraries like JOTM or Atomikos.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12261</commentid>
    <comment_count>1</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-23 23:17:12 +0000</bug_when>
    <thetext>In addition, let&apos;s remove the explicit EE references where it infers global transactions throughout the documentation since java batch is intended to run in both environments.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12263</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-23 23:39:05 +0000</bug_when>
    <thetext>(In reply to comment #0)

Yes, I agree the &quot;EE Only&quot; references can be removed. But be aware the spec indicats in section 6.7 a compliant implementation uses local mode on the Java SE platform.  An implementer is free to offer JTA semantics with packages like JOTM. 

&gt; I think we should replace all of the references in the process flows from
&gt; &quot;[&lt;begin transaction&gt; EE only]&quot; with  [&lt;begin transaction&gt; global transacdtion
&gt; only].  My reasoning is that you can have JTA in JSE through libraries like
&gt; JOTM or Atomikos.

(In reply to comment #1)

I don&apos;t know where you mean.  The only reference I find that even remotely fits that category is in section 6.7:

&quot;The batch runtime uses global transaction mode on the Java EE platform and local transaction mode  on the Java SE platform.&quot;

Did you find others?

&gt; In addition, let&apos;s remove the explicit EE references where it infers global
&gt; transactions throughout the documentation since java batch is intended to run
&gt; in both environments.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12297</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-24 20:26:24 +0000</bug_when>
    <thetext>All EE references in section 8 have been removed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4590</bug_id>
          
          <creation_ts>2013-01-25 04:25:00 +0000</creation_ts>
          <short_desc>Minor wording suggestion on &apos;filter&apos; from process returning &apos;null&apos;</short_desc>
          <delta_ts>2013-01-28 19:12:23 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12311</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-25 04:25:48 +0000</bug_when>
    <thetext>The Javadoc for ItemProcessor.processItem() states:

&quot;If processItem returns null, no value is passed onto the chunk&apos;s item writer.&quot;

It&apos;s not clear to me whether this means that the ItemWriter is NOT called at all or if a &apos;null&apos; value is passed within the List sent to writeItems.  

I&apos;m guessing the former but why leave room for interpretation?  If it&apos;s the former how about:

&quot;If processItem returns null, then the chunk&apos;s item writer is not called, and the chunk loop continues with the next readItem.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12315</commentid>
    <comment_count>1</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-25 16:04:30 +0000</bug_when>
    <thetext>I agree with the wording adjustment and it conforms to how we handle null from an itemProcessor in SB.  Our java doc states, &quot;returning null indicates that the item should not be continued to be processed&apos;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12325</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-25 18:08:14 +0000</bug_when>
    <thetext>(In reply to comment #1)

The spec now uses that wording.

&gt; I agree with the wording adjustment and it conforms to how we handle null from
&gt; an itemProcessor in SB.  Our java doc states, &quot;returning null indicates that
&gt; the item should not be continued to be processed&apos;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12339</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-28 19:12:23 +0000</bug_when>
    <thetext>That wording is not 100% correct.  When an ItemProcessor returns null, it is filtered out and not included in the chunk that is passed to the ItemWriter.  An ItemWriter is called once per chunk so even if the ItemProcessor returns null, the ItemWriter may still be called.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4596</bug_id>
          
          <creation_ts>2013-01-28 21:34:00 +0000</creation_ts>
          <short_desc>2 Introduction to JSR 352 should go on next page</short_desc>
          <delta_ts>2013-01-31 19:36:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12342</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 21:34:32 +0000</bug_when>
    <thetext>looks like this should start on page 9 as the TOC ends on page 8</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12403</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:36:25 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4597</bug_id>
          
          <creation_ts>2013-01-28 21:50:00 +0000</creation_ts>
          <short_desc>4 Domain Language of Batch - ItemProcessor is optional</short_desc>
          <delta_ts>2013-01-31 19:43:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12343</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 21:50:36 +0000</bug_when>
    <thetext>Section &quot;4 Domain Language of Batch&quot; reads:

&quot;A Job has one to many steps, which has exactly one ItemReader, ItemProcessor, and ItemWriter.&quot;

As ItemProcessor&apos;s are optional, I think it should read something to the effect of:

&quot;A Job has one to many steps, which has exactly one ItemReader, ItemWriter and optionally an ItemProcessor.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12406</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:43:39 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4598</bug_id>
          
          <creation_ts>2013-01-28 21:55:00 +0000</creation_ts>
          <short_desc>4.1.1 JobInstance parenthesized sentence</short_desc>
          <delta_ts>2013-01-31 19:55:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12344</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 21:55:21 +0000</bug_when>
    <thetext>I think the following:

&quot;..... run. (Usually this corresponds with the data it is processing as well, meaning the January 1st run processes data for January 1st, etc). Therefore ....&quot;

Should be written as:

&quot;..... run. Usually this corresponds with the data it is processing as well, meaning the January 1st run processes data for January 1st, etc. Therefore ....&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12413</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:55:16 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4599</bug_id>
          
          <creation_ts>2013-01-28 21:58:00 +0000</creation_ts>
          <short_desc>4.1.2 JobParameters</short_desc>
          <delta_ts>2013-01-31 20:50:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12345</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 21:58:17 +0000</bug_when>
    <thetext>I think the following:

&quot;The JobOperator start operation support the specification of job parameters.&quot;

Should be:

&quot;The JobOperator start operation supports the specification of job parameters.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12434</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 20:50:45 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4600</bug_id>
          
          <creation_ts>2013-01-28 22:00:00 +0000</creation_ts>
          <short_desc>4.2 Step</short_desc>
          <delta_ts>2013-02-01 20:27:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12346</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 22:00:43 +0000</bug_when>
    <thetext>The following:

&quot;A simple Step might load data from a file into the database, requiring little or no code,depending upon the implementations used.&quot;

Should have a space between &quot;code,&quot; and &quot;depending&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12445</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 20:27:12 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4601</bug_id>
          
          <creation_ts>2013-01-28 22:11:00 +0000</creation_ts>
          <short_desc>4.5 - 4.7 Inconsistent use of interface name casing</short_desc>
          <delta_ts>2013-02-01 22:33:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12347</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-28 22:11:35 +0000</bug_when>
    <thetext>Seems like the following would make things more consistent in the heading (as with &quot;4.3 JobOperator&quot;:

4.5 - &quot;Item Reader&quot; should be &quot;ItemReader&quot;

4.6 - &quot;Item Writer&quot; should be &quot;ItemWriter&quot;

4.7 - &quot;Item Processor&quot; should be &quot;ItemProcessor&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12447</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:33:07 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4602</bug_id>
          
          <creation_ts>2013-01-29 20:41:00 +0000</creation_ts>
          <short_desc>5.1.3 Job Level Properties</short_desc>
          <delta_ts>2013-02-01 22:44:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12351</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:41:05 +0000</bug_when>
    <thetext>I think the following:

Job level properties are available through the Job Context runtime object.

should be:

Job level properties are available through the JobContext runtime object.

Also, in the table with name, Value and save-as, Value should be &quot;value&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4603</bug_id>
          
          <creation_ts>2013-01-29 20:41:00 +0000</creation_ts>
          <short_desc>5.2.1.4 Chunk Exception Handling incomplete sentence</short_desc>
          <delta_ts>2013-02-01 22:50:46 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12352</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:41:57 +0000</bug_when>
    <thetext>The first paragraph ends in &quot;Skipping Exceptions&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12452</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:50:46 +0000</bug_when>
    <thetext>It is supposed to be a heading.  Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4604</bug_id>
          
          <creation_ts>2013-01-29 20:42:00 +0000</creation_ts>
          <short_desc>5.2.3 Step Level Properties</short_desc>
          <delta_ts>2013-02-01 22:58:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12353</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:42:47 +0000</bug_when>
    <thetext>I think the following:

&quot;Step level properties are available through the Step Context runtime object.&quot;

Should be:

&quot;Step level properties are available through the StepContext runtime object.&quot;

and

&quot;See section 6.4 for further information about Step Context.&quot;

Should be:

&quot;See section 6.4 for further information about StepContext.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12455</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:58:44 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4605</bug_id>
          
          <creation_ts>2013-01-29 20:43:00 +0000</creation_ts>
          <short_desc>5.2.4.1 Step Level Listener Properties</short_desc>
          <delta_ts>2013-01-31 18:39:23 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12354</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:43:07 +0000</bug_when>
    <thetext>In the table, under the name key:

&quot;If not, it is ignored.This is a required attribute.&quot;

Should be:

&quot;If not, it is ignored. This is a required attribute.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12396</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 18:39:23 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4606</bug_id>
          
          <creation_ts>2013-01-29 20:43:00 +0000</creation_ts>
          <short_desc>5.2.6.1 Partition Plan incomplete XML</short_desc>
          <delta_ts>2013-01-31 19:06:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12355</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:43:44 +0000</bug_when>
    <thetext>I think the XML listed in the example should be (close partition tag and remove space before plan element):

&lt;step id=&quot;Step1&quot;&gt;
  &lt;chunk .../&gt;
  &lt;partition&gt;
    &lt;plan partitions=&quot;3&quot; threads=&quot;2&quot;/&gt;
  &lt;/partition&gt;
&lt;/step&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12401</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:06:10 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4607</bug_id>
          
          <creation_ts>2013-01-29 20:44:00 +0000</creation_ts>
          <short_desc>5.2.6.2 Partition Properties</short_desc>
          <delta_ts>2013-01-31 19:39:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12356</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:44:15 +0000</bug_when>
    <thetext>I think the XML listed in the syntax should be (close properties and remove space before name-value):

&lt;properties partition=&quot;partition-number&quot;&gt; 
  &lt;property name=&quot;{property-name}&quot; value=&quot;{name-value}&quot; save-as=&quot;{output-property-name}&quot;/&gt;
&lt;/properties&gt;

Also, a space is needed in the table, under the name key:

&quot;If not, it is ignored.This is a required attribute.&quot;

Should be:

&quot;If not, it is ignored. This is a required attribute.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12404</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:39:01 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4608</bug_id>
          
          <creation_ts>2013-01-29 20:44:00 +0000</creation_ts>
          <short_desc>5.2.6.3 Partition Mapper</short_desc>
          <delta_ts>2013-01-31 19:45:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12357</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:44:37 +0000</bug_when>
    <thetext>&lt; mapper ref=&quot;{name}&quot;&gt;

Should be:

&lt;mapper ref=&quot;{name}&quot;&gt;

and:

&lt;partition&gt; 
  &lt; mapper ref=&quot;MyStepPartitioner&quot;/&gt;
&lt;/partition&gt;

Should be:

&lt;partition&gt; 
  &lt;mapper ref=&quot;MyStepPartitioner&quot;/&gt;
&lt;/partition&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12407</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:45:51 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4609</bug_id>
          
          <creation_ts>2013-01-29 20:45:00 +0000</creation_ts>
          <short_desc>5.2.6.3.1 Mapper Properties</short_desc>
          <delta_ts>2013-01-31 20:01:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12358</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:45:07 +0000</bug_when>
    <thetext>&lt;property name=&quot;{property-name}&quot; value=&quot;{ name-value}&quot; save-as=&quot;{output-property-name}&quot;/&gt;

Should be:

&lt;property name=&quot;{property-name}&quot; value=&quot;{name-value}&quot; save-as=&quot;{output-property-name}&quot;/&gt;

Also, a space is needed in the table, under the name key:

&quot;If not, it is ignored.This is a required attribute.&quot;

Should be:

&quot;If not, it is ignored. This is a required attribute.&quot;

Both of these seem to be present in multiple sections.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12416</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 20:01:27 +0000</bug_when>
    <thetext>All occurrences found and fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4610</bug_id>
          
          <creation_ts>2013-01-29 20:45:00 +0000</creation_ts>
          <short_desc>5.3 Flow</short_desc>
          <delta_ts>2013-01-31 20:52:59 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12359</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:45:28 +0000</bug_when>
    <thetext>The syntax:

&lt;flow id=&quot;{name}&quot;next=&quot;{ flow-id|step-id|split-id|decision-id}&quot; &gt; 
  &lt;step&gt; ... &lt;/step&gt; ... 
&lt;/flow&gt;

Should be (add/remove spaces, new line after close step tag):

&lt;flow id=&quot;{name}&quot; next=&quot;{flow-id|step-id|split-id|decision-id}&quot;&gt; 
  &lt;step&gt; ... &lt;/step&gt; 
  ... 
&lt;/flow&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12435</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 20:52:59 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4611</bug_id>
          
          <creation_ts>2013-01-29 20:45:00 +0000</creation_ts>
          <short_desc>5.4 Split</short_desc>
          <delta_ts>2013-02-01 20:34:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12360</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:45:55 +0000</bug_when>
    <thetext>&lt;split id=&quot;{name}&quot;next=&quot;{ flow-id|step-id|split-id|decision-id}&quot; &gt; 
  &lt;flow&gt; ... &lt;/flow&gt; 
  ... 
&lt;/split&gt;

Should be:

&lt;split id=&quot;{name}&quot; next=&quot;{flow-id|step-id|split-id|decision-id}&quot;&gt; 
  &lt;flow&gt; ... &lt;/flow&gt; 
  ... 
&lt;/split&gt;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4612</bug_id>
          
          <creation_ts>2013-01-29 20:46:00 +0000</creation_ts>
          <short_desc>5.5 Batch and Exit Status</short_desc>
          <delta_ts>2013-02-01 22:36:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12361</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:46:13 +0000</bug_when>
    <thetext>I think:

The batch and exit status of the job is set as follows:
1. it is initially the same as the batch and exit status of the last execution element (step, flow, split) to run
2. batch and exit status can be overridden by a decision element
3. batch and exit status for the job can be overridden by a job listener as the job ends. This overrides all else.

Should be:

The batch and exit status of the job is set as follows:
1. It is initially the same as the batch and exit status of the last execution element (step, flow, split) to run.
2. Batch and exit status can be overridden by a decision element.
3. Batch and exit status for the job can be overridden by a job listener as the job ends. This overrides all else.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12448</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:36:22 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4613</bug_id>
          
          <creation_ts>2013-01-29 20:46:00 +0000</creation_ts>
          <short_desc>5.5.1.2 End Element</short_desc>
          <delta_ts>2013-02-01 22:45:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12362</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:46:32 +0000</bug_when>
    <thetext>In the &quot;Where&quot; table &quot;On&quot; should be &quot;on&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12450</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:45:22 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4614</bug_id>
          
          <creation_ts>2013-01-29 20:46:00 +0000</creation_ts>
          <short_desc>5.6 Decision</short_desc>
          <delta_ts>2013-02-01 22:53:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12363</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:46:59 +0000</bug_when>
    <thetext>In the &quot;Where&quot; table &quot;Id&quot; should be &quot;id&quot; and &quot;Ref&quot; should be &quot;ref&quot;. The leading space before Specifies in the ref description column should be removed.

Also the example:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot; &gt; 
... 
&lt;/decision&gt;

Should be:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot;&gt; 
... 
&lt;/decision&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12453</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:53:48 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4615</bug_id>
          
          <creation_ts>2013-01-29 20:47:00 +0000</creation_ts>
          <short_desc>5.6.1 Fail Element</short_desc>
          <delta_ts>2013-02-01 23:00:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12364</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:47:29 +0000</bug_when>
    <thetext>The example:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot; &gt;
  &lt;fail on=&quot;FAILED&quot; exit-status=&quot;DO NOT RESTART&quot;/&gt;
&lt;/decision&gt;

Should be:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot;&gt;
  &lt;fail on=&quot;FAILED&quot; exit-status=&quot;DO NOT RESTART&quot;/&gt;
&lt;/decision&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12456</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 23:00:48 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4616</bug_id>
          
          <creation_ts>2013-01-29 20:54:00 +0000</creation_ts>
          <short_desc>5.6.2 End Element</short_desc>
          <delta_ts>2013-01-31 18:42:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12365</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:54:23 +0000</bug_when>
    <thetext>The example:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot; &gt;
  &lt;end on=&quot;COMPLETED&quot; exit-status=&quot;EARLY COMPLETION&quot;/&gt;
&lt;/decision&gt;

Should be:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot;&gt;
  &lt;end on=&quot;COMPLETED&quot; exit-status=&quot;EARLY COMPLETION&quot;/&gt;
&lt;/decision&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12397</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 18:42:00 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4617</bug_id>
          
          <creation_ts>2013-01-29 20:54:00 +0000</creation_ts>
          <short_desc>5.6.3 Stop Element</short_desc>
          <delta_ts>2013-01-31 19:07:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12366</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:54:44 +0000</bug_when>
    <thetext>The example:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot; &gt; 
  &lt;stop on=&quot;COMPLETED&quot; exit-status=&quot;RESTART&quot; restart=&quot;Step2&quot;/&gt; 
&lt;/decision&gt;

Should be:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot;&gt; 
  &lt;stop on=&quot;COMPLETED&quot; exit-status=&quot;RESTART&quot; restart=&quot;Step2&quot;/&gt; 
&lt;/decision&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12402</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:07:30 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4618</bug_id>
          
          <creation_ts>2013-01-29 20:55:00 +0000</creation_ts>
          <short_desc>5.6.4 Next Element</short_desc>
          <delta_ts>2013-01-31 19:40:57 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12367</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:55:00 +0000</bug_when>
    <thetext>The example:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot; &gt; 
  &lt;next on=&quot;*&quot; to=&quot;Step2&quot; /&gt;
&lt;/decision&gt;

Should be:

&lt;decision id=&quot;AfterFlow1&quot; ref=&quot;MyDecider&quot;&gt; 
  &lt;next on=&quot;*&quot; to=&quot;Step2&quot;/&gt;
&lt;/decision&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12405</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:40:57 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4619</bug_id>
          
          <creation_ts>2013-01-29 20:55:00 +0000</creation_ts>
          <short_desc>5.7 Job XML Substitution</short_desc>
          <delta_ts>2013-01-31 19:52:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12368</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:55:17 +0000</bug_when>
    <thetext>The last example:

&quot;&lt;property name=&quot;infile.name&quot; value=&quot;#{saved[&apos;step1.infile.name&apos;]}&quot; /&gt;&quot;

and description aren&apos;t bulleted like the others.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12411</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 19:52:48 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4620</bug_id>
          
          <creation_ts>2013-01-29 20:55:00 +0000</creation_ts>
          <short_desc>6.1.1.2 ItemProcessor Interface</short_desc>
          <delta_ts>2013-01-31 20:49:04 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12369</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:55:38 +0000</bug_when>
    <thetext>It should be noted that while an ItemProcessor is one of the three batch artifact types in a chunk step, an ItemProcessor is optional.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12433</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 20:49:04 +0000</bug_when>
    <thetext>Noted in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4621</bug_id>
          
          <creation_ts>2013-01-29 20:56:00 +0000</creation_ts>
          <short_desc>6.2.2 StepListener Interface</short_desc>
          <delta_ts>2013-01-31 20:59:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12370</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:56:02 +0000</bug_when>
    <thetext>&quot;A step listener can receive control before and after a step runs, , and also if an exception is thrown during step processing.&quot;

Has double &quot;, ,&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12436</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 20:59:14 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4622</bug_id>
          
          <creation_ts>2013-01-29 20:56:00 +0000</creation_ts>
          <short_desc>6.7 Transactionality</short_desc>
          <delta_ts>2013-02-01 20:37:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12371</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:56:21 +0000</bug_when>
    <thetext>Looks like the font in this section is different than others.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12446</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 20:37:49 +0000</bug_when>
    <thetext>Should be Calibri 11.  Fixed in PFD 1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4623</bug_id>
          
          <creation_ts>2013-01-29 20:56:00 +0000</creation_ts>
          <short_desc>7.3 JobOperator</short_desc>
          <delta_ts>2013-02-01 22:37:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12372</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:56:37 +0000</bug_when>
    <thetext>JobOperator jobOper= BatchRuntime.getJobOperator();

Should be:

JobOperator jobOper = BatchRuntime.getJobOperator();</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12449</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:37:32 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4624</bug_id>
          
          <creation_ts>2013-01-29 20:56:00 +0000</creation_ts>
          <short_desc>7.4 Batch Artifact Loading</short_desc>
          <delta_ts>2013-02-01 22:47:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12373</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:56:53 +0000</bug_when>
    <thetext>I think:

1. implementation-specific loader

Should be:

1. Implementation-specific loader

and:

2. archive loader

Should be:

2. Archive loader</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12451</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:47:39 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4625</bug_id>
          
          <creation_ts>2013-01-29 20:57:00 +0000</creation_ts>
          <short_desc>7.5 Job XML Loading</short_desc>
          <delta_ts>2013-02-01 22:55:46 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12374</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:57:47 +0000</bug_when>
    <thetext>I think:

1. on the JobOperator.start command (see 7.7.9) to start a job.
2. from within a Job XML to resolve inheritance (see 5.8).

Should be:

1. On the JobOperator.start command (see 7.7.9) to start a job.
2. From within a Job XML to resolve inheritance (see 5.8).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12454</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-01 22:55:46 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4626</bug_id>
          
          <creation_ts>2013-01-29 20:58:00 +0000</creation_ts>
          <short_desc>7.6.1 META-INF/batch.xml</short_desc>
          <delta_ts>2013-01-31 18:31:55 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12375</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:58:27 +0000</bug_when>
    <thetext>The first &quot;specifies&quot; in both description columns in the &quot;Where&quot; table should be upper-cased.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12395</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 18:31:55 +0000</bug_when>
    <thetext>Fixed in PFD v1.3</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4627</bug_id>
          
          <creation_ts>2013-01-29 20:58:00 +0000</creation_ts>
          <short_desc>7.6.2 META-INF/batch-jobs</short_desc>
          <delta_ts>2013-01-31 18:51:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12376</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-01-29 20:58:46 +0000</bug_when>
    <thetext>The first &quot;specifies&quot; in both description columns in the table should be upper-cased.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12398</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 18:51:43 +0000</bug_when>
    <thetext>Fixed in PFD v1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4634</bug_id>
          
          <creation_ts>2013-01-30 21:41:00 +0000</creation_ts>
          <short_desc>support subclass of java.lang.Throwable in all ExceptionClassFilter elements</short_desc>
          <delta_ts>2013-01-31 19:01:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12390</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-01-30 21:41:03 +0000</bug_when>
    <thetext>These elements include &lt;skippable-exception-classes&gt;, &lt;retryable-exception-classes&gt;, &lt;no-rollback-exception-classes&gt;.  Currently they take subclasses of exception.  I think we can broaden it to take all subclasses of Throwable to be flexible.

Some apps may need to recover from, or retry java.lang.Error, such as java.lang.AssertionError.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12399</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-31 18:55:40 +0000</bug_when>
    <thetext>I don&apos;t think we should do this.  

As per http://docs.oracle.com/javase/6/docs/api/java/lang/Error.html

&quot;An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch.&quot;

And therefore should not try to skip or retry.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12400</commentid>
    <comment_count>2</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2013-01-31 19:01:14 +0000</bug_when>
    <thetext>I second the veto.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4641</bug_id>
          
          <creation_ts>2013-02-05 07:00:00 +0000</creation_ts>
          <short_desc>Page 8 Stop Processing has text in TOC</short_desc>
          <delta_ts>2013-02-22 17:59:53 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12483</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2013-02-05 07:00:28 +0000</bug_when>
    <thetext>In the TOC under 8.13 Stop processing looks like some non-TOC text made it in there</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12661</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-22 17:59:53 +0000</bug_when>
    <thetext>It&apos;s gone in PFD v1.4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4642</bug_id>
          
          <creation_ts>2013-02-05 13:00:00 +0000</creation_ts>
          <short_desc>Clarify include/exclude for skip/retry and also rollback vs no-rollback retry exceptions in JSL</short_desc>
          <delta_ts>2013-02-28 21:45:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12484</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 13:00:54 +0000</bug_when>
    <thetext>Two issues:

First, I think it would only help to clarify that if I have multiple includes and excludes, on a skip/retry exception sequence, that ANY exclude causes the exception to be excluded.   

E.g. if I have 

include 1
exclude 2
include 3 

And an exception matches exclude 2 and include 3...   it gets excluded.   It is not as if include 3 trumps exclude 2 since it follows it in sequence.

The behavior we&apos;re going for is what Ant uses, to my knowledge, so it&apos;s probably safely expected anyway...but it would only help to clarify.

Second,  I think an issue I brough up before (Bug 4148, but no need to read the whole thing) is still unclear.

The way in which &lt;retryable-exception-classes&gt; and &lt;no-rollback-exception-classes&gt; are specified needs more wording.

Reading into your views here, I think you envision every entry in
 &lt;no-rollback-exception-classes&gt; also appearing in &lt;retryable-exception-classes&gt; 

So the &lt;no-rollback-exception-classes&gt; basically acts as a filter grafted on top of the include/exclude filter in &lt;retryable-exception-classes&gt;.   

I think you envision the algorithm as:

* Does exception get included from the include/exclude filter in &lt;retryable-exception-classes&gt;?  
* If no, don&apos;t retry in either manner:  rollback or no-rollback.  
* If yes, does exception get included from the include/exclude filter in  &lt;no-rollback-exception-classes&gt;?   If no, then retry with rollback.  If yes, then retry with no-rollback.

I think this should be spelled out... since another interpretation is that &lt;retryable-exception-classes&gt; and  &lt;no-rollback-exception-classes&gt; are &quot;peer&quot; filters, (with it underspecified which would take precdence).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12722</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 21:45:15 +0000</bug_when>
    <thetext>Agreed on all counts.  Will update the appropriate sections in PFD v1.5</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4643</bug_id>
          
          <creation_ts>2013-02-05 17:06:00 +0000</creation_ts>
          <short_desc>OK if flow and split do not contain &apos;next, stop, end, fail&apos; child elements?</short_desc>
          <delta_ts>2013-03-20 03:25:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12485</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 17:06:17 +0000</bug_when>
    <thetext>Though the RI currently assumes you can do:

&lt;flow &gt;
  &lt;step
  &lt;step&gt;
  &lt;next on=
  &lt;end on=&quot;
&lt;/flow&gt;

(You can see the XSD grants this as a possibility).

I don&apos;t see any justification for this in the spec.   The spec only seems to grant permission for a split/flow to use the @next attribute on the &lt;flow&gt; or &lt;split&gt; element itself.

So anything more complicated would have to be done in a decision.

This seems like a nice simplification, but I wanted to run it by you before removing this from the RI (and we&apos;ll update the XSD as well).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12729</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 13:36:25 +0000</bug_when>
    <thetext>The following elements are meant to be supported as child elements of &lt;flow&gt; and &lt;split&gt;:

1. &lt;end&gt;
2. &lt;stop&gt;
3. &lt;next&gt;
4. &lt;fail&gt;


This is an error in the spec and will be corrected in PFD v1.5.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12903</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 19:12:12 +0000</bug_when>
    <thetext>Chris, 

We actually went down this path on Bug 4540 and realized a split doesn&apos;t get an exit status... so it only makes sense to unconditionally @next from split.

For flow.. if we need a tiebreaker vote on whether to allow this or not.. I will say that the RI/TCK doesn&apos;t currently support this (except that I updated the XSD to &quot;support&quot; it).

Only allowing a flow a @next attr puts it more in your face that only a step has exit status.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12989</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:25:49 +0000</bug_when>
    <thetext>Refinement:

Flow will support transitions elements.  Split will not.  The transition elements are stop, end, next, and fail.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4644</bug_id>
          
          <creation_ts>2013-02-05 17:32:00 +0000</creation_ts>
          <short_desc>StepStatus not defined;  ordering not defined on array parm:  public String decide(StepStatus[] statuses)</short_desc>
          <delta_ts>2013-03-01 13:57:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12486</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 17:32:03 +0000</bug_when>
    <thetext>You forgot to include the StepStatus definition.

Even if StepStatus has a getId(), there is still a question to answer whether or not the Decider can assume an ordering on &apos;statuses&apos;..e.g. is it the same order as the ordering of flows in the JSL sequence.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12730</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 13:57:21 +0000</bug_when>
    <thetext>This bug is no longer valid since we removed StepStatus on the Decider interface and replaced it with StepExecution.  The spec will say nothing about order of the StepExecution[] array on &quot;String decide(StepExecution[])&quot; so nothing can be assumed by the application.  That further implies the implementation can order the elements in the array however it chooses.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4645</bug_id>
          
          <creation_ts>2013-02-05 17:44:00 +0000</creation_ts>
          <short_desc>Decider Javadoc language on exitStatus is misleading</short_desc>
          <delta_ts>2013-03-01 14:34:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12487</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-05 17:44:23 +0000</bug_when>
    <thetext>The Decider interface Javadoc repeates says in three method-level places (actually one whole method block is a dup):

&quot;The return value updates the current job execution&apos;s exit status. &quot;

That&apos;s misleading, since it&apos;s better described at the class-level Javadoc:

&quot; * The decider returns a String value which becomes the exit 
 * status value on which the decision chooses the next transition. &quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12732</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 14:34:40 +0000</bug_when>
    <thetext>We have reduced the number of methods on decider to exactly one.  The class level java doc will be updated consistent with what you suggest.  Change will be in PFD v1.5.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4647</bug_id>
          
          <creation_ts>2013-02-06 13:12:00 +0000</creation_ts>
          <short_desc>More detail on JobStartException / JobRestartException?  Job - abstract / restartable</short_desc>
          <delta_ts>2013-03-01 18:23:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12506</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-06 13:12:16 +0000</bug_when>
    <thetext>There&apos;s not much detail on when exactly a runtime should throw  JobStartException / JobRestartException?

I can see some value in having a general-type exception that an impl might throw for impl-specific reasons... 

As we&apos;re working on the RI/TCK we are faced with:

1a. should job start of an abstract job (or a job with an abstract step) result in a JobStartException?   

1b. should there NOT be a JobInstance or a JobExecution in this case (rather than creating a JobExecution which would end up with a batch status of FAILED).

2a. For restartable=false jobs, should this fail with a JobRestartException? 

2b. Should this NOT have a JobExecution for the restart?

------------------------------------------------------------------------------

The spec COULD choose to say something both about the specific exception associated with abstract jobs (or steps) and restartable=false.   It could also choose to say something about the association between JobStartException and JobRestartException and the lack of JobInstance/JobExecution.

Or I could envision saying this is all impl-specific as a valid choice.  Maybe I&apos;m shying away from that since that leaves me not knowing how to write the TCK test (if I don&apos;t know if there is a JobExecution or not, say).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12739</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:23:33 +0000</bug_when>
    <thetext>The spec will defer most error checking to the implementation.  However, consistent with servlet 3.0, it will require a schema-valid XML before a job can start.  Job start means that a job instance and job execution are created. Problems the runtime then detects with the job definition,  including, but not limited to:

1) no executable elements (i.e. only abstract steps)

2) non-existent transitions (i.e. next=&quot;value&quot; where &quot;value&quot; does not exist)

3) cycles among next values (i.e. step1:next=step2; step2:next=step1)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4648</bug_id>
          
          <creation_ts>2013-02-06 13:16:00 +0000</creation_ts>
          <short_desc>Do chunk ItemXXXXListener onXXXXError get called for skip/retried exceptions?</short_desc>
          <delta_ts>2013-03-01 18:45:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12507</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-06 13:16:52 +0000</bug_when>
    <thetext>E.g. does  ItemReadListener onReadError get called for skip/retried exceptions on the read?  Or only for non-skipped/retried exceptions?

From the pseudocode at the end of the spec, it seems the answer is &quot;yes&quot;, as in Sec. 8.8 you show:

iv.	&lt;-&gt;[ItemReadListener.onReadError] // thread A
v.	&lt;-&gt;[SkipListener.onSkipReadItem] // thread A

The equivalent pseudocode for retry listeners doesn&apos;t show the onXXXError method getting called though.  

If we couldn&apos;t raise the issue I&apos;d assume it did get called, but figured we&apos;d ask.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12740</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:45:56 +0000</bug_when>
    <thetext>Yes, the intention for exceptions is that all applicable listeners receive control (e.g. both read and skip listener).  The read/process/write listeners are missing in the retry schematic.  That will be fixed in PFD v1.5.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4654</bug_id>
          
          <creation_ts>2013-02-07 15:12:00 +0000</creation_ts>
          <short_desc>pkg-qualify @Inject at least once in spec</short_desc>
          <delta_ts>2013-02-08 19:09:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12520</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-07 15:12:30 +0000</bug_when>
    <thetext>Don&apos;t think it needs to be qualified every time..but at least once is probably good form.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12543</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 19:09:56 +0000</bug_when>
    <thetext>Agreed.  Update will be in PFD v1.4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4655</bug_id>
          
          <creation_ts>2013-02-07 15:50:00 +0000</creation_ts>
          <short_desc>clarify that @Inject is required for BatchProperty, BatchContext (though CDI, or a particular injection is not).</short_desc>
          <delta_ts>2013-02-08 19:52:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12521</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-07 15:50:03 +0000</bug_when>
    <thetext>I think this should be clarified.

For one, we have language like: &quot;BatchContexts can be injected&quot;  which could be taken to mean this is somehow optional. 

Two, the text around BatchProperty and BatchContext is not symmetrical... leading one to maybe think there&apos;s a difference here.

The @Inject is required... but CDI or a particular injection framework is not.   If no framework is used the batch runtime must do the injection itself.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12545</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 19:52:28 +0000</bug_when>
    <thetext>(In reply to comment #0)

&gt; I think this should be clarified.
&gt; For one, we have language like: &quot;BatchContexts can be injected&quot;  which could be
&gt; taken to mean this is somehow optional. 

&lt;cpv&gt; It now states: &quot;Batch artifact access to BatchContexts is by injection using the standard @Inject annotation (javax.inject.Inject).&quot;&lt;/cpv&gt;

&gt; Two, the text around BatchProperty and BatchContext is not symmetrical...
&gt; leading one to maybe think there&apos;s a difference here.

&lt;cpv&gt;

There is a difference:

@Inject @BatchProperty ...

@Inject &lt;context-type&gt; ...

I don&apos;t know what you expect concerning the asymmetry ...

&lt;/cpv&gt;

&gt; The @Inject is required... 

&lt;cpv&gt; True &lt;/cpv&gt;

&gt; but CDI or a particular injection framework is not. 
&gt; If no framework is used the batch runtime must do the injection itself.

&lt;cpv&gt; True again. The spec need only stipulate required use of @Inject.  It need not enumerate options for how implementers may satisfy the requirement. 
&lt;/cpv&gt;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4659</bug_id>
          
          <creation_ts>2013-02-08 12:52:00 +0000</creation_ts>
          <short_desc>JobOperator.getParameters should throw NoSuchJobInstanceException, not NoSuchJobExecutionException</short_desc>
          <delta_ts>2013-03-01 18:14:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12531</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-08 12:52:22 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12532</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-08 14:02:02 +0000</bug_when>
    <thetext>Since job parameters are off of the JobExecution, why would JobOperator.getParameters throw NoSuchJobInstanceException?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12533</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-08 14:19:45 +0000</bug_when>
    <thetext>Your comment prompted me to look over Bug 4562.    I&apos;d like to see how that pans out to know whether this is still an issue.

Before that whole discussion, this was wrong by the simple fact that we were passing in an instanceID parm, and therefore should get NoSuchJobInstanceException.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12547</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 23:04:32 +0000</bug_when>
    <thetext>The resolution of this bug is tied to the outcome of Bug 4562.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12738</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 18:14:28 +0000</bug_when>
    <thetext>The signature (as of PFD v1.4) is:

	public Properties getParameters(long executionId)
			throws NoSuchJobExecutionException;


That supports both start and restart parameters and throws the appropriate exception.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4660</bug_id>
          
          <creation_ts>2013-02-08 14:57:00 +0000</creation_ts>
          <short_desc>Implications of Sec 8.* pseudocode don&apos;t match rest of spec - property substitution, persistent userdata</short_desc>
          <delta_ts>2013-02-09 00:02:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12534</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-08 14:57:13 +0000</bug_when>
    <thetext>Two issues:

A) In saying in the pseudo code: 

  1.	&lt;Create StepContext&gt;
  2.	&lt;Apply substitutions to step level elements&gt;
   ...

This implies a late substitution... and as discussed implies late rather than early binding of systemProperty values.    I&apos;d say just remove it.

B) The Javadoc for StepContext.setPersistentUserData() says:

         * This data is saved as part of a step&apos;s 
	 * checkpoint. For a step that does not do checkpoints, it is saved 
	 * after the step ends. It is available upon restart. 
	 * @param data is the user-specified type

For all the chunk examples we have pseudo code showing it persisted at the end of step, however, not end of chunk.

17.	&lt;Store StepContext persistent area&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12550</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-09 00:02:27 +0000</bug_when>
    <thetext>Will fix in PFD v1.4.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4665</bug_id>
          
          <creation_ts>2013-02-08 23:27:00 +0000</creation_ts>
          <short_desc>Remove property save-as</short_desc>
          <delta_ts>2013-02-08 23:28:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12548</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 23:27:55 +0000</bug_when>
    <thetext>The save-as design results in conflicts when partitions save parameters.  In addition, the save-as design creates an implicit contract between the save-as step (producer) and the #{saved[xxx]} property substitution step (consumer). That constitutes a single-party contract when the batch artifacts and the job are implemented by different parties.  That&apos;s bad for contract law; it&apos;s bad for a programming model, too :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12549</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-08 23:28:44 +0000</bug_when>
    <thetext>Will be done in PFD v1.4</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4670</bug_id>
          
          <creation_ts>2013-02-12 15:01:00 +0000</creation_ts>
          <short_desc>unknown executable elements in the job.xml</short_desc>
          <delta_ts>2013-02-28 22:21:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>htavarez</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12557</commentid>
    <comment_count>0</comment_count>
    <who name="">htavarez</who>
    <bug_when>2013-02-12 15:01:44 +0000</bug_when>
    <thetext>&lt;job id=&quot;jobExecutableSequenceTest&quot; xmlns=&quot;http://batch.jsr352/jsl&quot;&gt;

	&lt;step id=&quot;step1&quot; next=&quot;step2&quot;&gt;
		&lt;batchlet ref=&quot;myBatchletImpl&quot;/&gt;
	&lt;/step&gt;
	&lt;step id=&quot;step2&quot; next=&quot;unknown&quot;&gt;
		&lt;batchlet ref=&quot;myBatchletImpl&quot;/&gt;
	&lt;/step&gt;
	&lt;step id=&quot;unreachable&quot;&gt;
		&lt;batchlet ref=&quot;myBatchletImpl&quot;/&gt;
	&lt;/step&gt;

&lt;/job&gt;

Should the RI flag an error before starting this job?

Should the JSR say something about it? Or, is it just an implementation detail?

What should the TCK test for? JobStartException?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12558</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-12 15:08:36 +0000</bug_when>
    <thetext>Another related question, as I raised in Bug 4647... if a job fails to start with a JobStartException (JobRestartException) should this imply a JobInstance/JobExecution are not created?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12559</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-12 15:15:11 +0000</bug_when>
    <thetext>With regards to your questions, the way Spring Batch handles things is as follows:

Should the RI flag an error before starting this job? Yes.  If a step defined within a job is unreachable, SB throws an exception.

Should the JSR say something about it? Or, is it just an implementation detail? Good question.  This goes to much more than just what to do in these scenarios but how far the JSR goes with regards to validation of the configuration.  I would be interested in looking at what other specs have done in this area (for example, what does the spec for a web.xml say?)

What should the TCK test for? JobStartException? This goes back to precedent IMHO.

With regards to whether a JobInstance/JobExecution is created on a job start failure, the way this is handled in SB is that the launcher creates the instance/execution just prior to the call to the execution of the job (in fact, the Job interface has an execute method that takes the JobExecution as the parameter).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12723</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 22:06:49 +0000</bug_when>
    <thetext>For reference,  here is a section from the Servelet 3.0 spec: 

14.2 Rules for Processing the Deployment
Descriptor

The deployment descriptor must be valid against the schema. Web containers and
tools that manipulate Web applications have a wide range of options for checking
the validity of a WAR. This includes checking the validity of the deployment
descriptor document held within.
Additionally, it is recommended that Web containers and tools that manipulate
Web applications provide a level of semantic checking. For example, it should be
checked that a role referenced in a security constraint has the same name as one of
the security roles defined in the deployment descriptor.
In cases of non-conformant Web applications, tools and containers should inform
the developer with descriptive error messages. High-end application server
vendors are encouraged to supply this kind of validity checking in the form of a
tool separate from the container.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12724</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 22:21:39 +0000</bug_when>
    <thetext>The batch spec will take a similar position.  The job must be be schema valid before the job can start.  If it fails schema validation,  JobStartException should be thrown.  The spec will say this. The spec will encourage semantic validation (e.g. next= value is valid) but will leave the behavior to the discretion of the implementation.  PFD v1.5 will contain these statements.

Now regarding the RI in this scenario, two approaches are valid and the RI team must choose one:

1) Do up front semantic validation on job xml before starting job.  Semantic validation would include whatever can be done by analyzing the xml. E.g. ensure all next= targets exist.  Issue JobStartException if up front semantic validation fails.  Do not create JobInstance/JobExecution. 

or 

2) Do only schema validation up front and detect semantic errors at runtime.  If schema validation passes, then create JobInstance/JobExecution.  If a semantic error occurs at runtime - e.g. next= target not valid - fail job with implementation-specific exception - e.g. com.ibm.jbatch.exception....

Either approach will conform with the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4672</bug_id>
          
          <creation_ts>2013-02-12 22:16:00 +0000</creation_ts>
          <short_desc>SPEC: How to identify the first job element.</short_desc>
          <delta_ts>2013-02-28 22:47:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12562</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-12 22:16:40 +0000</bug_when>
    <thetext>The first job element can be a step, flow, split, or a decision. I&apos;m 
wondering how an implementation determines which element should be the 
first to run inside a job.

Or is there a requirement that applications have to order them in a 
particular way? for example, the first non-abstract element under &lt;job&gt; 
is the first to run.

I didn&apos;t find such language in the current spec draft.  So looks like 
this is left to implementations.  I think this is an area that can 
benefit from more detailed spec coverage, at least provide some 
guidelines, usage tips, etc.

I guess one way is to traverse all next attr/element values, and if the 
id of any non-abstract step/decision/flow/split is not referenced as 
next by others, then it can be the head.   Steps, split, flows and 
decisions can be nested in multiple levels.

Some steps are not used as next, but exist as the parent of others:

&lt;job&gt;
&lt;step id=&quot;parent&quot;&gt;
   ...
&lt;/step&gt;

&lt;step id=&quot;child&quot; parent=&quot;parent&quot;&gt;
...
&lt;/step&gt;
&lt;/job&gt;

In the above example, I find both steps can be the head.  So in order to 
identify &quot;child&quot; is the element to run, we will also need to exclude 
those that are parent of other elements.

Just wanted to share my questions and thoughts, and would like to hear 
your insights and comments.

Cheng</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12687</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 16:00:12 +0000</bug_when>
    <thetext>The spec does say:

&quot;The first step, flow, or split defines the first step (flow or split) to execute for a given Job XML.&quot;

In the case of inheritance, would this be the first in the parent or child ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12725</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 22:47:13 +0000</bug_when>
    <thetext>The spec says this: 

&quot;5.2.5	Step Sequence 

The first step, flow, or split defines the first step (flow or split) to execute for a given Job XML.  The &apos;next&apos; attribute on the step, flow, or split defines what executes next.&quot;


I will clarify the paragraph to make it clear that &quot;first&quot; means in order of occurrence parsing from beginning to end of the xml document. In the case of a step, the &quot;first&quot; step must be abstract=true.


This update will go into PFD v1.5.


Concerning inheritance,  this matter of &quot;first&quot; could apply only to job inheritance and job inheritance explicitly excludes inheritance of steps, flows, splits, and decisions, as per section 5.8 Job XML Inheritance.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4676</bug_id>
          
          <creation_ts>2013-02-13 18:52:00 +0000</creation_ts>
          <short_desc>executable elements id scope</short_desc>
          <delta_ts>2013-03-01 14:11:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>htavarez</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12567</commentid>
    <comment_count>0</comment_count>
    <who name="">htavarez</who>
    <bug_when>2013-02-13 18:52:34 +0000</bug_when>
    <thetext>..
  &lt;step id=&apos;step1&apos;&gt;
  &lt;flow&gt;
     &lt;step id=&apos;step1&apos;&gt;


What&apos;s the scope of flow&apos;s step step1? 

Should it collide with job&apos;s step step1?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12731</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 14:11:38 +0000</bug_when>
    <thetext>The &quot;id&quot; values should be unique within their containment scope.  This means the following names are distinct:

&lt;step id=&quot;step1&quot;/&gt;

&lt;flow id=&quot;flow1&quot;&gt;
    &lt;step id=&quot;step1&quot;/&gt;
&lt;/flow&gt;

This will be important to support future &quot;flow&quot; inheritance.  E.g. would look something like this:

flow1.xml:

&lt;flow id=&quot;&quot;&gt;
   &lt;step id=&quot;step1&quot; /&gt;
&lt;/flow&gt;

job1.xml:

&lt;job id=&quot;job1&quot;&gt;
   &lt;step id=&quot;step1&quot; next=&quot;theFlow&quot;/&gt;
   &lt;flow id=&quot;theFlow&quot; parent=&quot;flow1&quot;/&gt;
&lt;/job&gt;

PFD will state the uniqueness rule for &quot;id&quot;.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4679</bug_id>
          
          <creation_ts>2013-02-14 15:22:00 +0000</creation_ts>
          <short_desc>The persistent user data in a Step Execution should extend Externalizable</short_desc>
          <delta_ts>2013-03-01 13:26:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12573</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-02-14 15:22:22 +0000</bug_when>
    <thetext>The persistent user data in a Step Execution should extend Externalizable

public interface StepContext &lt;T,P extends Externalizable&gt; ...:</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12728</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 13:26:10 +0000</bug_when>
    <thetext>Yes.  Except we are changing all uses of Externalizable to Serializable.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4687</bug_id>
          
          <creation_ts>2013-02-16 10:15:00 +0000</creation_ts>
          <short_desc>JobOperator.abandon should throw NoSuchJobExecutionException, not NoSuchJobInstanceException</short_desc>
          <delta_ts>2013-02-28 22:54:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12599</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-16 10:15:17 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12726</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 22:54:19 +0000</bug_when>
    <thetext>True.  Will be updated in PFD v1.5.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4688</bug_id>
          
          <creation_ts>2013-02-16 10:22:00 +0000</creation_ts>
          <short_desc>PartitionAnalyzer.analyzeStatus could use BatchStatus enum as parm type for &apos;batchStatus&apos; parm, not String</short_desc>
          <delta_ts>2013-02-28 16:44:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12600</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-16 10:22:59 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12716</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 16:44:40 +0000</bug_when>
    <thetext>Agreed for consistency.  Will appear in PFD v1.5.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4715</bug_id>
          
          <creation_ts>2013-02-23 16:21:00 +0000</creation_ts>
          <short_desc>Do we want to have restart parameters applied as overrides?</short_desc>
          <delta_ts>2013-02-28 19:53:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12689</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 16:21:30 +0000</bug_when>
    <thetext>See discussion about issue #1 in Bug 4702.  Restart properties were overrides way back (early draft timeframe) and RI/TCK still treats them as overrides.

Which do we want?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12691</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 16:24:16 +0000</bug_when>
    <thetext>Note that in Bug 4702 Michael raised the question of how to &quot;unset&quot; a parameter on override. 

Should setting the Property value to &apos;null&apos; be the answer?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12717</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 17:41:30 +0000</bug_when>
    <thetext>In the Proposed Final Draft,  job parameters are not overrides.  Rather, they are available to a job level substitution pool.  Job Parameter values may be freely substituted into attribute values using 

#{JobOperator[&apos;job parameter name&apos;]}

See section 5.7 Job XML Substitution.

So for example,  a job developer would choose to allow a job parameter to set (or influence) the value of a property - e.g.

&lt;property name=&quot;infile.name&quot; value=&quot;#{jobParameters[&apos;infile.name&apos;]}?:in.txt;&quot;/&gt;

Missing from the section is treatment of restart behavior, which needs to state that job parameters from the original start are saved and used on restart.  New parameters may be specified on the JobOperator.restart() method and replace saved job parameters of the same name.  

Updated text will appear in PFD v1.5</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12718</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-28 17:48:32 +0000</bug_when>
    <thetext>Chris,

How does that address the scenario of unsetting parameters?  Say I passed in a parameter on the first execution of the job, but on the restart I want to go back to the default.  What is the process for that?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12719</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-28 17:55:10 +0000</bug_when>
    <thetext>(In reply to comment #3)
&gt; Chris,
&gt; How does that address the scenario of unsetting parameters?  Say I passed in a
&gt; parameter on the first execution of the job, but on the restart I want to go
&gt; back to the default.  What is the process for that?


I think we could start from the example currently at the end of Sec. 5.7:


&lt;property name=&quot;infile.name&quot; value=&quot;#{jobParameter [&apos;infile.name&apos;]}?:in.txt;&quot; /&gt;

infile.name = value of infile.name job parameter or &quot;in.txt&quot; if infile.name job parameter is null.

------------------------------------------------------------------------------

First, since Properties can&apos;t hold &apos;null&apos;... the &quot;infile.name job parameter is null&quot; condition would more precisely be:  &quot;infile.name&quot; is not present as a key in the &quot;Properties&quot; object.  

So Michael has a valid point... there&apos;s no way to unset it to &apos;null&apos; at the moment.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12720</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-28 18:58:00 +0000</bug_when>
    <thetext>(In reply to comment #4)

Scott,

Honestly, I&apos;ve never considered &quot;unset&quot; an important use case.  I was really focused on common use cases and ease of use.  Typically, on restart, you only need to override one or two parameters, if any.  That&apos;s why I liked the idea of saving reusing, and optionally overriding the original start parameters.  But perhaps I&apos;m getting too focused on how the APIs might be used in contrast to what the APIs themselves should do.  

So let&apos;s consider this:

1) Save job parameters per (re)start in JobExecution.  We already have JobOperator.getParameters(long executionId), so we are already headed in that direction. 

2) Remember NO parameters on restart. Use only the parameters specified on restart for #{JobParameter} substitutions on the new execution.  

If the user of JobOperator wants to reuse previously specified parameters, they can do so by retrieving those parameters from the appropriate JobExecution and passing in the ones they want on restart.  Of course, they could override or omit any of those parameters.  Moreover, they could specify different or additional parameters as well.

Thoughts?


&gt; (In reply to comment #3)
&gt; &gt; Chris,
&gt; &gt; How does that address the scenario of unsetting parameters?  Say I passed in a
&gt; &gt; parameter on the first execution of the job, but on the restart I want to go
&gt; &gt; back to the default.  What is the process for that?
&gt; I think we could start from the example currently at the end of Sec. 5.7:
&gt; &lt;property name=&quot;infile.name&quot; value=&quot;#{jobParameter [&apos;infile.name&apos;]}?:in.txt;&quot;
&gt; /&gt;
&gt; infile.name = value of infile.name job parameter or &quot;in.txt&quot; if infile.name job
&gt; parameter is null.
&gt; ------------------------------------------------------------------------------
&gt; First, since Properties can&apos;t hold &apos;null&apos;... the &quot;infile.name job parameter is
&gt; null&quot; condition would more precisely be:  &quot;infile.name&quot; is not present as a key
&gt; in the &quot;Properties&quot; object.  
&gt; So Michael has a valid point... there&apos;s no way to unset it to &apos;null&apos; at the
&gt; moment.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12721</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-28 19:53:19 +0000</bug_when>
    <thetext>Chris,

What you suggest (remembering no parameters on restart) would be my vote.  It is actually the way we solved that issue when implementing non-identifying job parameters recently.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4726</bug_id>
          
          <creation_ts>2013-03-01 16:50:00 +0000</creation_ts>
          <short_desc>Change Metric interface enum values to conform to Java convention.</short_desc>
          <delta_ts>2013-04-09 15:19:23 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12734</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 16:50:13 +0000</bug_when>
    <thetext>From public mailing list:

 [jsr352-public] MetricName naming convention, string values (&quot;readCount&quot;, &quot;writeCount&quot;...)
Cheng Fang 
to:
public
03/01/2013 11:17 AM
Hide Details 
From: Cheng Fang &lt;cf126330@gmail.com&gt;

To: public@jbatch.java.net









Please respond to public@jbatch.java.net



Default custom expiration date: 03/01/2014
 

1, MetricName is currently defined as:

public enum MetricName {READCOUNT, WRITECOUNT, COMMITCOUNT, 
           ROLLBACKCOUNT, READSKIPCOUNT, PROCESSSKIPCOUNT, FILTERCOUNT, 
           WRITESKIPCOUNT}

Can we add underscore as word separator, to make it more readable, also stick to java naming convention?

This is an example of other enum namings in EE, which use enum names like  BAD_REQUEST:
http://docs.oracle.com/javaee/6/api/javax/ws/rs/core/Response.Status.html


2, Metric javadoc still include string values (&quot;readCount&quot;, &quot;writeCount&quot;, etc)of the expected metric name, and probably also in the spec.  Do we still need them?  If no, then we should remove them.

If we think &quot;readCount&quot; gives more readable display name than READCOUNT or READ_COUNT, then we can assign it to the enum as the custom display name:

WRITE_SKIP_COUNT(&quot;writeSkipCount&quot;);


Thanks,
Cheng</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12735</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 16:52:50 +0000</bug_when>
    <thetext>Yes, agreed.  Those constants look terrible.  Also the getName() method doesn&apos;t make any sense.  Here is the updated interface definition:

package javax.batch.runtime;
/**
  * 
  * The Metric interface defines job metrics recorded by
  * the batch runtime.
  *
  */
public interface Metric {
	public enum MetricType {READ_COUNT, WRITE_COUNT, COMMIT_COUNT, 
	       ROLLBACK_COUNT, READ_SKIP_COUNT, PROCESS_SKIP_COUNT, FILTER_COUNT, 
	       WRITE_SKIPCOUNT}
	/**
	 * The getName method returns the metric type. 
	 * @return metric type.
	 */
	public MetricType getType(); 
	/**
	 * The getValue method returns the metric value.
	 * @return metric value.
	 */
	public long getValue();
}

Update will appear in PFD v1.5.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13164</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-04-08 20:02:14 +0000</bug_when>
    <thetext>Just noticed WRITE_SKIPCOUNT is missing a separator between SKIP and COUNT, which makes it different from others (READ_SKIP_COUNT, PROCESS_SKIP_COUNT, etc).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13169</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-04-09 15:19:23 +0000</bug_when>
    <thetext>Will go ahead and fix this in the RI/TCK today. So I&apos;m assuming Chris will get to it in the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4740</bug_id>
          
          <creation_ts>2013-03-08 20:37:00 +0000</creation_ts>
          <short_desc>SPEC - Clarity around checkpoint configuration verbiage</short_desc>
          <delta_ts>2013-03-11 15:56:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12764</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:37:55 +0000</bug_when>
    <thetext>At the end of section 7.9, there is a sentence: &quot;Ideally, this should be adjustable operationally and not explicitly controlled by the batch application itself.&quot;  However, since the checkpoint interval is required to be configured in some way within the batch application (by specifying the algorithm at least...potentially more), this is confusing.  I&apos;d recommend removing that sentence.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12808</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:56:48 +0000</bug_when>
    <thetext>Agreed it is unnecessary in the specification.  PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4741</bug_id>
          
          <creation_ts>2013-03-08 20:40:00 +0000</creation_ts>
          <short_desc>SPEC - merge attribute sometime on lists and sometimes on element of lists</short_desc>
          <delta_ts>2013-03-13 00:28:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12765</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:40:00 +0000</bug_when>
    <thetext>Within the spec, most places the merge attribute is specified on the list element (listeners for example).  Yet for some attributes like properties, it is on the element of the list.  I would expect us to be consistent in how list merging occurs and have it always at the list level.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12798</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:41:49 +0000</bug_when>
    <thetext>I think the editor was up too late that night :)   It&apos;s supposed to be on &lt;properties&gt; not &lt;property&gt;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12799</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:42:14 +0000</bug_when>
    <thetext>Fixed in PFD v1.6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12874</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-13 00:28:21 +0000</bug_when>
    <thetext>Not fixed in v1.6.  Inheritance is being moved out of JSR 352 v1.0.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4742</bug_id>
          
          <creation_ts>2013-03-08 20:41:00 +0000</creation_ts>
          <short_desc>SPEC - next attribute is not always optional on a step element</short_desc>
          <delta_ts>2013-03-11 14:50:18 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12766</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:41:31 +0000</bug_when>
    <thetext>The next attribute should not be considered optional unless other transitions have been specified (this is not pointed out in 8.2) via their child elements.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12802</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:50:18 +0000</bug_when>
    <thetext>A step is not required to have a transition to another step. Such a step is a final step.  Therefore both the next attribute and the next element are always optional.  Same principle applies to flow, split, and decision.  I agree decision as the final execution element makes little sense.  But we have no reason to prevent it.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4743</bug_id>
          
          <creation_ts>2013-03-08 20:45:00 +0000</creation_ts>
          <short_desc>SPEC - Refer to where the checkpoint-algorithm is defined</short_desc>
          <delta_ts>2013-03-16 21:17:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12767</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:45:39 +0000</bug_when>
    <thetext>In many areas of the spec, if something being discussed is later in the spec a note of where to find that is made (for example, in 8.2.1 there&apos;s a note to see section 9.7 about transactionality).  Can we have a similar note put in the table in section 8.2.1 pointing the reader to where the checkpoint-algorithm is defined?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12926</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:17:00 +0000</bug_when>
    <thetext>Added in PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4744</bug_id>
          
          <creation_ts>2013-03-08 20:47:00 +0000</creation_ts>
          <short_desc>SPEC - time-limit needs a unit of measure</short_desc>
          <delta_ts>2013-03-20 03:07:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12768</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:47:16 +0000</bug_when>
    <thetext>Within the chunk element, the time-limit needs to define the unit of time it&apos;s measuring.  I would recommend milliseconds to be consistent with the rest of the way Java measures time.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12803</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:16:17 +0000</bug_when>
    <thetext>I agree it needs to be specified.  And I recognize the Java precedent of milliseconds.  But do you really believe conforming to precedent is the right thing here?  Batch times are usually seconds if not minutes.  E.g.

E.g. a 3 minute chunk limit is 180000.

Using milliseconds will make the JSL less readable IMO.   That would be fine if times less than a second where necessary.  Such small times are typical for OLTP but not batch. 

I think seconds as the unit of measure makes more sense.  Opinions?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12811</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-11 16:30:06 +0000</bug_when>
    <thetext>I think Michael&apos;s comment implies we need to add a new attribute, like time-limit-unit, and these 2 together can accurately define the time limit.  We can default time-limit-unit to a common value such as minutes or seconds, while allowing use of other units like millis, nanos, or days.  For example, ejb 3.1 stateful-timeout uses this structure with minutes as default unit:

http://java.sun.com/xml/ns/javaee/ejb-jar_3_1.xsd</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12841</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 03:07:01 +0000</bug_when>
    <thetext>I don&apos;t think we should make a change given the lateness of the date.    There are other ways to achieve &quot;quick checkpointing&quot; (custom or item-based), and I think we should prioritize this low.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12891</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-14 18:13:10 +0000</bug_when>
    <thetext>At the least, we do need a unit of measure specified in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12987</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:07:52 +0000</bug_when>
    <thetext>It will have to come in a future revision.  Anyone that needs to checkpoint more frequently than 1 second can do so with a checkpoint algorithm artifact.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4745</bug_id>
          
          <creation_ts>2013-03-08 20:49:00 +0000</creation_ts>
          <short_desc>SPEC - merge default</short_desc>
          <delta_ts>2013-03-13 00:29:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12769</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 20:49:08 +0000</bug_when>
    <thetext>The spec defines the default for the merge attribute as true.  Wouldn&apos;t it be safer to be defaulted to false (not merging the two lists together)?  For the record, that is the default with SB.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12791</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:08:19 +0000</bug_when>
    <thetext>I picked true arbitrarily. False is safer.  I will update to false in PFD v1.6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12875</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-13 00:29:44 +0000</bug_when>
    <thetext>Not fixed in PFD v1.6.  Inheritance is being moved out of JSR 352 v1.0.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4746</bug_id>
          
          <creation_ts>2013-03-08 21:11:00 +0000</creation_ts>
          <short_desc>SPEC - Verbiage about when artifacts are created is still present</short_desc>
          <delta_ts>2013-03-11 14:14:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12770</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 21:11:46 +0000</bug_when>
    <thetext>In section 8.2.4, the spec states: &quot;The lifecycle of a step level listener is the lifecycle of the step to which the listener is defined. The
listener is created at the start of the step and is deleted at the end of the step.&quot;  Per previous discussions in Bug 4714, this verbiage about when objects are created/destroyed should be removed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12792</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:14:15 +0000</bug_when>
    <thetext>Thanks for pointing it out.  Same thing applies to section 8.1.1.  I will remove those statements.  Regarding artifact lifecycle, the spec is supposed to address that only in section 11.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4747</bug_id>
          
          <creation_ts>2013-03-08 22:04:00 +0000</creation_ts>
          <short_desc>SPEC - Verbiage about partition reducer is confusing</short_desc>
          <delta_ts>2013-03-08 22:23:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12771</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:04:41 +0000</bug_when>
    <thetext>Section 8.2.6.4 states: &quot;Programmatic interception of the partition reducer lifecycle is possible by providing a partition reducer.&quot;  What does this actually mean?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12773</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-08 22:15:43 +0000</bug_when>
    <thetext>It means we have an infinite loop in the spec :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12774</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-08 22:23:12 +0000</bug_when>
    <thetext>Thanks for catching that, Michael.  It should have said:

&quot;Programmatic interception of the partitioned step&apos;s lifecycle is possible through the partition reducer.&quot;

I rewrote the entire paragraph to say: 

&quot;A partitioned step may execute with an optional partition reducer.  A partition reducer provides a kind of unit of work demarcation around the processing of the partitions.  Programmatic interception of the partitioned step&apos;s lifecycle is possible through the partition reducer. The reducer element specifies a reference to a PartitionReducer batch artifact;  see section 9.5.2 for further information.&quot;

This change will appear in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4748</bug_id>
          
          <creation_ts>2013-03-08 22:15:00 +0000</creation_ts>
          <short_desc>SPEC - Partition Collector</short_desc>
          <delta_ts>2013-03-11 21:00:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12772</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:15:30 +0000</bug_when>
    <thetext>In section 8.2.6.5:
1.  Why is the collector called once at the end of the step as well as once at the end of each chunk?  What is the purpose of the extra call at the end of the step?
2.  My assumption is that a partitioned Batchlet executes each partition within it&apos;s own thread/transaction.  If that is correct, why would the partition collector only be called once at the end of the step for a batchlet and not once per transaction commit like with chunk processing?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12797</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:33:40 +0000</bug_when>
    <thetext>It&apos;s a typo. Glad you caught it.  It&apos;s supposed to say end of partition - not end of step.  Updated in PFD v1.6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12821</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:00:38 +0000</bug_when>
    <thetext>This same issue exists in the javadoc of the related interfaces as well.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4749</bug_id>
          
          <creation_ts>2013-03-08 22:41:00 +0000</creation_ts>
          <short_desc>SPEC - Decision availability</short_desc>
          <delta_ts>2013-03-20 03:18:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12775</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:41:06 +0000</bug_when>
    <thetext>In section 8.5, the spec states that a decision may follow a step, flow or split.  Is there a reason for it not to be able to follow another decision?  Also, I&apos;m assuming a decision can be the first step in a job, yet this section only discusses that it follow others.  This should be clarified.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12806</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:23:40 +0000</bug_when>
    <thetext>Yes, a decision may follow a decision or be first. While being first is pathologicical IMO,  there is no reason to disallow it.  Note the StepExecutions[] array would be empty.  But so what.  Updated in PFD v1.6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12873</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-13 00:23:58 +0000</bug_when>
    <thetext>Not updated in PFD v1.6 - probably v1.7.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12988</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:18:13 +0000</bug_when>
    <thetext>Ok, I have to retract my position on this.  After further reflection, the decider accepts StepExecutions as input, which therefore implies as a matter of contract that a step executed prior to the decision receiving control.  If a decision is the first execution element in a job or follows another decision, the notion of step is lost and the contract does not make sense.

A future revision could introduce an additional decider signature appropriate for a decider that is invoked without being preceded by a step.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4750</bug_id>
          
          <creation_ts>2013-03-08 22:43:00 +0000</creation_ts>
          <short_desc>SPEC - Incorrect statement in 8.6</short_desc>
          <delta_ts>2013-03-11 15:53:53 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12776</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:43:41 +0000</bug_when>
    <thetext>The last sentence in 8.6 states: &quot;Fail, and, and stop are considered &quot;terminating elements&quot; because they cause a job execution to terminate.&quot;  I&apos;m assuming that should read &quot;Fail, end, and stop are considered &quot;terminating elements&quot; because they cause a job execution to terminate.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12807</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:53:53 +0000</bug_when>
    <thetext>Correct.  That is a typo.  Fixed in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4751</bug_id>
          
          <creation_ts>2013-03-08 22:45:00 +0000</creation_ts>
          <short_desc>SPEC - 8.6.1 decision id should be included</short_desc>
          <delta_ts>2013-03-20 03:00:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12777</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:45:35 +0000</bug_when>
    <thetext>In the syntax section of 8.6.1, it identifies the to attribute allowing step, flow and split ids.  A decision id should also be allowed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12778</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:47:44 +0000</bug_when>
    <thetext>This issue applies for section 8.6.4 with the stop element&apos;s restart attribute as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12809</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 16:00:57 +0000</bug_when>
    <thetext>8.6.1 in PFD v1.5 already includes decision.  I need to think about restart on a decision.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12985</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:00:21 +0000</bug_when>
    <thetext>After further consideration, decision will not be supported as a restart target. The decider contract implies that preceding steps have executed. If decision is a restart target, that may or may not be true.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4752</bug_id>
          
          <creation_ts>2013-03-08 22:53:00 +0000</creation_ts>
          <short_desc>SPEC - STOPPING batch status is defined incorrectly</short_desc>
          <delta_ts>2013-03-11 14:46:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12779</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 22:53:45 +0000</bug_when>
    <thetext>Per section 8.7, the STOPPING batch status indicates: &quot;A step has a status of STOPPING as soon as stop processing has commenced by the batch runtime.&quot;.  This is incorrect.  A job should be set to the batch status of STOPPING as soon as the request to stop it has been made (aka when JobOperator.stop is called).  This does not mean that any additional work towards stopping the job has happened yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12800</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:46:02 +0000</bug_when>
    <thetext>That&apos;s what &quot;commenced&quot; is supposed to mean.  I will reword to make more clear. Updated in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4753</bug_id>
          
          <creation_ts>2013-03-08 23:03:00 +0000</creation_ts>
          <short_desc>SPEC - Missing reference in section 8.7.1</short_desc>
          <delta_ts>2013-03-11 16:04:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12780</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 23:03:13 +0000</bug_when>
    <thetext>In section 8.7.1, the reference to decider documentation is broken (says &quot;(see Error! Reference source not found.)&quot;).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12810</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 16:04:05 +0000</bug_when>
    <thetext>fixed in PFD 1.6</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4754</bug_id>
          
          <creation_ts>2013-03-08 23:05:00 +0000</creation_ts>
          <short_desc>SPEC - Does not define how the ABANDONED batch status on a step works</short_desc>
          <delta_ts>2013-03-20 02:22:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12781</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 23:05:52 +0000</bug_when>
    <thetext>For a step, all of the statuses work the same as they do with a job except for ABANDONED.  When a step is marked ABANDONED but the job is not, it should be skipped on the restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12790</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:01:28 +0000</bug_when>
    <thetext>I agree the spec needs to say more.  Bottom line:   you can&apos;t restart an abandoned execution.  PFD v1.6 will state that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12906</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 22:56:16 +0000</bug_when>
    <thetext>It seems there is no way for a step to be marked as abandoned...

This confuses me.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12960</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 18:52:48 +0000</bug_when>
    <thetext>Regarding to Comment #2, I think Scott is correct.  There was an abandon method on the JobOperator in earlier versions of the spec that seems to be missing from the current version.  This needs to be re-added.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12982</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 02:22:25 +0000</bug_when>
    <thetext>I misread  this bug initially.  I thought it was only about abandoning executions.  I recall no prior discussion about abandoning steps.  JSR 352 v1.0 will support abandoning executions.  Abandoning steps will have to come in a future spec enhancement.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4755</bug_id>
          
          <creation_ts>2013-03-08 23:14:00 +0000</creation_ts>
          <short_desc>SPEC - Exit Status for Partitioned Steps is incorrect</short_desc>
          <delta_ts>2013-03-20 14:02:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12782</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 23:14:32 +0000</bug_when>
    <thetext>In section 8.7.2, the spec states that the default behavior for determining which exit status to use is to use the one provided by the last executing partition (the one that finishes last).  This is incorrect.  If I have a partition that fails quickly and others that complete and take longer, per the spec the step would be flagged as complete.  

I would recommend that the exit status of the worst case be taken out of the bunch in order of the following precedence: Abandon, Fail, Stop, Complete.  This would allow a partitioned step to be flagged as complete only if all of the partitions were completed successfully.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12789</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 13:44:02 +0000</bug_when>
    <thetext>Yes, this section is not right - it contradicts itself because earlier it indicates that a failed or stopped partition will result in batch status of failed or stopped.  The bottom line is if the chunk or batchlet artifacts try to set exit status,  the resultant exit status is not predictable.  I think exit status for a partitioned step must handled by an artifact that runs outside the partitions themselves.  The PartitionAnalyzer is designed for this purpose.  So I think what we need to say, in essence is:

1. the result of individual partitions establishes batch status as follows:
1.1 if all partitions end in completed state, batch status is completed.
1.2 if any partition ends with in failed state, batch status is failed.
1.3 if any partition ends with in stopped state, batch status is stopped.

2. exit state for partitioned step defaults batch status UNLESS exit status is set by PartitionAnalyzer.

This is going into PFD v1.6.  Please reopen this bug if you disagree with the approach.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12872</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-13 00:22:49 +0000</bug_when>
    <thetext>Correction:  not going into v1.6 - probably v1.7.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12996</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 14:02:15 +0000</bug_when>
    <thetext>*** Bug 4784 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4756</bug_id>
          
          <creation_ts>2013-03-08 23:28:00 +0000</creation_ts>
          <short_desc>SPEC - Property misspelling.</short_desc>
          <delta_ts>2013-03-11 15:19:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12783</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 23:28:15 +0000</bug_when>
    <thetext>In section 8.8.1, the first sentence of the second paragraph has the misspelling &quot;prohperty&quot;.  I believe it should be property.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12805</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 15:19:05 +0000</bug_when>
    <thetext>thanks.  update in PFD 1.6</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4757</bug_id>
          
          <creation_ts>2013-03-08 23:59:00 +0000</creation_ts>
          <short_desc>SPEC - jobProperties Substitution Operator clarification</short_desc>
          <delta_ts>2013-03-11 14:21:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12784</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-08 23:59:35 +0000</bug_when>
    <thetext>Section 8.8.1.2 discusses the jobProperties substitution operator.  In the example provided, it is not clear where the value of the &quot;#jobProperties{&apos;filestem&apos;}.txt&quot; actually comes from.  This should be reworked to be more clear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12793</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:21:06 +0000</bug_when>
    <thetext>I finished the example to make explicit where the value for #{jobProperties[&apos;filestem&apos;]} came from. Updated in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4759</bug_id>
          
          <creation_ts>2013-03-09 19:00:00 +0000</creation_ts>
          <short_desc>What does StepExecution.getStepContainment() return for direct children of job</short_desc>
          <delta_ts>2013-03-11 14:30:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12786</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-03-09 19:00:29 +0000</bug_when>
    <thetext>What does String[] getStepContainment();  return in the following case, null or empty array?

&lt;job id=&quot;job1&quot;&gt;
    &lt;step id=&quot;step1&quot;&gt;
    &lt;/step&gt;
&lt;/job&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12796</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 14:30:33 +0000</bug_when>
    <thetext>An empty list.  Spec updated (PFD 1.6) to say that.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4762</bug_id>
          
          <creation_ts>2013-03-11 14:21:00 +0000</creation_ts>
          <short_desc>SPEC - Property resolution</short_desc>
          <delta_ts>2013-03-16 21:07:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12794</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 14:21:58 +0000</bug_when>
    <thetext>Section 8.8.1.6 states that &quot;A property is considered defined once it is encountered by a top to bottom parse of the XML document.&quot;  I would expect to be able to resolve properties in any order in an XML document.  Since the document is not execution based (like the need to define a variable before we use it) with regards to properties I don&apos;t understand this limitation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12922</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:07:13 +0000</bug_when>
    <thetext>The document is not executable, true.  It is similar to Ant in that it directs an execution sequence.  And while I agree in principle there is no express purpose to require a property to be defined before it is used in substitution, we borrowed from the Ant model in the spec and in the RI with regard to this behavior. This is a rational way to prevent cycles.  I do not believe there is any important use case precluded by this choice.  Nor do I think usability or readability of the JSL is unduly compromised.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4763</bug_id>
          
          <creation_ts>2013-03-11 14:30:00 +0000</creation_ts>
          <short_desc>SPEC - Parameter substitution syntax</short_desc>
          <delta_ts>2013-03-13 00:04:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12795</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 14:30:11 +0000</bug_when>
    <thetext>In section 8.8.2 of the spec, the example that shows the default value has a semicolon at the end.  Can we drop that?  It seems pointless and actually implies that there is some form of evaluation of that statement (which would be a security risk).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12871</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-13 00:04:15 +0000</bug_when>
    <thetext>There is no evaluation.  

You need a semi-colon (terminator) in order to allow use of more than one property substitution with defaulting in an attribute expression, such as to construct a file name, and also to be able to concatenate string literals to the end of a defaulted property. You need a way to know that you have reached the end of the defaulting string.


Here&apos;s one example:

infile.name=&quot;myfile&quot;
default.file.name =&quot;defaultfile&quot;


&lt;property name=&quot;log.file.name&quot; value=&quot;#{jobParameters[&apos;unresolving.prop&apos;]}?:#{systemProperties[&apos;file.separator&apos;]};logdir #{systemProperties[&apos;file.separator&apos;]} #{jobParameters[&apos;infile.name&apos;]}?:#{systemProperties[&apos;default.file.name&apos;]};.log&quot; /&gt; 


This property will be able to resolve to something like  &quot;/logdir/myfile.log&quot;  or  &quot;/logdir/defaultfile.log&quot;  


Without the semi-colon you can only have one defaulting property and all literals and non-defaulting must placed before the defaulting property: 


infile.name=&quot;myfile&quot;
default.file.name =&quot;defaultfile&quot;


#{systemProperties[&apos;file.separator&apos;]} #{jobParameters[&apos;infile.name&apos;]}?:#{systemProperties[&apos;file.name.junit&apos;]}.log   &lt;---- no use of semi-colon
1) if infile.name resolves we get -----&gt; &quot;/myfile&quot;
2) if infile.name doesn&apos;t resolve we get ------&gt; /myfile.log 


So we lose the &quot;.log&quot; in the non-defaulting case because  you don&apos;t know where the end of the defaulting string is so you can&apos;t concatenate  anything after it.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4764</bug_id>
          
          <creation_ts>2013-03-11 14:46:00 +0000</creation_ts>
          <short_desc>SPEC - ItemReader Javadoc Issues</short_desc>
          <delta_ts>2013-03-20 02:34:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12801</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 14:46:36 +0000</bug_when>
    <thetext>1.  The class level javadoc states that this is a batch artifact that &quot;reads from a stream of items&quot;.  Given that java already has the concept of streams and that concept is not applicable here, we may want to choose another way to describe this.  I would say that we just want to state that this is a batch artifact that is responsible for providing input for a chunk based step.
2.  The javadoc for the open is to use case specific.  The open method is not about repositioning the reader as much as it is about resetting the state of the reader, whatever that may mean for the given implementation.  Also, in SB, we always pass in an ExecutionContext (the Serializable here) regardless of if it&apos;s a start or restart so we would advocate that the Serializable always be passed in and leave it to the implementation to determine what to do with that based on start vs restart.
3.  As with the class level javadoc, the readItem implies a java stream concept here that is not 100% accurate.
4.  checkpointInfo states that it returns the current position of the reader.  In fact, this should return whatever state is required to be persisted (regardless if it&apos;s position based or not).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12916</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 20:43:14 +0000</bug_when>
    <thetext>I will incorporate all comments except the one about passing an empty Serializable.  This value is user-defined, not spec defined, so empty is simply null. Update coming in PFD v1.7</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12951</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 16:39:01 +0000</bug_when>
    <thetext>Chris,

The reason I bring up the open is because I&apos;d like to still pass in the ExecutionContext that Spring Batch currently uses as that serializable.  Correct me if I&apos;m wrong but the spec does not require that it be user generated, only that it be serializable?  If that&apos;s the case, we would still be able to support the existing Spring Batch ItemStream style contracts with the new JSR interfaces.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12955</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 17:01:22 +0000</bug_when>
    <thetext>Michael&apos;s interpretation is news to me...

So in this view, there&apos;s no contract between container and app that the value returned by checkpointInfo() is the one passed to open() on restart.

I&apos;d hope the TCK would fail such an implementation... as our intentions reflected an understanding that the instance returned by checkpointInfo() would be passed to open()  (I mean a deserialized equivalent of course).

That seems radically different than our current understanding.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12956</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 17:13:52 +0000</bug_when>
    <thetext>After further thinking, that won&apos;t work because close and checkpointInfo do not accept a serializable so there is no way for that to work...We&apos;ll have to handle this internally.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12983</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 02:34:49 +0000</bug_when>
    <thetext>Michael, I see what you mean now.  The SB and JSR container/application contract governing checkpoint behavior are simply different.  

The JSR uses the concept of a checkpoint token that originates in the reader and is persisted through the container and then returned to the reader upon restart - the read essentially owns the object the container is merely the steward.

SB in comparison, uses a persistent workarea that is owned an managed by the container, but exposed to the reader to store and retrieve values across start/restart.

Both models are valid.  They achieve the same ends.  Their orientation is different. 

At this point in the schedule, we will have to go with the model in the JSR. I will still update the javadoc to avoid the stream confusion.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4765</bug_id>
          
          <creation_ts>2013-03-11 18:42:00 +0000</creation_ts>
          <short_desc>SPEC - ItemProcessor documentation issue</short_desc>
          <delta_ts>2013-03-20 02:45:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12813</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 18:42:56 +0000</bug_when>
    <thetext>In section 9.1.1.2 the opening paragraph seems to have been copied over from the ItemReader and is incorrect (it talks about reading a stream and says that the other artifacts in a chunk are an ItemProcessor and an ItemWriter).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12917</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 20:44:30 +0000</bug_when>
    <thetext>Copy/paste error.  Will fix in PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4766</bug_id>
          
          <creation_ts>2013-03-11 18:46:00 +0000</creation_ts>
          <short_desc>SPEC - ItemWriter javadoc issues</short_desc>
          <delta_ts>2013-03-20 02:46:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12814</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 18:46:42 +0000</bug_when>
    <thetext>Similar to BUG 4764, the ItemWriter refers to what it writes to as a stream which may be confusing given what most java streams actually mean.  The same issues with the open and checkpointInfo javadoc also exist where the javadoc discusses the repositioning of the writer instead of re-establishing the state.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12918</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 20:45:10 +0000</bug_when>
    <thetext>Will address same as bug 4764.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12984</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 02:46:45 +0000</bug_when>
    <thetext>The stream oriented language will be fixed in the spec and javadoc now (PFD 1.7). Changing the writer/container contract will stay as is.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4767</bug_id>
          
          <creation_ts>2013-03-11 19:11:00 +0000</creation_ts>
          <short_desc>SPEC - Checkpoint Algorithm interface issues</short_desc>
          <delta_ts>2013-03-11 19:55:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12815</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 19:11:58 +0000</bug_when>
    <thetext>1.  the checkpointTimeout returns an int currently.  If we end up supporting in any way milliseconds, I&apos;d assume that this would change to a long.
2.  Why does the checkpointTimeout method exist at all?  I would expect all state required to manage the checkpoint to be maintained within the implementation of the CheckpointAlgorithm implementation (so beginCheckpoint takes the current timestamp and isReadyToCheckpoint checks against that.  There is no need to expose that timeout value).
3.  What does the endCheckpoint() method bring to the table? In SB, we have essentially three methods in our CompletionPolicy: isComplete (isReadyToCheckpoint), start (beginCheckpoint), and update (no equivalent).  The update is called once per item so that the state of the implementation can be updated.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12819</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 19:55:36 +0000</bug_when>
    <thetext>1) int checkpointTimeout()

int max value is 2**31-1/1000millis/60sec/60/min/24hr ~ 24 days.  That&apos;s a long time for a single checkpoint.  If it were critical to change the return type and code was not written, time short, I&apos;d be happy to change.  However, given where we are, I think nothing substantive is at risk by retaining the current return type.

2) what checkpointTimeout() for anyway?  

The purpose is to provide a flexible means for establishing the checkpoint time - e.g autonomic.  The runtime uses it to set the UserTransaction timeout.  


3) what is endCheckpoint for?   

beginCheckpoint/endCheckpoint are essentially beforeCompletion/afterCompletion for the checkpoint transaction.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4768</bug_id>
          
          <creation_ts>2013-03-11 19:46:00 +0000</creation_ts>
          <short_desc>SPEC - Batchlet.stop clarification</short_desc>
          <delta_ts>2013-03-20 03:30:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12816</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 19:46:59 +0000</bug_when>
    <thetext>Is the Batchlet.stop() intended to be called as part of the JobOperator.stop()?  And if so, is it blocking (in otherwords, if I call JobOperator.stop() on a job that is currently running a long running Batchlet, will the JobOperator.stop return before the Batchlet actually stops?)?  

Along those lines, on a partitioned batchlet, what is the rule on how many times the stop method is called?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12825</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-11 21:15:55 +0000</bug_when>
    <thetext>We have in the JobOperator.stop() Javadoc:

The job execution normally stops and does so asynchronously.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12847</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 15:44:57 +0000</bug_when>
    <thetext>For partitions, stop is called on each active partition.  I will say so explicitly in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12990</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:30:44 +0000</bug_when>
    <thetext>In PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4770</bug_id>
          
          <creation_ts>2013-03-11 19:54:00 +0000</creation_ts>
          <short_desc>SPEC - ChunkListener.onError clarification</short_desc>
          <delta_ts>2013-03-20 03:51:46 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12818</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 19:54:07 +0000</bug_when>
    <thetext>Why is the exception that caused the error not passed to ChunkListener.onError?  How does that method obtain the information about what caused the error?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12849</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 16:04:56 +0000</bug_when>
    <thetext>Yeah, that looks like an oversight.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12993</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:51:46 +0000</bug_when>
    <thetext>Fixed in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4772</bug_id>
          
          <creation_ts>2013-03-11 21:07:00 +0000</creation_ts>
          <short_desc>SPEC - Grammer in Batch Artifact Loading</short_desc>
          <delta_ts>2013-03-16 20:50:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12822</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:07:57 +0000</bug_when>
    <thetext>In section 10.5 bullet point 2, it states: &quot;The implementation must provide an archive loader resolves the reference by looking up the reference in a batch.xml file&quot;.  I&apos;m assuming that it should say &quot;The implementation must provide an archive loader that resolves the reference by looking up the reference in a batch.xml file&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12919</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 20:50:14 +0000</bug_when>
    <thetext>Will be corrected in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4773</bug_id>
          
          <creation_ts>2013-03-11 21:09:00 +0000</creation_ts>
          <short_desc>SPEC - Thread Context Class Loader should be bullet 3</short_desc>
          <delta_ts>2013-03-12 18:59:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12823</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:09:53 +0000</bug_when>
    <thetext>In section 10.5, shouldn&apos;t the Thread Context Class Loader section be bullet point 3?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12868</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 18:59:51 +0000</bug_when>
    <thetext>Yes, indeed.  Fixed in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4774</bug_id>
          
          <creation_ts>2013-03-11 21:14:00 +0000</creation_ts>
          <short_desc>SPEC - batch.xml schema</short_desc>
          <delta_ts>2013-03-12 16:05:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12824</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:14:23 +0000</bug_when>
    <thetext>While the structure of the batch.xml is trivial, implementers of the spec still should have a standard XSD to validate a batch.xml against programatically.  This XSD should be provided as part of the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12833</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-11 22:15:17 +0000</bug_when>
    <thetext>This is in the PFD 1.5 ..Sec. 12</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4775</bug_id>
          
          <creation_ts>2013-03-11 21:18:00 +0000</creation_ts>
          <short_desc>SPEC - 10.8 is incomplete</short_desc>
          <delta_ts>2013-03-20 19:16:34 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12826</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:18:52 +0000</bug_when>
    <thetext>Section 10.8 of the spec is incomplete.  The full text of the section currently reads:

All parameters must be specified on each restart.
Deciders always execute on restart. 
Explain substitution handling. 
Explain partition restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12862</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 17:53:00 +0000</bug_when>
    <thetext>Agreed - I posted v1.5 with a note on the wiki that said that section was incomplete.  It will be updated for v1.6.  I am trying to wrap up 1.6 for publishing tonight (thought it would be last night, but I couldn&apos;t make it)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13014</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 19:16:34 +0000</bug_when>
    <thetext>Section 10.8 has been completed in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4776</bug_id>
          
          <creation_ts>2013-03-11 21:25:00 +0000</creation_ts>
          <short_desc>SPEC - TransientUserData should be a key/value pair.</short_desc>
          <delta_ts>2014-02-25 03:43:08 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12827</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:25:01 +0000</bug_when>
    <thetext>I was under the understanding that the transient user data was going to be updated to be a key/value pair.  Requiring a single unnamed object seems vague at best.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12829</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:30:29 +0000</bug_when>
    <thetext>The same goes for the PersistentUserData</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12836</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-12 02:02:28 +0000</bug_when>
    <thetext>+1.  I would again suggest we remvoe all the type parameters &lt;T&gt;, &lt;T, P extends Serialiable&gt; from JobContext and StepContext.  user data is not an integral part of a context so IMO we shouldn&apos;t include user data information into a context&apos;s identity.  Having these type parameters also clutters the api for developers and implementers alike.  

Users should be able to save different types of data in a context, so restricting to 1 type of data is not helpful.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12844</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 03:23:14 +0000</bug_when>
    <thetext>The single object could be a map, or it could be a single object.   Doesn&apos;t that satisfy this concern?  

The generic gets you a small extra in compile-time checking and saves a cast (though as it&apos;s currently holding up Glassfish integration due to a Weld bug I wouldn&apos;t argue too strongly against changing).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12850</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 16:07:03 +0000</bug_when>
    <thetext>Serializable gives the user more latitude.  You can always adopt a convention of HashMap&lt;String,String&gt; if you want key/value.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12893</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-14 21:54:32 +0000</bug_when>
    <thetext>Alright, I concede the existing interfaces are little awkward to use as it pertains to transient and persistent user data types. Parameterized types force the developer to always choose types when dealing with JobContext, StepContext, and StepExecution.  It&apos;s flexible and allows for strong typing, but it imposes a lot on the developer. 

Map&lt;Object,Object&gt; among other things has been suggested previously.  If we&apos;re going to do something like that, I suggest we impose a little more structure by defining a String keyed approach that allows any object for transient, but enforces Serializable for persistent, as follows: 

Map&lt;String,Object&gt; for transient data

and 

Map&lt;String,Serializable&gt; for persistent data


No promises, because it&apos;s getting late for changes; but this might be one that needs to be made to make the API set consumable.  

Please comment.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12894</commentid>
    <comment_count>6</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-15 01:38:40 +0000</bug_when>
    <thetext>Sounds good. For flexibility, we could use

Map&lt;String, ?&gt; for transient data

and 

Map&lt;String, ? extends Serializable&gt; for persistent data, 

so user can pass in Map&lt;String, String&gt;, or Map&lt;String, Number&gt; in as transient data, and Map&lt;String, String&gt; in as persistent data.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12895</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 03:17:07 +0000</bug_when>
    <thetext>I&apos;m not following the arguments... one angle seems to say using generics makes the API awkward.. but each of the proposals involves generics in some form.

Another angle seems to be that &quot;context&quot; = Map... and anything else makes the API surprising... I can appreciate that too much freedom could make the API look unwieldy at first when getting started.

But this isn&apos;t &quot;just a refactoring&quot; and it isn&apos;t strikingly better than the status quo.. it seems too late to change at this point.  

It is a bit of a pain for the implementor to &quot;do it right&quot; and make all the warnings go away ... you&apos;ll see we haven&apos;t in the RI.

But the end user could do something like:

  private StepContext&lt;Object, HashMap&lt;Object, Serializable&gt;&gt; stepCtx = null;

which doesn&apos;t seem too bad or any worse than the other suggestions.

Note that&apos;s HashMap, not Map which isn&apos;t Serializable.   That also raises another question.. depending on whether MyMapType is or isn&apos;t Serializable, should we spec whether we do or don&apos;t serialize the whole MyMapType object 
or just the entries ?   I don&apos;t think we have time for even that questionn.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12946</commentid>
    <comment_count>8</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 16:29:22 +0000</bug_when>
    <thetext>I believe I asked the question previously on what the generic type on the contexts themselves was.  That didn&apos;t make sense to me.  I&apos;d rather see the following:

StepContext#getPersistentUserData(String key)
StepContext#setPersistentUserData(String key, Object value)
StepContext#getTransientUserData(String key)
StepContext#setTransientUserData(String key, Object value)

and the same for the JobContexts.  This remove the confusing typing at the class level and makes the API much more straight forward IMHO.

With regards to the serializable aspect, I&apos;d be open to having the PersistentUserData require the value be Serializable as well...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12950</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 16:34:29 +0000</bug_when>
    <thetext>Seems late for just a programming style preference adjustment..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12992</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:44:09 +0000</bug_when>
    <thetext>Yes, we need to keep the existing interfaces.  They do at least provide the developer with considerable latitude.  Specifying JobContext&lt;HashMap&lt;String,String&gt;&gt; is an example of an easy convention for a key-based  transient data.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15219</commentid>
    <comment_count>11</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-02-25 03:43:08 +0000</bug_when>
    <thetext>Can we revisit this in 1.1?  I think this is a very important part that we can improve to define a structure so various parts of the application can pass multiple values around without conflict.

It&apos;s true that application can stick to a convention to use Map&lt;String, ?&gt; as the container for multiple transient context data, but a convention is not a contract. When a batch application consists of components from various source, there is no good way to convey and enforce this convention.

For example, some spec implementations provide ready-to-use ItemReader and ItemWriter artifacts. There is the need to pass certain context data and processing instructions from reader to writer, but I can&apos;t reliably use step userTransientData because it may overwrite any existing data, and it may also be overwritten by ItemProcessor, and as a result the writer may never get the data from reader.

One option to support key-value pair while keeping backward compatible is to overload current methods, providing more api choices to users.  There are valid use cases for both single-valued and multi-valued user data.

//new method
void addTransientUserData(String key, Object data);

//overload current method to take a key param
Object getTransientUserData(String key);

The same applies for persistentUserData, and the same applies for both StepContext and JobContext.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4777</bug_id>
          
          <creation_ts>2013-03-11 21:28:00 +0000</creation_ts>
          <short_desc>SPEC - Ability to retrieve JobExecution straight from the JobContext</short_desc>
          <delta_ts>2013-03-16 21:09:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12828</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:28:37 +0000</bug_when>
    <thetext>It would be nice to have a bit of a hierarchy within the contexts to allow easier access (than having to go back to the JobOperator for everything).  For example, it would be nice to be able to get the JobExecution from the JobContext and get the JobInstance from the JobExecution.  A similar line of hierarchy would also be nice from the StepContext.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12923</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:09:41 +0000</bug_when>
    <thetext>This is a reasonable suggestion, although I will point out there is little in the executions that is not available in the contexts. So the use case for easy access from context to execution is probably not that strong.  It&apos;s late for this kind of enhancement, so I think we need to consider it for a future spec revision.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4778</bug_id>
          
          <creation_ts>2013-03-11 21:35:00 +0000</creation_ts>
          <short_desc>SPEC - Pull out BatchStatus from the JobOperator interface</short_desc>
          <delta_ts>2013-03-20 02:01:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12830</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 21:35:25 +0000</bug_when>
    <thetext>There is no direct coupling between the JobOperator and the BatchStatus so from a design perspective, there isn&apos;t a good reason to implement the BatchStatus as an inner enum on the JobOperator interface.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12924</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:10:32 +0000</bug_when>
    <thetext>Yes, we should do this.  I need to speak with the RI team first.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12925</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 21:15:53 +0000</bug_when>
    <thetext>A straight refactor is no big deal.. this is fine.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12936</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 22:43:28 +0000</bug_when>
    <thetext>How about moving to package:
javax.batch.runtime 

Seems like the catch-all place..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12981</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 02:01:27 +0000</bug_when>
    <thetext>It will become javax.batch.runtime.BatchStatus in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4779</bug_id>
          
          <creation_ts>2013-03-11 22:02:00 +0000</creation_ts>
          <short_desc>SPEC - JobInstance id vs instance id</short_desc>
          <delta_ts>2013-03-20 03:57:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12831</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 22:02:26 +0000</bug_when>
    <thetext>Why is there a need for both an id and an instance id on the JobInstance?  There should only be one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12842</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 03:11:46 +0000</bug_when>
    <thetext>How did that get back in there?   Chris, it wasn&apos;t in the copy of JobInstance you sent to me...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12846</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 14:20:39 +0000</bug_when>
    <thetext>Easy: I screwed up.  Correct JobInstance is:

package javax.batch.runtime;

public interface JobInstance {
	/**
	 * Get unique id for this JobInstance.
	 * @return instance id
	 */
	public long getInstanceId();
	/**
	 * Get job name.
	 * @return value of &apos;id&apos; attribute from &lt;job&gt;
	 */
	public String getJobName();	
}


I am correcting the spec in PFD v1.6.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4780</bug_id>
          
          <creation_ts>2013-03-11 22:09:00 +0000</creation_ts>
          <short_desc>SPEC - The spec should not limit artifact reuse</short_desc>
          <delta_ts>2013-03-20 03:05:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12832</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 22:09:10 +0000</bug_when>
    <thetext>While the default scope for CDI is the dependent pseudo-scope (Spring&apos;s prototype scope), there should be no reason from a spec perspective to not allow the reuse of batch artifacts that are stateless.  I would propose the removal of that restriction from section 11.1.  I&apos;m fine with having all artifacts instantiated from a batch.xml be this way, but to eliminate the concept of Spring&apos;s singleton scope or CDI&apos;s other scopes without a reason behind it goes too far.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12851</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 16:11:40 +0000</bug_when>
    <thetext>If we do that, we effectively declare the batch programming model is stateless. Stateless is more difficult for developers.  We offer step and job transient data so that stateless is a developer&apos;s choice.  But why would we mandate it?  What is the value or benefit of so doing?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12853</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 16:14:38 +0000</bug_when>
    <thetext>1.  We would not be saying that the batch programming model is stateless, just that it is ok for artifacts to be stateless.  For example, there is nothing wrong with having a stateless ItemProcessor implementation that just does some validation on the item returned.
2.  I&apos;m not proposing that we mandate it, I&apos;m proposing that we don&apos;t disallow it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12858</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 17:18:09 +0000</bug_when>
    <thetext>Sounds like what Michael&apos;s saying is that we shouldn&apos;t prevent an implementation from reusing artifacts across scopes if it is smart enough to detect that the PM is stateless (through means outside of the spec).

But we still go with a stateful PM within a scope (e.g. StepListener.beforeStep+AfterStep within Step, ItemReader withinStep).

This wording is tricky to get right though...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12865</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 18:05:54 +0000</bug_when>
    <thetext>What about this: If the ref is resolved to something defined within the batch.xml through the rules stated elsewhere in the spec, a new instance is created.  Otherwise, the instance creation rules is delegated to the implementation.  This allows Spring to use standard Spring semantics, CDI to use standard CDI semantics and yet still have the fallback of the batch.xml and rules that work for those who are using neither.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12867</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 18:56:24 +0000</bug_when>
    <thetext>Michael, 

Rather than just say instance lifecycle (except for batch.xml) is an implementers decision, I&apos;d rather we give the developer something they can count on more across implementations - specially as it pertains to whether or not they safely use artifact instance variables. 

I think we can relax the spec enough to allow instance reuse. But I think artifact instance consistency within scope instance is important and that concurrent sharing across scope instances should be avoided. 

I know: what&apos;s a &quot;scope instance&quot;?  A scope instance is an invented term to facilitate this discussion, which I define as follows: a scope instance is a runtime instance of a job or step.  

So I recommend we retain these rules:

1) The same artifact instance must be used for the life of a given scope instance.
2) No artifact instance may be used concurrently by more than one scope instance.

What&apos;s removed from the rule set is the bit about an artifact instance getting reused across successive scope instances.  That would certainly allow singleton reuse.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12870</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 19:00:28 +0000</bug_when>
    <thetext>Chris,  I agree 100% on the point that we need to be clear about an instance&apos;s scope (for example, you&apos;ll get one instance for a listener over the course of the step it&apos;s executing in).  I think your updates will address my concern.  Thanks!</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12986</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:05:49 +0000</bug_when>
    <thetext>updated in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4781</bug_id>
          
          <creation_ts>2013-03-11 22:28:00 +0000</creation_ts>
          <short_desc>SPEC - JobInstance and JobExecution creation</short_desc>
          <delta_ts>2013-03-20 03:36:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12834</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 22:28:02 +0000</bug_when>
    <thetext>Section 13.1 states that if the JobXML is schema valid, a JobInstance and JobExecution will be created.  A JobInstance and JobExecution should only be created if the job is truly a valid job (both schema and semantically).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12838</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 02:22:12 +0000</bug_when>
    <thetext>I can see the virtues of Chris&apos; latest approach, though currently the RI is coded closer to Michael&apos;s.

I now think we should remove this language from the spec altogether. 

It seemed that writing &quot;prove this JSL is treated as invalid&quot; TCK tests was the driving use case for bringing up this issue (since it&apos;s a bit of a challenge to write a test with failure if you don&apos;t know it&apos;s going to fail synchronously or not)

But I move we scrap the spec statement completely and remove all &quot;invalid&quot;-style TCK tests.   (Chris, I know this was your original thought...)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12848</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 16:03:58 +0000</bug_when>
    <thetext>A couple thoughts on this:

1) I patterned this off z/OS batch, which I think has a good approach.  With z/OS batch, they take it even farther:  even non-valid JCL create the equivalent of a JobInstance/JobExecution.  Z/OS batch writes a log for every job.  If there is any kind of problem with the job, you can always debug from the joblog.  In the case of the JSR, I tightened that approach to require that the JSL be syntactically valid before creating a record in the repository.  The JSR does not address logging, but you can see how logging might certainly be tied to a JobInstance or JobExecution.  I figured declaring when the JobInstance/JobExecution is created would set the stage.

2) If we declare semantic validation is required before the JobInstance/JobExecution is created,  I think we have to define what the semantic rules are because now semantic validation enters into the programming model. I.e. semantic validation throws the same exception to the JobOperator.start/restart invoker for the same conditions across all implementations. I really wanted to avoid having to enumerate all of that in the spec, but rather leave that to implementer discretion to do at runtime. Semantic validation is natural at runtime without having to specify it all. With regard to the programming model, a job that fails runtime semantic validation is just a job in the FAILED state.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12852</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 16:12:21 +0000</bug_when>
    <thetext>@Chris
The issue I have is that if you don&apos;t have a semantically valid job, then how can you have a JobInstance at all?  That&apos;s like saying that you can generate a class file from a .java file that isn&apos;t semantically valid.  If the definition is not semantically valid, the runtime cannot attempt to execute it and therefore no JobInstance or JobExecution should be created.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12857</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 17:10:10 +0000</bug_when>
    <thetext>And why does need to be specified ?   What application code (besides the TCK) would need to be rewritten when moving to an implementation with different behavior?   It&apos;s not like you&apos;re going to programmatically put together some random steps and then rely on the runtime to tell you if it&apos;s semantically valid...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12863</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 18:02:13 +0000</bug_when>
    <thetext>While not ideal for portability, I&apos;d be open to dropping the requirement that a JobInstance and JobExecution are created prior to validating that the JSL is semantically valid.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12991</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 03:36:40 +0000</bug_when>
    <thetext>I will actually update the spec to give the implementation greater latitude. It can either:

a) do semantic validation in JobOperator.start and throw JobStartException if there is a semantic violation

or 

b) do only schema validation in JobOperator.start and delay semantic validation until job execution.  Semantic violations result in a FAILED job.  

Note a schema-valid JSL has sufficient information to create a JobInstance and JobExecution because all that is really required is a &lt;job&gt; id attribute value.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4782</bug_id>
          
          <creation_ts>2013-03-11 22:31:00 +0000</creation_ts>
          <short_desc>SPEC - Id uniqueness is incorrect</short_desc>
          <delta_ts>2013-03-20 03:13:18 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12835</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-11 22:31:58 +0000</bug_when>
    <thetext>Section 13.2 states that the id attribute must be unique within the containment scope.  Two issues with this:

1.  In order for an XML document to be valid, id must be unique within the document.  If we want to allow duplicates, we need to use something else (name perhaps).
2.  Is there a compelling reason to allow the duplication of ids at all?  I would recommend enforcing that the document be a valid XML document and that ids be unique within the document.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12843</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 03:15:19 +0000</bug_when>
    <thetext>These are not xs:id types, so we shouldn&apos;t have that restriction.  

As mentioned in other contexts, we only use xs:string since we don&apos;t have detailed rules about what values can vs. cannot be subject to property substitution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12854</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 16:16:24 +0000</bug_when>
    <thetext>In that case, is there a reason why we wouldn&apos;t want to use xs:id types?  It&apos;s more clear from a user&apos;s perspective and I don&apos;t see any issues with requiring the ids to be unique across the document...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12859</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 17:20:18 +0000</bug_when>
    <thetext>One reason is indeed this property substitution issue.   By the time we&apos;d apply the identity rule in xs:id, the XML has already been parsed... so we&apos;ve lost the most obvious chance to apply it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12861</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 17:51:37 +0000</bug_when>
    <thetext>The other reason to not require all ids be unique across a job is to avoid inheritance collisions - e.g. a job that inherits 2 flows, where each flow happens to use the same step id.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12866</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-12 18:14:08 +0000</bug_when>
    <thetext>I don&apos;t follow you with regards to Comment 3.

With regards to Comment 4, there is nothing stopping the developer from choosing a different name for each of those two steps within the same document.  For example, flow1.step1 vs flow2.step1.

I am asking this namely due to the way most developers who deal with XML view the attribute id.  If we aren&apos;t going to honor what id means in most XML documents, we should name it something else (name perhaps).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12876</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 03:55:00 +0000</bug_when>
    <thetext>Michael, I think you&apos;re right and I let this very unlikely use case of a substitutible id influence my argument.   You being OK with needing &quot;flow1.step1&quot; and &quot;flow2.step1&quot; in that case removes the final possible objection.

Talked to Chris and we&apos;re updating to xs:ID ... for PFD 1.7 I&apos;d assume...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12915</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 20:41:20 +0000</bug_when>
    <thetext>Yes, coming in PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4784</bug_id>
          
          <creation_ts>2013-03-12 02:56:00 +0000</creation_ts>
          <short_desc>SPEC - Revisit Bug 4755 - exit status default in partitioned steps</short_desc>
          <delta_ts>2013-03-20 14:02:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>DUPLICATE</resolution>
          <dup_id>4755</dup_id>
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12840</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-12 02:56:20 +0000</bug_when>
    <thetext>So the reason we introduced the &quot;last exit status wins&quot; behavior was to allow step artifacts programatically setting exit status, and developed without partitions in mind, to &quot;just work&quot; without the need for an analyzer when later used as a partitioned step.   (Presumably in this case they&apos;re all using the same &quot;SUCCESS&quot; exit status 95% of the time anyway.)

But Chris&apos; approach seems more natural ... defaulting in this way in a partitioned step without partition analyzer setting exit status seems most analogous to defaulting to batch status if exit status isn&apos;t set in a non-partitioned step.

If we absolutely have to hit the RI anyway (and I&apos;m not convinced we do since nothing we are talking about prevents someone from using an analyzer and setting the exit status explicitly), we could do:

1. the result of individual partitions establishes batch status as follows:
1.1 if all partitions end in completed state, batch status is completed.
1.2 if any partition ends with in failed state, batch status is failed.
1.3 if any partition ends with in stopped state, batch status is stopped.

2. exit state for partitioned step is set as:
  2.1) explicitly set by PartitionAnalyzer
  2.2) If batch status is completed, and all partitions set same exit status on the per-partition level (either via StepContext or batchlet process() retval), we use this value
  2.3) defaults batch status 

------------------------------------------------------------------------------

Two more concerns:

1) We lost the language saying that explicitly setting &apos;null&apos; is equivalent to &quot;default to batch status&quot; rather than &quot;I want the null value&quot;.   I think this needs specification.. currently in the RI setting &apos;null&apos; = unset = default to batch status

2) The language:

 However, if step has artifacts that explicitly set the exit status on the StepContext or through a terminating transition element, it 

I think should be:

 However, if step has artifacts that explicitly set the exit status on the StepContext or through a batchlet process() return value.

I don&apos;t see that there is anything related to transitions that runs on a partition thread, right?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12920</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:01:10 +0000</bug_when>
    <thetext>The matter of how partitioned batch and exit status will be set will be addressed by BUG 4755. 

This bug will be used to address the matter of clearly specifing how exit status defaults to batch status.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12921</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 21:04:56 +0000</bug_when>
    <thetext>I think something similar.. btw.. is still needed for splits as I recently pointed out.  Even though the split doesn&apos;t have an &quot;external&quot; status... the behavior of &quot;any containing flow stop or fail surfacing&quot; seems to be what&apos;s needed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12995</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 14:02:15 +0000</bug_when>
    <thetext>

*** This bug has been marked as a duplicate of bug 4755 ***</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4786</bug_id>
          
          <creation_ts>2013-03-12 16:40:00 +0000</creation_ts>
          <short_desc>SPEC - Sync up Partitin Plan JSL and Java Object</short_desc>
          <delta_ts>2013-03-12 16:41:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12855</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-03-12 16:40:41 +0000</bug_when>
    <thetext></thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4787</bug_id>
          
          <creation_ts>2013-03-12 16:55:00 +0000</creation_ts>
          <short_desc>SPEC - Sync up Partition Plan JSL and Java Object</short_desc>
          <delta_ts>2013-03-12 19:00:09 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12856</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-03-12 16:55:30 +0000</bug_when>
    <thetext>The interface for PartitionPlan now has a partitionsOverride parameter. I believe the JSL should reflect this parameter as an optional partitionsOverride attribute on plan. Since property substitution is allowed on any parameter we should know how to handle a change on restart in the number of partitions for a static plan, and ideally it should have the same behavior as the dynamic mapper.

Also, I believe the default value(in the runtime) for this attribute should be false, so the batch container keeps the same number of partitions on a restart and remembers previous partition results unless the JSL explicitly directs the container not to.

&lt;plan partitions=&quot;{number}&quot; threads=&quot;{number}&quot; partitionsOverride=&quot;true|false&quot;/&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12860</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-12 17:49:15 +0000</bug_when>
    <thetext>Actually, leaving it off was deliberate.  I consider it an advanced option and an application has to be specifically designed to take advantage of it. So I think it does not belong in the JSL.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12869</commentid>
    <comment_count>2</comment_count>
    <who name="">kmukher</who>
    <bug_when>2013-03-12 19:00:09 +0000</bug_when>
    <thetext>I see, so in the case of a static plan the number of partitions will always remain the same after the first execution, even if a substitution property changes the partitions attribute on restart.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4791</bug_id>
          
          <creation_ts>2013-03-13 17:50:00 +0000</creation_ts>
          <short_desc>SPEC - Should we refine the StepExecution&lt;?&gt; parameter reference ?</short_desc>
          <delta_ts>2013-03-20 16:21:11 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12879</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 17:50:30 +0000</bug_when>
    <thetext>Should this signature:

  public List&lt;StepExecution&lt;?&gt;&gt; getStepExecutions(long jobExecutionId) throws NoSuchJobExecutionException, JobSecurityException;

be:
  public List&lt;StepExecution&lt;? extends Serializable&gt;&gt; getStepExecutions</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12892</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-14 18:20:02 +0000</bug_when>
    <thetext>What is the type parameter on this for?  Why would a StepExecution have a type?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12930</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:40:31 +0000</bug_when>
    <thetext>I think we should redefine the user persistent data to be Map&lt;String,? extends Serializable&gt;, which will eliminate the need for the parameterized type in StepExecution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12934</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 22:06:26 +0000</bug_when>
    <thetext>Please see my comment on Bug 4776 about switching to a Map.   I don&apos;t see that this is so valuable to incur this extra work..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12999</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 16:21:11 +0000</bug_when>
    <thetext>The parameterized types are not helpful.  They&apos;re coming off.  In PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4792</bug_id>
          
          <creation_ts>2013-03-13 17:55:00 +0000</creation_ts>
          <short_desc>SPEC - Does @BatchProperty need its own definition</short_desc>
          <delta_ts>2013-03-20 14:03:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12880</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 17:55:23 +0000</bug_when>
    <thetext>Not claiming that @BatchProperty isn&apos;t well-specified.. but it seems to be &quot;missing&quot; the definition, with Javadoc in the spec.

Even though it&apos;s an annotation it probably should have its Javadoc in the spec to be complete.

Someone on the ML proposed it be folded into an existing package since it&apos;s the sole member of javax.batch.annotation now..

That&apos;s fine with me...I guess javax.batch.api ?  If we go that route...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12931</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:42:00 +0000</bug_when>
    <thetext>Yes, this is all reasonable.  Let&apos;s go ahead and coordinate this change.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12997</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 14:03:32 +0000</bug_when>
    <thetext>package is now javax.batch.api and javadoc is in PFD v1.7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4794</bug_id>
          
          <creation_ts>2013-03-13 18:42:00 +0000</creation_ts>
          <short_desc>TCK: add version number and root dir to tck zip</short_desc>
          <delta_ts>2013-03-19 02:35:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12882</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-13 18:42:41 +0000</bug_when>
    <thetext>It will be good to have version number in tck zip file name, jsr235-tck-1.0.zip, and add a top-level root directory to zip content.  Currently there is no such root dir:

     0 Wed Mar 13 10:30:14 EDT 2013 artifacts/
     0 Wed Mar 13 10:30:14 EDT 2013 doc/
     0 Wed Mar 13 10:30:14 EDT 2013 lib/
 10343 Wed Mar 13 10:30:14 EDT 2013 LICENSE.txt
    49 Wed Mar 13 10:30:14 EDT 2013 NOTICE.txt
...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12888</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 20:02:58 +0000</bug_when>
    <thetext>What are you suggesting be in the root directory?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12889</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-13 20:07:31 +0000</bug_when>
    <thetext>What I&apos;m suggesting is all zip content is under a root directory, for example:

tck zip content:

jsr352-tck-1.0/lib
jsr352-tck-1.0/doc
jsr352-tck-1.0/README
jsr352-tck-1.0/

Upon unzip, everything will fall under a single product directory.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12971</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-19 02:35:39 +0000</bug_when>
    <thetext>Should be in latest drop.  Release 1.0-b17</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4795</bug_id>
          
          <creation_ts>2013-03-13 18:51:00 +0000</creation_ts>
          <short_desc>RI: add version number to xml schemas</short_desc>
          <delta_ts>2013-03-19 02:36:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12883</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-13 18:51:49 +0000</bug_when>
    <thetext>./JSR352.JobXML.Model/src/main/resources/batchXML.xsd
./JSR352.JobXML.Model/src/main/resources/jobXML.xsd

The above 2 schema file names do not contain version number.  It&apos;s easier to organize with versioned names when there are multiple versions:

jobXML_1_0.xsd
batchXML_1_0.xsd
jobXML_1_1.xsd
batchXML_1_1.xsd


Also the word XML seems redundant in xml schema file names, but it&apos;s minor.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12884</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 19:58:39 +0000</bug_when>
    <thetext>OK.. will rename to:

jobXML_1_0.xsd
batchXML_1_0.xsd

I&apos;ll attach the latest since Chris doesn&apos;t have these versions in PFD 1.6.

Chris, you can resolve this bug.

I can appreciate the redundancy point... I thought about &apos;jsl.xsd&apos; and &apos;job.xsd&apos;.... but I liked jobXML better.. it is a term used in the spec after all.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12885</commentid>
    <comment_count>2</comment_count>
      <attachid>72</attachid>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 19:59:49 +0000</bug_when>
    <thetext>Created attachment 72
batch.xml XSD

Latest updates to batch.xml XSD</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12886</commentid>
    <comment_count>3</comment_count>
      <attachid>73</attachid>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 20:00:35 +0000</bug_when>
    <thetext>Created attachment 73
Latest updates to JSL XSD

Latest updates to JSL XSD</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12887</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-13 20:01:11 +0000</bug_when>
    <thetext>Notice I&apos;m throwing at you quite a few changes which have been made in the meantime...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12972</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-19 02:36:01 +0000</bug_when>
    <thetext>Should be in latest drop.  Release 1.0-b17</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>72</attachid>
            <date>2013-03-13 19:59:00 +0000</date>
            <delta_ts>2013-03-13 19:59:49 +0000</delta_ts>
            <desc>batch.xml XSD</desc>
            <filename>batchXML_1_0.xsd</filename>
            <type>application/xsd</type>
            <size>1447</size>
            <attacher>ScottKurz</attacher>
            

          </attachment>
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>73</attachid>
            <date>2013-03-13 20:00:00 +0000</date>
            <delta_ts>2013-03-13 20:00:35 +0000</delta_ts>
            <desc>Latest updates to JSL XSD</desc>
            <filename>jobXML_1_0.xsd</filename>
            <type>application/xsd</type>
            <size>16758</size>
            <attacher>ScottKurz</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>4797</bug_id>
          
          <creation_ts>2013-03-15 03:21:00 +0000</creation_ts>
          <short_desc>BatchRuntime.getJobOperator should return the same instance when called repeatedly</short_desc>
          <delta_ts>2013-03-16 21:22:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12896</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-15 03:21:21 +0000</bug_when>
    <thetext>/**
	* The getJobOperator factory method returns
	* an instance of the JobOperator interface.
	* Repeated calls to this method returns the
	* same instance.
	* @return JobOperator instance.
	*/

The current impl returns different instances.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12898</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 03:42:13 +0000</bug_when>
    <thetext>So Cheng, thanks for reminding me that I&apos;d forgotten that we violated this statement in the spec.

Let me ask, though... Chris, why do we need to specify this?  

The JobOperator spec API doesn&apos;t imply that an instance carries any state, right?   Plus there&apos;s going to be a point where the statement breaks... maybe it breaks when you&apos;re in a new classloader scope, say.   Do we need to say anything here?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12927</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:22:30 +0000</bug_when>
    <thetext>There is probably no reason for that requirement. It&apos;s an implementation decision.  I think it should be removed from the spec.  Change coming in PFD v1.7.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4799</bug_id>
          
          <creation_ts>2013-03-15 16:52:00 +0000</creation_ts>
          <short_desc>Untested functionality in TCK</short_desc>
          <delta_ts>2013-08-28 21:29:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12899</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-15 16:52:41 +0000</bug_when>
    <thetext>Since I&apos;m not an expert on the codebase, I may be missing something but I can&apos;t seem to find where the following cases are verified:

1. JobListener is a single instance over the course of the job - The closest this gets is ContextAndListenerTests#testOneArtifactIsJobAndStepListener().  However, since the state is not changed between the calls of the JobListener methods, there is no validation that it&apos;s the same instance (the runtime could have created a new instance and honored the @Ijnect for the JobContext).
2. Step&apos;s start-limit attribute - That attribute is never used in the TCK.
3. Skip/Retry limits are not validated as the reason for the job&apos;s failure.
4. no-rollback-exception-classes - Does not validate the exclude option (only include).
5. No validation of parallel processing within a partitioned step or split occurs (This could be done with placing timestamps in exit statuses and validating that they overlap from step to step).
6. Decider throwing an exception should fail the job.
7. An attempt of an abandoned job (there&apos;s only one place we validate that the job was abandoned in the TCK that I was able to find: JobOperatorTests#testAbandoned).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12905</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 21:41:32 +0000</bug_when>
    <thetext>I think we have to hold back on a TCK test on restarting abandoned executions.

This is the same deal as with semantically invalid jobs... if the spec isn&apos;t going to say whether it should be rejected upfront or get a JobExecution with batch status FAILED... then what do we do in the TCK?

My current working assumption is we just don&apos;t have any semantically invalid tests.   

The other alternative would be:  1) spec a behavior 2) figure out the set of valid behaviors.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12909</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 14:44:50 +0000</bug_when>
    <thetext>For 
 &quot;3. Skip/Retry limits are not validated as the reason for the job&apos;s failure.&quot;

How would the TCK do that?  There&apos;s no callout on the &quot;skip count exceeded&quot; condition..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12911</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-16 15:04:18 +0000</bug_when>
    <thetext>As I note in Bug 4702, this seems like a miss in the spec that we do not return why a job failed.  In Spring Batch, the ExitStatus is not just a String...it&apos;s an object that has a String that is used to determine the transitions and a message that typically holds the stack trace of an error if an error condition occurred.  That stack trace is returned and stored in the repository so that the user knows why the job failed.  This question makes me realize that we currently have no way of informing the user why the job failed and this needs to be addressed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12912</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 15:17:05 +0000</bug_when>
    <thetext>If we don&apos;t expect the JobOperator client to be able to programamticaly react to some of these errors then there&apos;s very little reason to spec it.

I don&apos;t see why a JobOperator client wants to deal with a stack trace programmatically.

If it could react in some ways then it&apos;s at least worth considering.. but you&apos;re talking about adding a whole list of failure conditions and I think it&apos;s too late for that.

This will just be part of the implementation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12913</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 15:32:17 +0000</bug_when>
    <thetext>I disagree with my idea that we can&apos;t use the TCK to test semantically invalid jobs.

As I mentioned in another bug  Chris said in a private conversation that he wanted to say that

1) an impl must fail a XSD-invalid job with JobStartException.   
2a) an impl may synchronously fail a semantically-invalid job with JobStartException   
 OR  
2b) asynchronously fail in some other manner, like producing a JobExecution with FAILED batch status.

Well.. I don&apos;t see how you do 2b) in any way except producing a JobExecution with FAILED batch status.

You have to have a JobExecution, since you&apos;ve returned from START with an execution ID.

Maybe the TCK is enforcing a bit of specific exception behavior here, but I think that&apos;s worthwhile to prevent any confusion about what we all agree are semantically invalid executions occuring. 

As one simple example, restart of a restartable=false job can now be verified by checking for either (JobRestartException) OR JobExecution, BS=FAILED.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12961</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 19:02:44 +0000</bug_when>
    <thetext>Comment # 1, I disagree that restarting an abandoned job is the same thing as starting a semantically invalid job.  In the case of an abandoned job, we have a valid job definition.  We should be able to state one way or the other what the expected results should be.  In SB&apos;s case, we perform as many checks as we can prior to the creation of a JobExecution.  If the job is not valid or if it should not be started for any reason, we do not create a JobExecution (since we never actually attempted to run the job).

With regards to Comment #4, I&apos;m not saying that the JobOperator itself would programmatically deal with a failed job (or even the client using the JobOperator).  However, we seem to have a miss in that besides a FAILED BatchStatus return, the batch runtime does not provide any further information on what went wrong.  In SB, we return a stack trace so that when a job does fail, the user has an idea of why the job got that status.  By not having that functionality, we are saying that it is ok for a job to fail with zero insight into the reason it did.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13001</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 17:35:27 +0000</bug_when>
    <thetext>#1 - abandon behavior is now specified (PFD v1.7) - attempt to restart abandoned execution results in exception.

#4 - if the job fails during the async phase of job processing, whether it is for semantic reasons or other problems (like db authentication or whatever) the runtime needs a way to communicate those errors.  I think how to expose problem determination information from the runtime is an implementation specific decision.  E.g. It might be logging.  It might be storing an exception in an &quot;extended&quot; job repository and providing a implemenation-specific API.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14030</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 21:29:07 +0000</bug_when>
    <thetext>We seem to have addressed some but maybe not all of these comments.  Doesn&apos;t seem like there&apos;s value in keeping this open so marking RESOLVED, WONTFIX</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4800</bug_id>
          
          <creation_ts>2013-03-15 17:02:00 +0000</creation_ts>
          <short_desc>Code notes from the TCK</short_desc>
          <delta_ts>2013-03-19 02:32:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12900</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-15 17:02:24 +0000</bug_when>
    <thetext>Just a couple small notes from while I was digging into the TCK:
1.  There seem to be a long list of job definitions in the TCK that are not referenced (that I can find).  Some include: job_batchlet_joblistener.xml, job_decider_next_special.xml, job_split_batchlet_4steps.xml, job_decider_end_special.xml, job_decider_fail_special.xml, job_decider_stop_special.xml.
2.  Line 64 of MyPartitionAnalyzer!!!  This seems a bit odd...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12901</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-15 17:48:06 +0000</bug_when>
    <thetext>Michael,

Thanks for pointing that out... 

First, please note in the latest TCK zip that we took a pass and removing most of the unused JSL XMLs..I think we got the ones you referred to.

(I can&apos;t remember when we last removed Java artifacts and we may have some unused ones of those lingering too)

One more note.. as you&apos;ve seen I&apos;m only getting around to updating the SE zip every so often.. Just wanted to note that the Maven binary for the TCK is updated a bit more regularly (we just dropped one an hour ago):

https://maven.java.net/content/groups/public/com/ibm/jbatch/com.ibm.jbatch-tck/

Which of course you&apos;d have to correlate back to Git to see version control change history
----

About the triple negative.. we can&apos;t find who did that :) it is odd looking.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12970</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-19 02:32:43 +0000</bug_when>
    <thetext>Should be in latest drop.  Release 1.0-b17</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4803</bug_id>
          
          <creation_ts>2013-03-16 13:53:00 +0000</creation_ts>
          <short_desc>Should we lose &lt;properties&gt; and &lt;listeners&gt; elements?</short_desc>
          <delta_ts>2013-03-16 21:43:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12908</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 13:53:57 +0000</bug_when>
    <thetext>Without inheritance, we could lose the &lt;properties&gt; and &lt;listeners&gt; elements grouping &lt;property&gt; and &lt;listener&gt; children... which makes the JSL unnecessarily verbose.

I think we can still tweak the TCK pretty easily here with a find-replace, but I think we should give Mahesh a chance to weigh in on the impact to Glassfish tests.     

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12910</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-16 14:46:51 +0000</bug_when>
    <thetext>I disagree with this.  Just because we are not supporting inheritance in this version of the spec does not mean that we will whenever the next version is addressed.  The grouping element provides an element of readabilitiy as well as minimizes the impact of the changes required to support inheritance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12932</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:43:39 +0000</bug_when>
    <thetext>I disagree, too, for same reasons as Michael.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4804</bug_id>
          
          <creation_ts>2013-03-16 19:19:00 +0000</creation_ts>
          <short_desc>Split-level flow (child of split) transitions are invalid</short_desc>
          <delta_ts>2013-03-18 17:34:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12914</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 19:19:45 +0000</bug_when>
    <thetext>I know we&apos;ve been back and forth in and out of this type of issue, (e.g. Bug 4234).

&lt;job
   &lt;split id=&quot;split1&quot;&gt;
      &lt;flow id=&quot;flow1&quot; next=&quot;step1&quot;&gt;
	&lt;step id=&quot;flow1step1&quot; next=&quot;flow1step2&quot;&gt;

The &lt;flow&gt;&apos;s @next is meaningless.   

So this raises two other questions:

1) Can the split-level flow do a stop/end/fail?   

2) Say we say &quot;flow within split cannot next..&quot; 
This raises a point we keep getting back to w.r.t. the TCK... can the TCK test for either JobStartException or BatchStatus.FAILED?   What if a runtime wanted to just ignore this?  Does that imply semantic-validation tests aren&apos;t desirable?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12929</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 21:24:28 +0000</bug_when>
    <thetext>I wouldn&apos;t mind being strict here and saying that the flow cannot have a @next attribute or any transition elements.   

An alternative of course is that any flow in a split can stop or fail the whole split through JSL.   I think we could take a stab at that since we&apos;re in this code anyway but it&apos;s likely to be undertested by the TCK.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12933</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-16 21:54:40 +0000</bug_when>
    <thetext>1. Since the spec says semantic validation is done at the discretion of the implementation, the TCK should really stay clear of semantic validation.

2. If we add this one semantic requirement to the spec - i.e. next= is not allowed on a split-flow, what rationale do we have for not specifying other semantic requirements?

3. I wanted to shy away from enumerating all possible semantic requirements, because it would significantly increase the spec and TCK without providing any real value.

4. The semantic requirements naturally fall out of the decisions an implementation must make in order to process the job, so I don&apos;t think that&apos;s too big of a problem.

5. I can see the spec is under-specified in this regard, however:  it fails to state what occurs if a JSL element specifies both the next attribute and the next element.  I think the right answer for that is:  the transitions elements take precedence;  if none of them apply, then next= (if specified) is used. If there is no transition, then it is end of job.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12935</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 22:40:25 +0000</bug_when>
    <thetext>Chris,

This isn&apos;t purely a question of whether the TCK should test for JSL we all agree &quot;shouldn&apos;t work&quot;.  

I&apos;m also raising the question &quot;can a split-level flow end/fail/stop a job&quot;?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12937</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-16 22:52:53 +0000</bug_when>
    <thetext>And the spec is NOT underspecified w.r.t. using next attribute and next as transition element.

It clearly says you cannot mix and match.. implying it&apos;s some type of error.

You&apos;re actually throwing a new behavior into the mix at the last minute...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12954</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-18 16:56:38 +0000</bug_when>
    <thetext>I forgot about the statement in PFD v1.6 section 8.2.5 Step Sequence that says:

&quot;The next attribute and next element may not be specified together in the same step.&quot;

The combination of the two is a semantic error in the JSL and can be dealt with in an implementation specific way, as per 13.1 Validation Rules. 

So you can ignore list item #5 in comment #2.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4811</bug_id>
          
          <creation_ts>2013-03-19 01:22:00 +0000</creation_ts>
          <short_desc>TCK add sig file for Java SE 6</short_desc>
          <delta_ts>2013-03-20 17:26:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12968</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-19 01:22:51 +0000</bug_when>
    <thetext>The sig file (artifacts/jsr352-api-sigtest.sig) is for Java SE 7.  Need to add sig file for Java SE 6.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13000</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-20 17:14:27 +0000</bug_when>
    <thetext>Addressed and will show up in the next update.  Thanks for raising the issue.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4812</bug_id>
          
          <creation_ts>2013-03-19 01:59:00 +0000</creation_ts>
          <short_desc>TCK automate signature test run</short_desc>
          <delta_ts>2015-09-03 13:12:37 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>suggestion</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12969</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-19 01:59:44 +0000</bug_when>
    <thetext>Currently the tck sig test requires running a separate java command, passing quite some arguments.  Can we automate the sig test run and include it as part of the regular test run, so all the testing can be done in one shot?

We could add it to build.xml as part of the run target, or add a testng test that does the signature verification.  The latter seems a better choice.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18414</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-05-22 13:47:50 +0000</bug_when>
    <thetext>For this one the automation is already in place.  The remaining task is to update the TCK doc to make users aware of this and formally point out that this is a legitimate way to run the TCK.

Will do this only in the 1.1 TCK doc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19075</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 13:12:37 +0000</bug_when>
    <thetext>Moved to: https://github.com/WASdev/standards.jsr352.tck/issues/2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4813</bug_id>
          
          <creation_ts>2013-03-19 04:48:00 +0000</creation_ts>
          <short_desc>RI: JobExecution  returned by jobOperator.getJobExecutions(jobInstance) return null jobName</short_desc>
          <delta_ts>2013-08-28 22:02:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mk111283</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12973</commentid>
    <comment_count>0</comment_count>
    <who name="">mk111283</who>
    <bug_when>2013-03-19 04:48:54 +0000</bug_when>
    <thetext>The following returns null


for (String jn : jobOperator.getJobNames()) {
  List&lt;JobInstance&gt; exe = jobOperator.getJobInstances(jn, 0, Integer.MAX_VALUE);
  if (exe != null) {
    for (JobInstance ji : exe) {
       for (JobExecution je : jobOperator.getJobExecutions(ji)) {
           je.getJobName() ===&gt; returns null
       }
    }
  }
}

However, 
   jobOperator.getJobExecution(executionId).getJobName() is not null</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12974</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-19 05:07:54 +0000</bug_when>
    <thetext>This should be fixed in today&apos;s drop (Maven 1.0-b17 version).  You can close this..</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4818</bug_id>
          
          <creation_ts>2013-03-20 20:04:00 +0000</creation_ts>
          <short_desc>TCK property jsr352.impl.runtime not sufficient</short_desc>
          <delta_ts>2013-08-28 22:04:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13015</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-20 20:04:36 +0000</bug_when>
    <thetext>jsr352.impl.runtime property may not be sufficient for tck testing.  Since we only need to get the implementation classes, I suggest changing it to batch.impl.classes, for example,

batch.impl.classes=$HOME/foo/lib/classes:$HOME/foo/lib/foo.jar:$HOME/foo/lib/batch-api.jar

The current ant run target only takes impl classes from ${jsr352.impl.runtime}/**/*.jar, but some implementation may keep classes in a directory, not jar, or may not have every jar under one single directory.

We may also want to add a property for passing testing jvm options.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13016</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-20 20:34:01 +0000</bug_when>
    <thetext>We&apos;ll try to look at this type of enhancement, though we should probably prioritize areas where our coverage of the spec needs improvement.

I must admit I&apos;m not familiar with what if any rules exist about modifying buildfiles in order to run the TCK, but I&apos;m hoping, for example, that if you needed to make such a change it will still count as an official run.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13017</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-03-21 02:33:46 +0000</bug_when>
    <thetext>w.r.t user properties, the common practice in TCKs is to keep them in a properties file so as to avoid mixing up with logics in build files.  Users should not need to touch build.xml files.  This is also how CTS handles it, and if we follow the same pattern, it makes it easier to integrate it into CTS later.

In addition to batch.impl.classes, we also need a property to pass jvm options to testng, such as -DjobOperator.sleep.time, debug options, etc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13018</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-21 04:49:30 +0000</bug_when>
    <thetext>I agree that&apos;s a better way to do it.. and actually, I think we might have a bit more time on the SE TCK, especially the automation around the TCK... so I think we can fix this.

BTW, our latest drop includes an exposure of all of our &quot;sleep times&quot; via front-end JVM system property.   

This enables someone who is failing a test because something is running &quot;too slow&quot; (or too fast) to try a different sleep value without recompile.    It seemed that to test this type of async function this was an acceptable design tradeoff.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4826</bug_id>
          
          <creation_ts>2013-03-22 13:28:00 +0000</creation_ts>
          <short_desc>SPEC - StepExecution.getUserPersistentData() vs StepContext.getPersistentUserData()</short_desc>
          <delta_ts>2013-08-28 18:40:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13028</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-22 13:28:38 +0000</bug_when>
    <thetext>Since getPersistentUserData rhymes with getTransientUserData, how about 
renaming StepExecutioni.getUserPersistentData() to 
StepExecution.getPersistentUserData()?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4827</bug_id>
          
          <creation_ts>2013-03-22 14:59:00 +0000</creation_ts>
          <short_desc>SPEC: Misspoke on collector role on exit status</short_desc>
          <delta_ts>2015-09-03 20:37:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13029</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-22 14:59:12 +0000</bug_when>
    <thetext>In Sec. 8.7.2 Exit Status for Partitioned Steps
we have:

For a partitioned batchlet, each thread processing a partition may return a separate exit status. These exit status values are ignored unless a partition collector is used to coalesce these separate exit status values into a final exit status value for the step.

---

The collector doesn&apos;t play a role here..it&apos;s the analyzer.

Should be:
These exit status values are ignored unless a partition analyzer...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14865</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 18:46:28 +0000</bug_when>
    <thetext>Small rewrite of entire paragraph to incorporate this point as well as bug 5533 (in which the effects of the transition element on step exit status were misstated).

Change from:

&lt;BEFORE&gt;

8.7.2 Exit Status for Partitioned Steps

The exit status for a partitioned step follows the same rules as for a regular step except for exit status set by batch artifacts processing individual partitions. This means the step&apos;s exit status is set by  
  1. transition elements stop, end, fail
  2. StepContext
the same as for a non-partitioned step. If the exit status is not set, it defaults to batch status, the same as for a non-partitioned step.

For a partitioned batchlet, each thread processing a partition may return a separate exit status. These exit status values are ignored unless a partition collector is used to coalesce these separate exit status values into a final exit status value for the step.

The batch runtime maintains a StepContext clone per partition. For a partitioned batchlet or chunk, any batch artifact running on any of the threads processing a partition set a separate exit status through the StepContext clone. These exit status values are ignored unless a partition collector is used to coalesce these separate exit status values into a final exit status value for the step.

&lt;/BEFORE&gt;

to:

&lt;AFTER&gt;
8.7.2	Exit Status for Partitioned Steps

The exit status for a partitioned step follows the same rules as for a regular step except for an exit status set by batch artifacts processing individual partitions. This means any batch artifact running on the main thread of the partitioned step can set the steps exit status via the exit status setter method on the StepContext object , the same as for a non-partitioned step.   E.g. a steps partition analyzer, partition reducer, or step listener could each potentially  set the steps exit status in this simple manner (since each of these artifacts run on the initial thread, not the threads processing an individual partition).  If the exit status is not set, it defaults to batch status, the same as for a non-partitioned step.

For a partitioned batchlet, each thread processing a partition may return a separate exit status.  However, these exit status values are ignored unless a partition analyzer is used to coalesce these separate exit status values into a final exit status value for the step.

The batch runtime maintains a StepContext clone per partition.  For a partitioned batchlet or chunk, any batch artifact running on any of the threads processing a partition would merely set a separate exit status through the StepContext clone.  These exit status values are ignored unless a partition analyzer is used to coalesce these separate exit status values into a final exit status value for the step.

&lt;/AFTER&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14868</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-07 19:04:20 +0000</bug_when>
    <thetext>Scott,  

I may be wrong here but I don&apos;t think the batchlet paragraph is correct in the new version.  It&apos;s my understanding that the ExitStatus from a partitioned Batchlet is ignored.  Period.  

The PartitionAnalyzer can coalesce any output by the PartitionCollector, but that is a separate artifact that doesn&apos;t have any direct interaction with the Batchlet by default.

Am I missing something here?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14869</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 19:50:53 +0000</bug_when>
    <thetext>(In reply to mminella from comment #2)
&gt; Scott,  
&gt; 
&gt; I may be wrong here but I don&apos;t think the batchlet paragraph is correct in
&gt; the new version.  It&apos;s my understanding that the ExitStatus from a
&gt; partitioned Batchlet is ignored.  Period.  
&gt; 
&gt; ...

Michael,

In mentioning the potential role of the analyzer, we&apos;re recognizing that the PartitionAnalyzer&apos;s method:

  public void analyzeStatus(BatchStatus batchStatus, String exitStatus) 

could be used to &quot;coalesce&quot; per-partition-only exit statuses into a step-level, overall, exit status.  

That&apos;s the case for both partitioned batchlet and chunk steps.  The fact that the batchlet return value can be used to pass a partition-level exit status via analyzeStatus simply extends the full set of exit status options available to batchlets to partitioned batchlets.

We do exercise this requirement in the TCK, in test:
  ParallelExecutionTests#testInvokeJobWithOnePartitionedStepExitStatus</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14870</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-07 20:02:40 +0000</bug_when>
    <thetext>Sorry.  I stand corrected.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4828</bug_id>
          
          <creation_ts>2013-03-22 15:02:00 +0000</creation_ts>
          <short_desc>SPEC - 8.5.2 Decision exception handling is confusing</short_desc>
          <delta_ts>2014-01-08 15:42:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>1.0_mr_planned</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13030</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-22 15:02:33 +0000</bug_when>
    <thetext>8.5.2 Decision Exception Handling
Any exception thrown by a batch artifact invoked during decision handling will end the job with a batch status of FAILED. This exception is visible to job-level listeners.

Isn&apos;t FAILED on exception well-specified enough without listing this as a special case?  What are we saying about the exception visible to listeners?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14878</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-08 15:42:44 +0000</bug_when>
    <thetext>Leaving this alone...As it turns out FAILED on exception wasn&apos;t completely specified (Bug 5374).  But after the dust has settled, it seems useful to point out that an unhandled exception from the decider will end the job rather than triggering some other behavior in the decision transition element matching.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4829</bug_id>
          
          <creation_ts>2013-03-22 16:04:00 +0000</creation_ts>
          <short_desc>SPEC - add BatchException as common base class</short_desc>
          <delta_ts>2013-08-28 21:24:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13031</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-22 16:04:48 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13032</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-22 16:06:40 +0000</bug_when>
    <thetext>I noticed BatchOperationsRuntimeException has been removed.  I actually 
find exception like this can be quite useful as an umbrella exception.  
I&apos;ve seen such general exceptions in other technologies, for example,

JPA has PersistenceException (unchecked exception), extended by all jpa 
exceptions;
EJB has EJBException (unchecked exception), extended by all exceptions 
in EJB.

It&apos;s convenient for the client code as a grouping mechanism.

Even if we don&apos;t need it right now, it can add some flexibility for 
future enhancement.  For example, this super exception (BatchException) 
can hold some common logic.

Our current exceptions are all very fine-grained, which means various 
vendor-specific exceptions will be created for uncovered error 
conditions (e.g. loopback exception).  I think it will be cleaner if all 
these vendor-specific exceptions voluntarily extend BatchException.

Cheng</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4830</bug_id>
          
          <creation_ts>2013-03-22 16:12:00 +0000</creation_ts>
          <short_desc>8.6.1 Transition Next Element</short_desc>
          <delta_ts>2015-05-22 14:00:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>1.0_mr_pending</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13033</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-22 16:12:13 +0000</bug_when>
    <thetext>pg 42, in the table for next element, to attribute:

Specifies the job-level step, flow, or split to which to transition after this decision... 

Why is job-level step...?  The source step can be nested inside a flow, and so its target next step will not be a job-level step.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13034</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-22 16:12:35 +0000</bug_when>
    <thetext>Good catch.  There was a time when the spec allowed transition elements on decision only.   That statement on pg 42 is a leftover.  It will be removed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14873</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 21:47:40 +0000</bug_when>
    <thetext>Changed to read:

&quot;Specifies the execution element to which to transition after this decision.&quot;


------------------------------------------------------------------------------

Note the rule for transitioning within flows aren&apos;t mentioned here, only elsewhere.  Not trying to address that..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15130</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 12:03:40 +0000</bug_when>
    <thetext>Draft 2 - 2nd change:

Fix snippet at end of 8.6.1 to:

&lt;step id=&quot;Step1&quot;&gt;
	&lt;next on=&quot;*&quot; to=&quot;Step2&quot;/&gt;
&lt;/step&gt;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4833</bug_id>
          
          <creation_ts>2013-03-24 15:07:00 +0000</creation_ts>
          <short_desc>SPEC -transition elements and/or next attribute</short_desc>
          <delta_ts>2013-08-28 22:08:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13039</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-24 15:07:25 +0000</bug_when>
    <thetext>Sorry for not directly referencing earlier bugs.. I know this was recently raised (the idea of having both &lt;next&gt; and @next attribute, and I shot down the idea.

However, since we had to revisit this in the RI anyway, I have a new opinion.

Here&apos;s what the spec should say, IMO:

1) First, we match against any of the transition elements.

2) Next, if we haven&apos;t matched, we follow the next attribute value, if one is specified

3) If no @next is specified, the job ends normally (COMPLETED).

-----

Obviously it would be pointless to have the attribute take precedence over the transition elements...and I can&apos;t see a reason to exclude next as a transition element.

If there are no objections, can we please add this to the spec Chris?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13040</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-24 15:53:40 +0000</bug_when>
    <thetext>Just to point out, SB considers the use of both the next attribute and the next transition element in the same step, etc to be semantically invalid.  I&apos;d have to double check the code but it may be an all or nothing thing (either you use the next attribute or transition elements in general).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14033</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 22:08:24 +0000</bug_when>
    <thetext>This discussion has been superseded by discussion between Scott and Michael on the public ML with subject &quot;evaluation order of multiple transition elements&quot;.   Expect one or more new issues from that discussion.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4849</bug_id>
          
          <creation_ts>2013-03-28 18:06:00 +0000</creation_ts>
          <short_desc>no package summary for javax.batch.*</short_desc>
          <delta_ts>2013-08-28 14:52:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>romain_grecourt</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>arungupta</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13076</commentid>
    <comment_count>0</comment_count>
    <who name="">romain_grecourt</who>
    <bug_when>2013-03-28 18:06:09 +0000</bug_when>
    <thetext>Looking at the combined EE javadocs, there is no package summary for javax.batch packages.

See http://javaee-spec.java.net/nonav/javadocs/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13077</commentid>
    <comment_count>1</comment_count>
    <who name="">arungupta</who>
    <bug_when>2013-03-28 18:07:12 +0000</bug_when>
    <thetext>Add myself to CC</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13290</commentid>
    <comment_count>2</comment_count>
    <who name="">romain_grecourt</who>
    <bug_when>2013-05-01 10:17:49 +0000</bug_when>
    <thetext>what is the status of this ? Will it be fixed in the final javadoc version?</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4865</bug_id>
          
          <creation_ts>2013-04-01 10:43:00 +0000</creation_ts>
          <short_desc>SPEC Partition Plan example confusing</short_desc>
          <delta_ts>2015-09-03 21:23:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>arunkumar_s</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13098</commentid>
    <comment_count>0</comment_count>
    <who name="">arunkumar_s</who>
    <bug_when>2013-04-01 10:43:42 +0000</bug_when>
    <thetext>In PFD 1.7

Under 8.2.6.1 Partition Plan example

&lt;step id=&quot;Step1&quot;&gt; 
&lt;chunk .../&gt; 
   &lt;partition&gt; 
       &lt;plan partitions=&quot;3&quot; threads=&quot;2&quot;/&gt; 
   &lt;/partition&gt; 
&lt;/chunk&gt; 
&lt;/step&gt;

It looks like partition element part of &lt;chunk&gt; element. Actually it should be part of step element like specified in comments of

http://java.net/bugzilla/show_bug.cgi?id=4606</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14877</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-08 14:26:21 +0000</bug_when>
    <thetext>Snippets in Section 8.2.6.1 and another in Section 8.8.1.4 were fixed to have &lt;partition&gt; as a child of &lt;step&gt; not &lt;chunk&gt;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15132</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 12:28:58 +0000</bug_when>
    <thetext>Added one more change:

In Sec. 8.8.1.4, fixed element names:  itemReader =&gt; reader, itemWriter =&gt; writer.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4866</bug_id>
          
          <creation_ts>2013-04-01 10:49:00 +0000</creation_ts>
          <short_desc>SPEC Partition Properties example has a invalid &lt;/properties&gt; tag</short_desc>
          <delta_ts>2015-09-03 16:26:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>arunkumar_s</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13099</commentid>
    <comment_count>0</comment_count>
    <who name="">arunkumar_s</who>
    <bug_when>2013-04-01 10:49:08 +0000</bug_when>
    <thetext>In PFD 1.7

Under 8.2.6.2 Partition Properties example

&lt;partition&gt; 

&lt;plan partitions=&quot;2&quot;&gt; 

&lt;properties partition=&quot;0&quot;&gt; 
&lt;property name=&quot;filename&quot; value=&quot;/tmp/file1.txt&quot;/&gt; 
&lt;/properties&gt; 

&lt;properties partition=&quot;1&quot;&gt; 
&lt;property name=&quot;filename&quot; value=&quot;/tmp/file2.txt&quot;/&gt; 
&lt;/properties&gt; 

&lt;/properties&gt; 
&lt;/partition


Last two lines of xml is wrong. 
First there shouldnt be a &lt;/properties&gt; tag in the second last line. It should be &lt;/plan&gt;
Second the &lt;/partition should end with &gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14635</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-25 15:27:22 +0000</bug_when>
    <thetext>Corrected typos in XML snippet for Partition Properties example;  corrected partition number description by changing from &quot;positive&quot; to &quot;non-negative&quot; (Section 8.2.6.2).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14963</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-16 15:35:14 +0000</bug_when>
    <thetext>As Cheng noticed recently, we have a similar issue in Sec. 8.8.1.2

E.g. The batch runtime would attempt resolution of the jobProperties operator specification in the following chunk definition by first searching the chunk properties collection, then the step properties collection (if any), then the job properties collection (if any). The search would stop at the first occurrence of the specified target name. 

&lt;job id=&quot;job1&quot;&gt; &lt;properties&gt; &lt;property name=&quot;filestem&quot; value=&quot;postings&quot;/&gt; &lt;/properties&gt; &lt;step id=&quot;step1&quot;&gt; &lt;chunk&gt; &lt;properties&gt; &lt;property name=&quot;infile.name&quot; value=&quot;#{jobProperties[&apos;filestem&apos;]}.txt&quot;/&gt; &lt;/properties&gt; &lt;/chunk&gt; &lt;/</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15131</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 12:23:06 +0000</bug_when>
    <thetext>Fixed example in Section 8.8.1.2 to conform to XSD and better explain that you can use a jobProperties substitution from an earlier property in the current sequence (same scope).

It now reads:
------------------------------------------------------------------------------
E.g.

The batch runtime would attempt resolution of the jobProperties operator specification in the following  reader property definition by first searching for earlier property definitions within the reader properties collection, then the step properties collection (there are none in this example), then the job properties collection (if any).  The search would stop at the first occurrence of the specified target name.  

&lt;job id=&quot;job1&quot;&gt;
&lt;properties&gt;
  &lt;property name=&quot;filestem&quot; value=&quot;postings&quot;/&gt;
&lt;/properties&gt;
 &lt;step id=&quot;step1&quot;&gt;
  &lt;properties/&gt;
  &lt;chunk&gt;
    &lt;reader ref=MyReader&gt; 
	&lt;properties&gt;
      	  &lt;property name=&quot;infile.name&quot;                        
 				value=&quot;#jobProperties[&apos;filestem&apos;]}.txt&quot;/&gt;
	&lt;/properties&gt;
    &lt;/reader&gt;
  &lt;/chunk&gt;
 &lt;/step&gt;
&lt;/job&gt;

The resolved value for property &quot;infile.name&quot; would be &quot;postings.txt&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15151</commentid>
    <comment_count>4</comment_count>
    <who name="">kmukher</who>
    <bug_when>2014-02-14 21:37:05 +0000</bug_when>
    <thetext>Since the example mentions the search order of property resolution it would help to include it right in the XML so we don&apos;t have to qualify the statement with &quot;there are none in this example&quot;.

------------

The batch runtime would attempt resolution of the jobProperties operator specification in the following reader property definition by first searching for earlier property definitions within the reader properties collection, then the step properties collection, then the job properties collection (if any). The search would stop at the first occurrence of the specified target name. 

&lt;job id=&quot;job1&quot;&gt; 
    &lt;properties&gt; 
        &lt;property name=&quot;filestem&quot; value=&quot;postings&quot;/&gt; 
        &lt;property name=&quot;outputlog&quot; value=&quot;jobmessages&quot;/&gt; 
    &lt;/properties&gt; 
    &lt;step id=&quot;step1&quot;&gt; 
        &lt;properties/&gt; 
        &lt;chunk&gt; 
            &lt;reader ref=MyReader&gt; 
                &lt;properties&gt; 
                    &lt;property name=&quot;infile.name&quot; value=&quot;#{jobProperties[&apos;filestem&apos;]}.txt&quot;/&gt; 
                    &lt;property name=&quot;ouputtlog&quot; value=&quot;readermessages&quot;/&gt; 
                    &lt;property name=&quot;outfile.name value=&quot;#{jobProperties[outputlog]}.txt&quot;/&gt; 
                &lt;/properties&gt; 
            &lt;/reader&gt; 
        &lt;/chunk&gt; 
    &lt;/step&gt; 
&lt;/job&gt; 

The resolved value for property &quot;infile.name&quot; would be &quot;postings.txt&quot;.
The resolved value for property &quot;outfile.name&quot; would be &quot;readermessages.txt&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15152</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-14 21:56:53 +0000</bug_when>
    <thetext>Kaushik, 

I can incorporate that example too alongside the other.   It still doesn&apos;t have any properties at the step properties level, but it now shows substitution from an earlier property at the &quot;same level&quot; alongside the other one, and so clarifies that the search is inner to outer.    This means that override is outer to inner (by that I mean that inner overrides outer which I think is natural).

Here&apos;s how it reads now:

------------------------------------------------------------------------------

8.8.1.2	jobProperties Substitution Operator

The jobProperties substitution operator resolves to the value of the job property with the specified target name.  This property is found by recursively searching  from the innermost containment scope to the outermost scope until a property with the specified target name is found. 

E.g.
The batch runtime would attempt resolution of the jobProperties operator specification in each of the two following  reader property definitions by first searching for earlier property definitions within the reader properties collection, then the step properties collection (there are none in this example), then the job properties collection (if any).  The search stops at the first occurrence of the specified target name.  

&lt;job id=&quot;job1&quot;&gt;
	&lt;properties&gt;
		&lt;property name=&quot;filestem&quot; value=&quot;postings&quot;/&gt;
		&lt;property name=&quot;outputlog&quot; value=&quot;jobmessages&quot;/&gt;
	&lt;/properties&gt;
	&lt;step id=&quot;step1&quot;&gt;
		&lt;properties/&gt;
		&lt;chunk&gt;
			&lt;reader ref=MyReader&gt; 
				&lt;properties&gt;
					&lt;property name=&quot;infile.name&quot;  value=&quot;#{jobProperties[&apos;filestem&apos;]}.txt&quot;/&gt;
					&lt;property name=&quot;ouputtlog&quot;  value=&quot;readermessages&quot;/&gt; 
					&lt;property name=&quot;outfile.name  value=&quot;#{jobProperties[&apos;outputlog&apos;]}.txt&quot;/&gt; 
				&lt;/properties&gt;
			&lt;/reader&gt;
		&lt;/chunk&gt;
	&lt;/step&gt;
&lt;/job&gt;

The resolved value for reader property &quot;infile.name&quot; would be &quot;postings.txt&quot;.
The resolved value for reader property &quot;outfile.name&quot; would be &quot;readermessages.txt&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15153</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-14 22:00:04 +0000</bug_when>
    <thetext>Rephrased slightly:

The jobProperties substitution operator resolves to the value of the job property with the specified target name.  This property is found by recursively searching  from the innermost containment scope (this includes earlier properties within the current scope) to the outermost scope until a property with the specified target name is found.

---

Just wait for the full PDF to review if this is too much to assemble.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15394</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-24 14:17:13 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #5)

In above, new example, change:
 &lt;property name=&quot;ouputtlog&quot;  value=&quot;readermessages&quot;/&gt; 
to:
 &lt;property name=&quot;outputlog&quot;  value=&quot;readermessages&quot;/&gt; 

Thanks to Michael for noticing that.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4887</bug_id>
          
          <creation_ts>2013-04-09 06:05:00 +0000</creation_ts>
          <short_desc>Exception When Using Null Parameter Lists</short_desc>
          <delta_ts>2013-08-28 15:02:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>fribeiro</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13165</commentid>
    <comment_count>0</comment_count>
    <who name="">fribeiro</who>
    <bug_when>2013-04-09 06:05:32 +0000</bug_when>
    <thetext>When the parameter lists are null, any calls to JobOperator.getParameters throw a NoSuchJobExecutionException exception.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13173</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-04-09 19:05:44 +0000</bug_when>
    <thetext>Thanks for letting us know.   Fixed in next drop.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13174</commentid>
    <comment_count>2</comment_count>
    <who name="">fribeiro</who>
    <bug_when>2013-04-09 19:09:06 +0000</bug_when>
    <thetext>You are welcome!</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4962</bug_id>
          
          <creation_ts>2013-05-01 10:19:00 +0000</creation_ts>
          <short_desc>metadata of javax.batch-api does not comply with https://wikis.oracle.com/display/GlassFish/Maven+Versioning+Rules</short_desc>
          <delta_ts>2013-08-28 14:51:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>romain_grecourt</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13291</commentid>
    <comment_count>0</comment_count>
    <who name="">romain_grecourt</who>
    <bug_when>2013-05-01 10:19:17 +0000</bug_when>
    <thetext>See the following output:

[ javax.batch:javax.batch-api:1.0-b26 ]
{ spec-version=0.0 apiPackage=javax.batch API non-final new-spec-version=1.0 spec-build=23 }
- ERROR: Extension-Name not found in MANIFEST
- ERROR: Specification-Version not found in MANIFEST
- ERROR: Implementation-Version not found in MANIFEST
- WARNING: Extension-Name () should be javax.batch
- WARNING: Bundle-Version (1.0.0.qualifier) should be 0.0.99.b23
- WARNING: Specification-Version () should be 0.0.99.23
- WARNING: Bundle-SymbolicName (JSR352.API) should be javax.batch-api

Please fix this in the final version of the API jar.

Thanks.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5218</bug_id>
          
          <creation_ts>2013-07-18 15:24:00 +0000</creation_ts>
          <short_desc>Add generics where it makes sense</short_desc>
          <delta_ts>2013-08-28 14:46:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13745</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-07-18 15:24:59 +0000</bug_when>
    <thetext>The interfaces defined within the spec typically take or return Object.  It would be much nicer to have the type safety of generics available.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14021</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 14:46:00 +0000</bug_when>
    <thetext>The generics we had were removed (Bug 4791 and Bug 4776 show at least part of the discussion).

Will close for now since this doesn&apos;t include a specific suggestion.  

If you decide to reopen with specific signatures, suggested, we can add that to the SPEC list, but it seems like it might be more appropriate for a new JSR rather than a maintenance release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5315</bug_id>
          
          <creation_ts>2013-08-21 10:40:00 +0000</creation_ts>
          <short_desc>Broken PostgreSQL Support in SE mode</short_desc>
          <delta_ts>2015-09-01 20:51:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mbogner2</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>htavarez</cc>
    
    <cc>issues</cc>
    
    <cc>kewlmain</cc>
    
    <cc>lberteau</cc>
    
    <cc>radcortez</cc>
    
    <cc>ScottKurz</cc>
    
    <cc>thomas_haines</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13966</commentid>
    <comment_count>0</comment_count>
    <who name="">mbogner2</who>
    <bug_when>2013-08-21 10:40:36 +0000</bug_when>
    <thetext>Hello,

I&apos;m trying to get the SE RI running with an up2date installation of postgresql. I&apos;ve already imported the ddl [3] into public schema and configured the database connection.

The exception is thrown when executing JDBCPersistenceManagerImpl.java:386

PreparedStatement ps = null;
ps = connection.prepareStatement(&quot;SET SCHEMA ?&quot;);
ps.setString(1, schema);
ps.executeUpdate();

My connection is configured correctly and the SQL statement would be &quot;SET SCHEMA &apos;public&apos;&quot; as my connetion-config looks like this:
JDBC_DRIVER=org.postgresql.Driver
JDBC_URL=jdbc\:postgresql\://localhost/jsr352
DB_USER=jsr352
DB_PWD=jsr352
DB_SCHEMA=public

Executing the statement on the command line works, but executing it with plain JDBC results in the same exception as I get it in the RI.

public static void main(String[] args) throws SQLException {
        final PreparedStatement stmt = DriverManager.getConnection(
          &quot;jdbc:postgresql://localhost/jsr352&quot;, &quot;jsr352&quot;,&quot;jsr352&quot;)
          .prepareStatement(&quot;SET SCHEMA ?&quot;);
        stmt.setString(1, &quot;public&quot;);
        stmt.executeUpdate();
        stmt.close();
}

results in the exception as stated under [1].

The RI tries to execute this statement in class JDBCPersistenceManagerImpl.java line 386 which results in the exception as stated under [2].

As this statement is executed every time a connection is opened I don&apos;t know how to use the RI with PostgreSQL without changing the source. I think the statement SET SCHEMA should be avoided in general.

Regards,
Manuel

[1]

Exception in thread &quot;main&quot; org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;$1&quot;
  Position: 12
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2157)
	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1886)
	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:255)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:555)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:417)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeUpdate(AbstractJdbc2Statement.java:363)
	at test.Main.main(Main.java:21)

[2]

Exception in thread &quot;main&quot; javax.batch.operations.JobStartException: com.ibm.jbatch.container.exception.PersistenceException: org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;$1&quot;
  Position: 12
	at com.ibm.jbatch.container.api.impl.JobOperatorImpl.start(JobOperatorImpl.java:90)
	at at.itsv.sea.jsr352se.util.BatchExecutionUtil.submitJob(BatchExecutionUtil.java:14)
	at at.itsv.sea.jsr352se.ExampleBatch.main(ExampleBatch.java:33)
Caused by: com.ibm.jbatch.container.exception.PersistenceException: org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;$1&quot;
  Position: 12
	at com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl.createJobInstance(JDBCPersistenceManagerImpl.java:1712)
	at com.ibm.jbatch.container.jobinstance.JobExecutionHelper.getNewJobInstance(JobExecutionHelper.java:89)
	at com.ibm.jbatch.container.jobinstance.JobExecutionHelper.startJob(JobExecutionHelper.java:120)
	at com.ibm.jbatch.container.impl.BatchKernelImpl.startJob(BatchKernelImpl.java:123)
	at com.ibm.jbatch.container.api.impl.JobOperatorImpl.startInternal(JobOperatorImpl.java:121)
	at com.ibm.jbatch.container.api.impl.JobOperatorImpl.start(JobOperatorImpl.java:86)
	... 2 more
Caused by: org.postgresql.util.PSQLException: ERROR: syntax error at or near &quot;$1&quot;
  Position: 12
	at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2157)
	at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1886)
	at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:255)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:555)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:417)
	at org.postgresql.jdbc2.AbstractJdbc2Statement.executeUpdate(AbstractJdbc2Statement.java:363)
	at com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl.setSchemaOnConnection(JDBCPersistenceManagerImpl.java:386)
	at com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl.getConnection(JDBCPersistenceManagerImpl.java:323)
	at com.ibm.jbatch.container.services.impl.JDBCPersistenceManagerImpl.createJobInstance(JDBCPersistenceManagerImpl.java:1700)
	... 7 more

[3]

DROP TABLE IF EXISTS JOBSTATUS;
DROP TABLE IF EXISTS STEPSTATUS;
DROP TABLE IF EXISTS CHECKPOINTDATA;
DROP TABLE IF EXISTS JOBINSTANCEDATA;
DROP TABLE IF EXISTS EXECUTIONINSTANCEDATA;
DROP TABLE IF EXISTS STEPEXECUTIONINSTANCEDATA;

CREATE TABLE JOBINSTANCEDATA(
  jobinstanceid		serial not null PRIMARY KEY,
  name		character varying (512), 
  apptag VARCHAR(512)
);

CREATE TABLE EXECUTIONINSTANCEDATA(
  jobexecid		serial not null PRIMARY KEY,
  jobinstanceid	bigint not null REFERENCES JOBINSTANCEDATA (jobinstanceid),
  createtime	timestamp,
  starttime		timestamp,
  endtime		timestamp,
  updatetime	timestamp,
  parameters	bytea,
  batchstatus		character varying (512),
  exitstatus		character varying (512)
);
  
CREATE TABLE STEPEXECUTIONINSTANCEDATA(
	stepexecid			serial not null PRIMARY KEY,
	jobexecid			bigint not null REFERENCES EXECUTIONINSTANCEDATA (jobexecid),
	batchstatus         character varying (512),
    exitstatus			character varying (512),
    stepname			character varying (512),
	readcount			integer,
	writecount			integer,
	commitcount         integer,
	rollbackcount		integer,
	readskipcount		integer,
	processskipcount	integer,
	filtercount			integer,
	writeskipcount		integer,
	startTime           timestamp,
	endTime             timestamp,
	persistentData		bytea
); 

CREATE TABLE JOBSTATUS (
  id		bigint not null REFERENCES JOBINSTANCEDATA (jobinstanceid),
  obj		bytea
);

CREATE TABLE STEPSTATUS(
  id		bigint not null REFERENCES STEPEXECUTIONINSTANCEDATA (stepexecid),
  obj		bytea
);

CREATE TABLE CHECKPOINTDATA(
  id		character varying (512),
  obj		bytea
);</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13967</commentid>
    <comment_count>1</comment_count>
    <who name="">mbogner2</who>
    <bug_when>2013-08-21 10:55:29 +0000</bug_when>
    <thetext>Strange behavior. I wrote two unit tests to get behind this bug. The first one uses PreparedStatement and fails as expected. But using normal Statement as done in the second test works. Bad practice, but works.

    @Test
    public void testSetSchemaPrepared() throws SQLException {
        final PreparedStatement stmt = con.prepareStatement(&quot;SET SCHEMA ?&quot;);
        stmt.setString(1, &quot;&quot;);
        try {
            stmt.executeUpdate();
            fail(&quot;this doesnt work, doesnt it?&quot;);
        } catch (final SQLException exc) {
            // expected
        } finally {
            stmt.close();
        }
    }

    @Test
    public void testSetSchema() throws SQLException {
        final Statement stmt = con.createStatement();
        stmt.execute(&quot;SET SCHEMA &apos;public&apos;&quot;);
        stmt.close();
    }</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13968</commentid>
    <comment_count>2</comment_count>
    <who name="">mbogner2</who>
    <bug_when>2013-08-21 11:57:11 +0000</bug_when>
    <thetext>@PreparedStatement-Test:
stmt.setString(1, &quot;&quot;);
or
stmt.setString(1, &quot;public&quot;);
gives the same result...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13971</commentid>
    <comment_count>3</comment_count>
    <who name="">thomas_haines</who>
    <bug_when>2013-08-22 12:15:45 +0000</bug_when>
    <thetext>Hi, this same issue / same line also fails if you try to run SE RI using MySQL (error when SET SCHEMA command is called from JDBCPersistenceManagerImpl).

I traced it through in the source, but couldn&apos;t see a way to fix it without branching &amp; adding logic to skip sending the command when the JDBC_DRIVER is MySQL.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14016</commentid>
    <comment_count>4</comment_count>
    <who name="">htavarez</who>
    <bug_when>2013-08-27 19:55:08 +0000</bug_when>
    <thetext>
What release version of PostgreSQL are you using?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14018</commentid>
    <comment_count>5</comment_count>
    <who name="">mbogner2</who>
    <bug_when>2013-08-27 23:37:42 +0000</bug_when>
    <thetext>(In reply to htavarez from comment #4)
&gt; What release version of PostgreSQL are you using?

I&apos;m using the latest release. 9.2.4</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14042</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-08-29 16:19:54 +0000</bug_when>
    <thetext>So it seems from here:

http://stackoverflow.com/questions/4168689/is-it-possible-to-specify-schema-when-connecting-to-postgres-with-jdbc

the &quot;schema&quot; can be specified on the conn URL.

That suggests we could have a new property in batch-config.properties:
  SET_DEFAULT_SCHEMA  (defaults to &apos;true&apos;)

If &apos;false&apos;, we would simply not do this SET SCHEMA. 

That works fine for &quot;SE mode&quot;, where we use the conn URL.   

That leaves &quot;EE mode&quot;, where we&apos;re using a DataSource.   If anyone is familiar with these please let us know, otherwise I&apos;m inclined to say we&apos;ll deal with that if/when we need to, and go ahead and make the above change.

Sound reasonable?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14061</commentid>
    <comment_count>7</comment_count>
    <who name="">mbogner2</who>
    <bug_when>2013-08-29 19:48:14 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #6)
&gt; So it seems from here:
&gt; 
&gt; http://stackoverflow.com/questions/4168689/is-it-possible-to-specify-schema-
&gt; when-connecting-to-postgres-with-jdbc
&gt; 
&gt; the &quot;schema&quot; can be specified on the conn URL.
&gt; 
&gt; That suggests we could have a new property in batch-config.properties:
&gt;   SET_DEFAULT_SCHEMA  (defaults to &apos;true&apos;)
&gt; 
&gt; If &apos;false&apos;, we would simply not do this SET SCHEMA. 
&gt; 
&gt; That works fine for &quot;SE mode&quot;, where we use the conn URL.   
&gt; 
&gt; That leaves &quot;EE mode&quot;, where we&apos;re using a DataSource.   If anyone is
&gt; familiar with these please let us know, otherwise I&apos;m inclined to say we&apos;ll
&gt; deal with that if/when we need to, and go ahead and make the above change.
&gt; 
&gt; Sound reasonable?

Adding the default schema to the connection url has to be supported by the jdbc driver. The article doesn&apos;t really say that this feature is supported by the latest postgresql driver. So I don&apos;t think this is a very generic solution anyway. Further having a flag to skip this configuration removes the functionality to set a custom schema in the application and leaves you alone with your database config.

In my opinion the correct solution would be to prepend the configured schema name to all table names in the queries instead of setting a default schema for the whole connection. Would this be possible too?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14172</commentid>
    <comment_count>8</comment_count>
    <who name="">thomas_haines</who>
    <bug_when>2013-09-18 01:27:46 +0000</bug_when>
    <thetext>&gt; So I don&apos;t think this is a very generic solution anyway. 
&gt; Further having a flag to skip this configuration removes the functionality 
&gt; to set a custom schema in the application and leaves you alone with your database config.

To include the flexibility for all databases, would one solution be to adopt the suggested SET_DEFAULT_SCHEMA [true/false] option in batch-config.properties, 
plus include an additional DB_INIT_STATEMENT option in batch-config.properties. If specified, the DB_INIT_STATEMENT statement is run after the connection is established.

For MySQL and many other drivers, the database name can be specified in the connection URL.  For special cases, you could use the DB_INIT_STATEMENT, e.g. in Postgres if you did not want to use the connection url, you could use:

SET_DEFAULT_SCHEMA=FALSE
DB_INIT_STATEMENT=SET search_path TO jbatch

Perhaps this would balance simplicity with generic support for any jdbc database (between connectionUrl and in rare cases a DB init statement) ?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17301</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-12-18 15:25:02 +0000</bug_when>
    <thetext>Some related observations noted with:
https://github.com/WASdev/standards.jsr352.jbatch/issues/23

Note I&apos;d be happy to consider special-casing MySQL and PostgreSQL like we did with Oracle as a tactical solution.  Also there&apos;s the start of an effort to make the persistence service truly pluggable and extensible
https://github.com/WASdev/standards.jsr352.jbatch/issues/11</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19059</commentid>
    <comment_count>10</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 20:51:17 +0000</bug_when>
    <thetext>This discussion has moved to:
https://github.com/WASdev/standards.jsr352.jbatch/issues/23.

Closing to clean up Bugzilla.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4702</bug_id>
          
          <creation_ts>2013-02-20 21:02:00 +0000</creation_ts>
          <short_desc>TCK ChunkTests issues</short_desc>
          <delta_ts>2013-08-29 14:46:55 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12652</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-20 21:02:59 +0000</bug_when>
    <thetext>Reviewing the test cases in the ChunkTests test within the TCK raises the following issues:

1.  testChunkRestartItemCount7, testChunkRestartItemCount10, testChunkRestartChunk5 - How do these methods validate that the jobs failed at the correct point, restarted at the correct point and processed the correct number of records in each attempt?  The only assertions that are made are the status of the job and if it was restarted (via an instance id check).  Also, besides the number of records to be read in/processed, all three of these methods seem to be the same test (redundant).


2.  testChunkRestartCustomChunkDefaults - This test doesn&apos;t actually verify the chunk size directly.  Since time can have an impact on chunk size, while this test will probably work, it&apos;s not the most direct way of verifying chunk size.  


3.  testChunkRestartCustomCheckpoint - No validation that the number of items processed is correct, no validation that it was a true restart (same issue as all of the tests above), no validation that checkpointing itself was used to maintain the required state (it just requires that the state be maintained between executions which could probably be accomplished by reusing the same instances of the batch artifacts).

4.  testChunkTimeBasedDefaultCheckpoint - Error message in MyTimeCheckpointListener#beforeChunk is incorrect.  It implies that the chunk committed sooner when it could have also committed later.  Also, I didn&apos;t think that there was a default timeout for chunk processing...

5.  testChunkRestartTimeBasedCheckpoint - Does not validate that checkpointing is actually being used for this.  Also does not validate the number of items processed each run or total number of items processed.

6.  testChunkRestartTimeBasedDefaultCheckpoint - Does not validate that checkpointing is being used for this.  Does not validate the number of items processed per run or total.

7.  testChunkSkipRead, testChunkSkipProcess - All of the statuses set by the listeners are the same so if any of the listeners are triggered, the test would pass.  Statuses should be more specific.

8.  testChunkSkipWrite - Tests against the default exit status so it would pass if no items were skipped.

9.  testChunkSkipReadExceedSkip, testChunkSkipProcessExceedSkip, testChunkSkipWriteExceedSkip - All of the statuses set by the listeners are the same so if any of the listeners are triggered, the test passes.  No validation that the job failed due to the skip limit being hit (just that a skip occurred and that the job failed).

10.  testChunkSkipNoReadSkipChildEx - All of the statuses set by the listeners are the same so if any of them are triggered via a skip, the test passes.  No validation that the failure of the job was due to the skip limit being hit.  The only validation that occurs is that an item was skipped and that the job failed.

11.  testChunkRetryRead - Does not use/validate retryable-exceptions.  Does not validate that any retry occurred, just that the job was completed successfully.

12.  testChunkItemListeners - All three runs validate against the read listener&apos;s constant (instead of the appropriate listener&apos;s constant per each run).  All of the constants also are set to the same value so the validation would be inconclusive.  Also the error methods on the listeners are not tested.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12654</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-20 23:15:58 +0000</bug_when>
    <thetext>
(In reply to comment #0)

&gt; 1.  testChunkRestartItemCount7, testChunkRestartItemCount10,
&gt; testChunkRestartChunk5 - How do these methods validate that the jobs failed at
&gt; the correct point, restarted at the correct point and processed the correct
&gt; number of records in each attempt?  The only assertions that are made are the
&gt; status of the job and if it was restarted (via an instance id check).  Also,
&gt; besides the number of records to be read in/processed, all three of these
&gt; methods seem to be the same test (redundant).

Michael, thanks for the review.

We&apos;re still going through your list, but I wanted to start by giving an answer to the first since it will show a pattern we use often in these TCK tests.

You&apos;re not seeing more assertions (than the checking of batch status) in the testng/junit test method, since the validation is really happening in the batch artifact.   

The batch artifact, in this case the writer (DoSomethingArrayItemWriterImpl), contains logic to determine if the chunk writes are occurring at the correct point upon restart.  It can distinguish between the original run vs. the restart case by the value of the checkpoint data passed into the open() method.

If the checkpoint data is not in sync with the known write point, the writer artifact throws an Exception which fails the 
restart job and puts the BatchStatus into FAILED state. 

The artifact is written to be reused across more than one test by injecting the list of expected values via JSL as BatchProperty(s). 

The three methods are using different job xmls in which the item-count values are set to different values. 
These values are less than the default value (10), greater than the default value and exactly equal to the default value, to 
ensure these values are being honored over the default value.

Having said all that I don&apos;t see a further need to &quot;validate that the jobs failed at the correct point&quot; as you mentioned.

------------------------------------------------------------------------------

Though we can appreciate the value of keeping all the assertions in one place (e.g. the JUnit/TestNG test method), that seemed to result in unnecessary passing back and forth data when simply &quot;blowing up&quot; would do the trick.  

Will review the others tomorrow...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12656</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-21 14:45:12 +0000</bug_when>
    <thetext>Scott,

I have to disagree that the validation you are proposing goes far enough.  From what you are saying, the assumption is being made that the state is being reset correctly on the restart in order to validate that the job is picking up where it left off.  However, that cannot be a valid assumption.  The test should verify that the state was re-established correctly, and therefore is picking up at the correct spot.  For example, if my runtime does not pass in an Externalizable on restart, since you do not pass in a record fail parameter on the restart, the ItemReader assumes that it is a new run and therefore resets the index and would rerun the job to completion and the test would therefore pass.  Is my understanding incorrect?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12657</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-21 21:25:56 +0000</bug_when>
    <thetext>(In reply to comment #2)
&gt; Scott,
&gt; I have to disagree that the validation you are proposing goes far enough.  From
&gt; what you are saying, the assumption is being made that the state is being reset
&gt; correctly on the restart in order to validate that the job is picking up where
&gt; it left off.  However, that cannot be a valid assumption.  The test should
&gt; verify that the state was re-established correctly, and therefore is picking up
&gt; at the correct spot.  For example, if my runtime does not pass in an
&gt; Externalizable on restart, since you do not pass in a record fail parameter on
&gt; the restart, the ItemReader assumes that it is a new run and therefore resets
&gt; the index and would rerun the job to completion and the test would therefore
&gt; pass.  Is my understanding incorrect?

Michael, 

It doesn&apos;t sound like you have an issue with the general idea of validation done by the artifact but you&apos;re saying we have a gap in this test (or tests) where we would incorrectly pass a wrong impl.

I think you make a good point.

As it turns out the test would indeed fail (as it should), but maybe in too roundabout a way?  The writer (DoSomethingSimpleArrayWriter, not DoSomethingArrayItemWriterImpl as I&apos;d said earlier), uses a fixed int[30] array to write to.   If only the reader failed to checkpoint and started from the beginning... and the writer steadily advanced its index... it would overflow by the time the original execution + restart were finished.   (If the writer failed to checkpoint either alone or together with the reader we have a more direct failure).

I think we could close this gap by more directly checking the checkpoint value passed into the reader open.   

On a side note, I&apos;ll mention that we&apos;re using the persistent step context at the moment to provide the variable for the artifact(s) to distinguish if this is the restart or the original execution.   For some of these tests, we were using restart override parameters at one point to make this same distinction.  Restart parms were removed from the spec, then re-added.. so you might seem some leftover artifacts of this churn.

Another note, which gets to your point 2.).... these tests were written before the spec moved to allow item or time-based checkpointing, whichever came first... so they made some assumptions which might need some rethinking.   

I&apos;m not sure how much we&apos;ve thought about this.. so owe you an answer.   Also in looking at this I think we might have an RI bug in how we calculate time elapsed... which could additionally confuse the execution of these tests.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12666</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-22 23:21:08 +0000</bug_when>
    <thetext>Finally getting around to responding in detail (though there&apos;s still a place or two I need to look at more but I didn&apos;t want to end the week without responding).

Thanks again for your comments.

(In reply to comment #0)
&gt; Reviewing the test cases in the ChunkTests test within the TCK raises the
&gt; following issues:
&gt; 1.  testChunkRestartItemCount7, testChunkRestartItemCount10,
&gt; testChunkRestartChunk5 - How do these methods validate that the jobs failed at
&gt; the correct point, restarted at the correct point and processed the correct
&gt; number of records in each attempt?  The only assertions that are made are the
&gt; status of the job and if it was restarted (via an instance id check).  Also,
&gt; besides the number of records to be read in/processed, all three of these
&gt; methods seem to be the same test (redundant).

Building on my earlier comments...let me put this into my own words and see if you agree. 

&quot;We are not directly checking that the reader/writer open() methods are passed 
the current checkpoint values on original execution and restart.   
We are relying too much on downstream behavior in the writer.&quot;

Now, I&apos;d say the logic in the writer is a bit complicated in that it relies on an interplay between persistent user data, @BatchProperty(s), and a couple array indices... but I believe we are effectively testing that the correct number of records are being written in each chunk, in each execution.   

&gt; 2.  testChunkRestartCustomChunkDefaults - This test doesn&apos;t actually verify the
&gt; chunk size directly.  Since time can have an impact on chunk size, while this
&gt; test will probably work, it&apos;s not the most direct way of verifying chunk size.  

This doesn&apos;t seem to be doing anything important...will look into it and possibly remove.

&gt; 3.  testChunkRestartCustomCheckpoint - No validation that the number of items
&gt; processed is correct, no validation that it was a true restart (same issue as
&gt; all of the tests above), no validation that checkpointing itself was used to
&gt; maintain the required state (it just requires that the state be maintained
&gt; between executions which could probably be accomplished by reusing the same
&gt; instances of the batch artifacts).

As in 1), I think the number of items processed is effectively tested, as is
the writer checkpoint (I mentioned this in my comment #3).   As in 1), the
reader checkpointing could be tested more directly.   

Regarding your point: &quot;no validation that it was a true restart&quot;.  Not sure
I&apos;m understanding.. have I already addressed that or are you suggesting something further?   I could imagine some additional assertions but I&apos;m sure they&apos;d add too much value so I&apos;d like to hear your thoughts.

&gt; 4.  testChunkTimeBasedDefaultCheckpoint - Error message in
&gt; MyTimeCheckpointListener#beforeChunk is incorrect.  It implies that the chunk
&gt; committed sooner when it could have also committed later.  Also, I didn&apos;t think
&gt; that there was a default timeout for chunk processing...

Thanks for catching that... our code is assuming a default of 10 seconds. The default should now be &apos;0&apos;, i.e. don&apos;t checkpoint due to time.  Also the error message should be improved.

&gt; 5.  testChunkRestartTimeBasedCheckpoint - Does not validate that checkpointing
&gt; is actually being used for this.  Also does not validate the number of items
&gt; processed each run or total number of items processed.
&gt; 6.  testChunkRestartTimeBasedDefaultCheckpoint - Does not validate that
&gt; checkpointing is being used for this.  Does not validate the number of items
&gt; processed per run or total.

I&apos;m assuming the earlier comments already do (or do not) address the points here
as well.  Correct?

&gt; 7.  testChunkSkipRead, testChunkSkipProcess - All of the statuses set by the
&gt; listeners are the same so if any of the listeners are triggered, the test would
&gt; pass.  Statuses should be more specific.
&gt; 8.  testChunkSkipWrite - Tests against the default exit status so it would pass
&gt; if no items were skipped.

Agreed.  We&apos;ll make that change (to a reader/processor/writer-specific exit status).

&gt; 9.  testChunkSkipReadExceedSkip, testChunkSkipProcessExceedSkip,
&gt; testChunkSkipWriteExceedSkip - All of the statuses set by the listeners are the
&gt; same so if any of the listeners are triggered, the test passes.  No validation
&gt; that the job failed due to the skip limit being hit (just that a skip occurred
&gt; and that the job failed).

OK, we can make a reader/processor/writer-specific exit status.. but I&apos;m not seeing an obvious way to test &quot;the job failed due to the skip limit being hit&quot;.   Is that really worth going out of our way for given that normally the job will complete succesfully, in contrast?

&gt; 10.  testChunkSkipNoReadSkipChildEx - All of the statuses set by the listeners
&gt; are the same so if any of them are triggered via a skip, the test passes.  No
&gt; validation that the failure of the job was due to the skip limit being hit. 
&gt; The only validation that occurs is that an item was skipped and that the job
&gt; failed.

We will confirm that the one skip read listener is called exactly twice, with 
the included exception each time (not any other exception).

(Also looks like the @test_Strategy comment got botched).

&gt; 11.  testChunkRetryRead - Does not use/validate retryable-exceptions.  Does not
&gt; validate that any retry occurred, just that the job was completed successfully.

Let me look at this one some more.

&gt; 12.  testChunkItemListeners - All three runs validate against the read
&gt; listener&apos;s constant (instead of the appropriate listener&apos;s constant per each
&gt; run).  All of the constants also are set to the same value so the validation
&gt; would be inconclusive.  Also the error methods on the listeners are not tested.

Ok, we&apos;ll separate out the exit status so each of the three runs is reader/processor/writer
specific.

Also.. you&apos;re right, the error methods are not tested.  Will add a test there.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12673</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:19:09 +0000</bug_when>
    <thetext>Scott,

#1  I think I may see where I&apos;m going wrong on my understanding of this, but it leaves, IMHO a more serious spec related issue.  It seems to me that these tests are assuming on restart that the parameters provided in the last execution will be re-applied in the new execution (What leads me to that is that there is no null check on of the readrecordfailNumberString in the DoSomethingArrayItemReaderImpl prior to the Integer.parseInt).  That can&apos;t work.  It prevents you from removing a previously passed in value.  I&apos;ll take a look to see if an issue is already opened on that and if not, open one.

#3  What I mean by &quot;no validation that it was a true restart&quot; is that there is no check that the restart provided a new JobExecution.  All it checks is that the JobExecution provided has the same JobInstance reference (which it would if we restarted the old JobExecution instead of creating a new one like the spec requires).

#9  I do feel that it is important to validate that the skip limit was the reason for the job failure.  When I think of all of the ways people could code a runtime like this up, we need to be sure we are being as explicit as possible in validating the executed functionality.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12685</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 06:02:43 +0000</bug_when>
    <thetext>(In reply to comment #5)
&gt; Scott,
&gt; #1  ...
Michael
...I&apos;m going to read through that carefully a bit later

&gt; #3  What I mean by &quot;no validation that it was a true restart&quot; is that there is
&gt; no check that the restart provided a new JobExecution.  All it checks is that
&gt; the JobExecution provided has the same JobInstance reference (which it would if
&gt; we restarted the old JobExecution instead of creating a new one like the spec
&gt; requires).

I see... well, we hadn&apos;t thought this was that interesting to test.  Would you agree that if we added this assertion to a few of these chunk restart tests that we wouldn&apos;t need it on every test in the whole TCK that performs a restart?   That doesn&apos;t seem like that tricky a thing to get right (restart API = new object instance).

&gt; #9  I do feel that it is important to validate that the skip limit was the
&gt; reason for the job failure.  When I think of all of the ways people could code
&gt; a runtime like this up, we need to be sure we are being as explicit as possible
&gt; in validating the executed functionality.

So how would you propose validating this was the reason for failure?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12686</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 15:37:32 +0000</bug_when>
    <thetext>I&apos;m going to add one more shortcoming I found

13. Spec says &quot;The item-count attribute is ignored for &quot;custom&quot; checkpoint policy.&quot;    TCK should verify this... (I just tried this and the RI has a bug in this regard... it wrongly honors item-count).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12690</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 16:22:14 +0000</bug_when>
    <thetext>(In reply to comment #5)
&gt; Scott,
&gt; #1  I think I may see where I&apos;m going wrong on my understanding of this, but it
&gt; leaves, IMHO a more serious spec related issue.  It seems to me that these
&gt; tests are assuming on restart that the parameters provided in the last
&gt; execution will be re-applied in the new execution (What leads me to that is
&gt; that there is no null check on of the readrecordfailNumberString in the
&gt; DoSomethingArrayItemReaderImpl prior to the Integer.parseInt).  That can&apos;t
&gt; work.  It prevents you from removing a previously passed in value.  I&apos;ll take a
&gt; look to see if an issue is already opened on that and if not, open one.

Michael, thanks for noticing this.  Here at one time the RI/TCK + spec were in sync but have diverged.

The RI/TCK is indeed assuming that on restart you simply pass the &quot;override&quot; parameters, which are added/merged to the properties submitted on the original start.

The spec does not currently say that this is the correct behavior... so currently the RI/TCK is &quot;wrong&quot;.

I opened new Bug 4715 to track this question of how to treat this in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12696</commentid>
    <comment_count>9</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-25 18:30:34 +0000</bug_when>
    <thetext>With regards to both #3 and #9, if it&apos;s interesting enough to be in the spec, it needs to be tested.  If we have a behavior that we cannot validate via a test, that tells me that the user will be in the same trouble when trying to debug that behavior.

#3.  That being said, as long as the TCK validates the behavior thoroughly, I&apos;m ok with it.  

#9.  Within SB, we store the reason for a failure in the job repository so validation would be easier there.  For the TCK, what is the way the batch runtime is expected to communicate why it failed?  While failing a job is important, so is telling the user why.  This sounds like a miss in the spec...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14040</commentid>
    <comment_count>10</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-29 14:46:55 +0000</bug_when>
    <thetext>Looks to have been sufficiently addressed, and at least it seems clear there haven&apos;t been any spec issues raised (but not addressed).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4705</bug_id>
          
          <creation_ts>2013-02-23 02:33:00 +0000</creation_ts>
          <short_desc>TCK ContextGetIdTests issues</short_desc>
          <delta_ts>2013-03-18 06:17:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12674</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:33:18 +0000</bug_when>
    <thetext>1.  testJobContextGetId - How is the job1 set on the JobContext?  Why do we believe that it should be job1?
2.  testStepContextGetId - Same question only at the step level.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12760</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-08 04:37:53 +0000</bug_when>
    <thetext>Michael,

The naming has been changed with the description spelled out even more in PFD 1.5.

We&apos;ll now have:

public interface JobContext &lt;T&gt; {
	/**
	 * Get job name
	 * @return value of &apos;id&apos; attribute from &lt;job&gt;
	 */
	public String getJobName();


public interface StepContext &lt;T,P extends Serializable&gt; {	
	/**
	 * Get step name
	 * @return value of &apos;id&apos; attribute from &lt;step&gt;
	 * 
	 */	
	public String getStepName();

-------

Previously each of these two methods had been named simply getId().


In both cases though, they map simply to the @id attribute on &lt;job&gt;, and &lt;step&gt; respectively.

This is where the &apos;job1&apos; and &apos;step1&apos; values come from (in the corresponding JSL), uncreative as they may be.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4706</bug_id>
          
          <creation_ts>2013-02-23 02:39:00 +0000</creation_ts>
          <short_desc>TCK ExecutionTests issues</short_desc>
          <delta_ts>2013-08-29 14:25:08 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12675</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:39:51 +0000</bug_when>
    <thetext>1.  testInvokeJobWithOneBatchletStep, testInvokeJobWithTwoStepSequenceOfBatchlets, testInvokeJobWithFourStepSequenceOfBatchlets - Does not validate exit status (which would validate that the batchlet actually ran) of the job or the steps.
2.  testInvokeJobWithNextElement - Does not validate exit status or that the second step ran (job is flagged complete if either step2 runs to completion or step1 returns an exit status of ENDED as configured).
3.  testInvokeJobWithStopElement - Does not validate that the job stopped after the first step.
4.  testInvokeJobSimpleChunk - Does not validate that any chunk related processing was called (were reader/processor/writers actually called).
5.  testCheckpoint - How does this test verify checkpointing functionality?  Also, why does the ItemWriter in this test rely on the context&apos;s persistentUserData to store a good amount of the job&apos;s state (instead of relying on the checkpoint)?
6.  testSimpleFlow - job_flow_batchlet_4steps.xmlthe step2 should not have a next element configured.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12941</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 06:27:05 +0000</bug_when>
    <thetext>We did address point 6. which was an issue in a number of JSLs.  

Re: 5.  There is a story here.

You&apos;ve probably seen a lot of the pattern where the artifact is somehow parameterized by an &quot;execution number&quot; directing the batch artfact to blow up on execution 1, then complete on execution 2.

This allows us to do restart and some associated things (verifying we persist snd rehydrate checkpoint correcdtly, etc.).

For awhile we were passing in this execution # as a job param on start() with one value e.g. &quot;1&quot; and then overriding on restart() with a different value e.g. &quot;2&quot;

When restart properties went away for a time, we jumped on the persistent user data as a way to &quot;know&quot; which execution we were in.  We had the artifact &quot;increment&quot; a counter in persistent user data on each execution.

It&apos;s less natural to do that with checkpoint since you typically will see the same &quot;cursor&quot;/checkpoint values across both executions.

Anyway we still use persistent data in some tests..and in others we&apos;re back to using restart job param.

--
I realize I didn&apos;t address the other 4 comments...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12945</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 16:03:43 +0000</bug_when>
    <thetext>In response to Comment #1:

I&apos;m not sure that explains my question.  ExecutionTests#testCheckpoint doesn&apos;t do anything explicitly with the checkpoints.  There is no validation that they were taken or used in any way (unless I&apos;m missing something).  It runs the job once and the parameters passed in do not trigger any of the interesting conditions the job may run.  Finally, the writer seems to use the stepContext&apos;s persistent user data as a way to maintain the state of the writer.  Since this is really the responsibility of the checkpoint data, I think it&apos;s a bad idea to implement this test this way since it is confusing for anyone looking to the TCK as a form of documentation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12949</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 16:32:42 +0000</bug_when>
    <thetext>Michael,

I agree I didn&apos;t fully respond to your point.

I was just using it as an opportunity to explain a coding practice that might look particularly confusing... like I mentioned, it&apos;s partly to handle the period where we didn&apos;t have the ability to change restart parms, and we still employ this mechanism on other tests.

I didn&apos;t address your comment about checkpointing, nor #1-4 either...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14039</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-29 14:25:08 +0000</bug_when>
    <thetext>It looks like all of these could be considered enhancements.  There are no questions being raised about the spec behavior.  The comments are saying that the TCK should do a better job covering the spec assertions, but not claiming any incompatibility with the spec or flat out incorrect behavior.

This doesn&apos;t seem helpful to keep open as a &quot;bug&quot;, since we don&apos;t plan on updating the TCK in this way, (with new and tightened assertions).

However, if this information seems helpful to TCK consumers to better understand what the TCK does and doesn&apos;t enforce, we could maintain a reference to this type of information in a Wiki page.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4707</bug_id>
          
          <creation_ts>2013-02-23 02:42:00 +0000</creation_ts>
          <short_desc>TCK FlowTransitioningTests issues</short_desc>
          <delta_ts>2013-08-29 16:49:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12676</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:42:54 +0000</bug_when>
    <thetext>1. testFlowTransitionToStepOutOfScope - This test implies that &quot;parsing&quot; errors will result in a JobStartException.  Is that really the way we want to handle these (is that the way the spec does)?  That&apos;s a really obfuscated way of communicating that error.  This test also implies that the job would actually get a JobExecution in this scenario.  If the runtime cannot even parse the job, I don&apos;t think we should be providing a JobInstace/JobExecution.  That&apos;s like providing a jar file when your classes don&apos;t even compile.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12688</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-02-23 16:04:15 +0000</bug_when>
    <thetext>Michael,

You and I each made related points in &quot;Bug 4670&quot;.

I agree we shouldn&apos;t have a JobInstance/JobExecution.. but I&apos;d though JobStartException seemed like a natural choice in this case.

That does kind of put the TCK in front of the spec in specifying this... but on the other hand it might be hard to specify all the behaviors that should result in JobStartException/JobRestartException.

What do you think the TCK should do for something like this?

Fail with any exception?    Wait a few seconds and count that no new JobInstance/JobExecution for this job has been created???</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12694</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-25 17:41:02 +0000</bug_when>
    <thetext>Scott,

I guess the JobStartException is ok.  You could also make the argument for throwing a NoSuchJobException since if you cannot parse the XML, we don&apos;t know if a definition for the job exists.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14044</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-29 16:49:21 +0000</bug_when>
    <thetext>The spec (in Section 13.1) now requires either JobStartException or a FAILED execution, addressing this point.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4708</bug_id>
          
          <creation_ts>2013-02-23 02:44:00 +0000</creation_ts>
          <short_desc>TCK JobAttributeAbstractTests Issues</short_desc>
          <delta_ts>2013-03-18 06:16:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12677</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:44:30 +0000</bug_when>
    <thetext>Since inheritance is being dropped, this test should be removed from the TCK as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12684</commentid>
    <comment_count>1</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-02-23 03:06:21 +0000</bug_when>
    <thetext>(In reply to comment #0)
Is Job XML inheritance dropped completely, or just some part of it?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12940</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 06:16:38 +0000</bug_when>
    <thetext>Removed</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4709</bug_id>
          
          <creation_ts>2013-02-23 02:47:00 +0000</creation_ts>
          <short_desc>TCK JobExecutableSequenceTests Issues</short_desc>
          <delta_ts>2013-08-28 21:53:09 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12678</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:47:01 +0000</bug_when>
    <thetext>1. testJobExecutableSequenceToUnknown - Why is this job runnable?  I would expect this job to fail prior to start due to the unreachable step (instead of starting and processing before figuring out that it has a step that can&apos;t be reached).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14032</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 21:53:09 +0000</bug_when>
    <thetext>This test checks for either JobStartException or FAILED execution, the choices specified in Sec 13.1, &quot;Validation Rules&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4710</bug_id>
          
          <creation_ts>2013-02-23 02:48:00 +0000</creation_ts>
          <short_desc>Consider clarifying that JobContext/StepContext may contain implementation-specific properties other than JSL properties.</short_desc>
          <delta_ts>2014-01-07 18:54:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>DUPLICATE</resolution>
          <dup_id>5490</dup_id>
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>1.0_mr_planned</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12679</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:48:28 +0000</bug_when>
    <thetext>1. testJobLevelPropertiesCount - This test implies that the JobContext.getProperites can *only* return properties configured and that properties object cannot be used by the runtime for anything else.  I&apos;m not sure the spec is specific enough to rule that usage out (and would rather it not).
2. testJobLevelPropertiesPropertyValue - While this test is probably good enough, it would be nice to test the values for all three properties...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12758</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-07 19:47:25 +0000</bug_when>
    <thetext>Chris,

Assigning this over to you for point #1 here... 

I think allowing runtime-specific properties in the JobContext and StepContext seems like a useful thing to do.   

On the other hand, it seems to me the most obvious reading of the current wording is that you get just what you see in the corresponding JSL, and so therefore testing for these and ONLY these properties is an appropriate TCK test.

I think to allow additional runtime-specific properties we should simply add language to the spec saying this is possible..then we&apos;ll go back and review the JobLevelPropertiesTests/StepLevelPropertiesTests test methods.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12998</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-20 14:35:47 +0000</bug_when>
    <thetext>The runtime may insert properties in the JobContext and StepContext properties objects.  The spec does not say so, neither does it prohibit.  

I have asked Scott to revise the test case to not preclude runtime properties.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14866</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 18:54:10 +0000</bug_when>
    <thetext>Resolve together with Bug 5490.

*** This bug has been marked as a duplicate of bug 5490 ***</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4711</bug_id>
          
          <creation_ts>2013-02-23 02:51:00 +0000</creation_ts>
          <short_desc>TCK JobOperatorTests Issues</short_desc>
          <delta_ts>2013-03-18 19:38:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12680</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:51:44 +0000</bug_when>
    <thetext>1. testJobOpGetJobNames - The number of names returned isn&apos;t verified.
2. testJobOpgetJobInstanceCount - Should the job fail if a NoSuchJobException is *not* thrown?  Seems non-deterministic
3. testJobOpgetJobInstanceCountException - Test does not fail if the exception at the end is *not* thrown.
4. testJobOpgetJobInstances - The assertWithMessage in the bottom try/catch is confusingyou are catching a NoSuchJobExceptionyet expect the exception to not be an instance of it (probably should be catching Exception)?  Also, there is no validation that the exception did (or did not) occur.  Finally, I would expect the size of the jobInstances list to be determinant (not just &gt; 0).
5. testJobOpgetJobInstancesException - While the assert within the catch is redundant, there is also no validation that the exception is actually thrown (what happens if it&apos;s not)?
6. testJobOperatorGetParameters - This test uses the JobInstance to get the parametersthe spec says it should be the JobExecution.  The parameters returned are never validated.
7. testJobOperatorGetJobInstance - The JobInstance returned is not validated in any way other than it was the correct type (which would have thrown a ClassCastException anyways).
8. testJobOperatorGetRunningJobInstances - Why is this checking &gt; 0 instead of 2?
9. testJobOperatorGetRunningJobInstancesExeception - Does not validate the exception was thrownjust that if it was, it was the correct one.
10. testJobOperatorGetJobExecution - Does not validate any of the data within the returned JobExecution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12939</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 06:03:15 +0000</bug_when>
    <thetext>Michael,

Thanks for the review, and sorry for just getting around to it (but I was just fixing something else in this class so got back to your comments). 

You made some good points... and actually there were a couple other things we didn&apos;t test like JobExecutionAlreadyCompleteException, JobExecutionNotMostRecentException too. 
To your points (the fixed one should be out tomorrow):

1. Fixed (or improved, see 2. below).

2. It&apos;s a good question, but no it should not.  The reason is we don&apos;t require a clean job repository to run the TCK.   I don&apos;t think it&apos;s important enough to force that.  We don&apos;t have a &quot;cleanup from TCK&quot; routine of any form..... so it&apos;s better this way.

3. Fixed 

4. Fixed.  Made me realize an unspec&apos;d detail.. if you ask for 12 and there are only 10, it&apos;s up to the implementation to decide what to do...

5. Fixed 
6. Fixed 

7. I can&apos;t find this method.. did some cleanup here including fixing all the &quot;instanceof&apos; checks and making sure we were verifying that we had seen exceptions and failing if we hadn&apos;t... you&apos;ll have to let me know if you still see an issue

8. It&apos;s just a tradeoff between being more strict and avoiding &quot;false positives&quot; by failing due to a timing window when there&apos;s nothing wrong with the runtime.  We&apos;ve got some buffer built in, true...but say you forgot to implement the API.. you&apos;d fail then so the test does serve a purpose.

9. Fixed

10.  Maybe we don&apos;t even need this test... we do plenty of looking at JobExecution(s).

-----

One other note, I changed some of these from blocking to non-blocking, i.e. look at instance count immediately.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12962</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-03-18 19:24:21 +0000</bug_when>
    <thetext>With regards to number 8, this test has changed a bit now and I&apos;m not sure how it accomplishes the goal of validating the JobOperator#getRunningJobInstances.  Now it would pass if the jobOp.getRunningExecutions(&quot;JOBNAMEDOESNOTEXIST&quot;); call throws an exception, but won&apos;t fail if it doesn&apos;t.  Also, because this method now is just checking for that exception, running any jobs before the call is pointless.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12963</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-03-18 19:38:16 +0000</bug_when>
    <thetext>I&apos;m marking this fixed... we also fixed #8 to ONLY pass if the execption is caught.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4712</bug_id>
          
          <creation_ts>2013-02-23 02:53:00 +0000</creation_ts>
          <short_desc>TCK ParallelExecutionTests Issues</short_desc>
          <delta_ts>2013-09-06 19:19:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12681</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:53:53 +0000</bug_when>
    <thetext>1. testInvokeJobWithOnePartitionedStep, testStopRunningPartitionedStep, testStopRestartRunningPartitionedStep - How does this test that anything other than a successful run happened (does not validate that any partitioning or parallel execution of any kind actually occured)?
2. testStopRestartRunningPartitionedStep - Doesn&apos;t validate that the state of the job is maintained between runs.
3. testInvokeJobSimpleSplit - job_split_batchlet_4steps has an invalid next element in it so the job shouldn&apos;t even start.  This test does not validate that anything is executed in parallel.
4. testPartitionedCollectorAnalyzerReducerChunkRestartItemCount10 - Does not validate that any parallization occurs.  Does not validate what partitions failed vs didnt.  Also does not validate that the job failed for the expected reason.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14101</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-06 14:09:47 +0000</bug_when>
    <thetext>I realize this is not exactly a timely response.  Still, since you took the trouble to post I wanted to complete with a review.  

There are no spec issues, just arguments that the tests could have been more thorough.   

The first point I&apos;ll address is the thought we should have tested that  parallel execution really occurs (I assume you mean, e.g., look for interleaved timestamps).   

Maybe we didn&apos;t publicize this enough but we decided to stick to the letter of the spec, which doesn&apos;t prevent an implementation from using a single thread serially to execute each of a step&apos;s partitions. 

(Though as we just discussed yesterday, coincidentally, we do assume you have at least two threads in that the job executes on a different thread than the JobOperator client).

Replying to the rest of your points:

1. Agree these tests are performing very minimal checks.  Maybe stop is a bit interesting in that, assuming the impl is partitioning, we&apos;re forcing you to confirm that you view the overall job is stopped.  But even for this one, and for the others, there&apos;s no checking that we are indeed running partitions.  

2. Not sure what you meant by &quot;state of the job&quot; not being maintained.   I&apos;ll make the observation that it would have been much better to test that the persistent data was maintained across the restart.  This is non-trivial since each partition is supposed to get its own copy of the persistent user data.  Too bad we didn&apos;t include that here, as I don&apos;t see it in the later tests either.

Another miss: we probably should have forced the issue in confirming that setting the exit status on a partition thread has no bearing on the job&apos;s exit status.  The JobContext is just a thread local copy.    You noticed this behavior in splits and were a bit surprised by it, so it&apos;s clearly non-trivial and would have been nice to cover.  (I don&apos;t see us covering this elsewhere).

3. The invalid @next has been removed

4. I see your point that the test could indeed pass if any two partitions were to resume and then execute a single chunk (really only partitions #1 and #2 should restart but never partition #0).

Still, this let us test more easily and I&apos;d guess most implementations that pass will have indeed implemented this correctly, though it would have been even better to verify as you mentioned.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4713</bug_id>
          
          <creation_ts>2013-02-23 02:55:00 +0000</creation_ts>
          <short_desc>TCK TransactionTests Issues</short_desc>
          <delta_ts>2013-08-29 16:44:37 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12682</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:55:26 +0000</bug_when>
    <thetext>1. testTranRollbackRetryReadSkipRead, testTranRollbackRetryProcessSkipProcess, testTranRollbackRetryWriteSkipWrite - I don&apos;t see where the actual verification of the transaction being rolled back, chunk size changed, etc are verified.  I only see the verification of the listeners being called (which is already addressed in other tests).
2. testGlobalTranForcedTimeoutCheckpointRestart - Does not validate a new execution is created (not 100% sure that it&apos;s needed...but still).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14043</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-29 16:44:37 +0000</bug_when>
    <thetext>It would have been good to include a test for the use of chunk size of 1 on a retry with rollback.  That does not seem to have been included.  But that doesn&apos;t affect the spec so I&apos;m closing this out.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4714</bug_id>
          
          <creation_ts>2013-02-23 02:56:00 +0000</creation_ts>
          <short_desc>TCK does not validate artifact creation behavior</short_desc>
          <delta_ts>2013-08-28 21:49:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12683</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-02-23 02:56:53 +0000</bug_when>
    <thetext>The spec requires that the artifacts (ItemReaders, etc) are created as the steps that use them are executed.  There are no tests (from what I can tell) that verify this behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14031</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-08-28 21:49:02 +0000</bug_when>
    <thetext>Can&apos;t remember all the context here.

The spec now says in Sec 11.1: 

&quot;All batch artifacts are instantiated prior to their use in the scope in which they are declared in the Job XML and are valid for the life of their containing scope.&quot;

So the comment doesn&apos;t seem to apply.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4724</bug_id>
          
          <creation_ts>2013-02-27 22:05:00 +0000</creation_ts>
          <short_desc>SPEC: Remove listeners from split and flow elements in jsl xsd</short_desc>
          <delta_ts>2013-03-01 19:42:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cvignola</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12710</commentid>
    <comment_count>0</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-02-27 22:05:23 +0000</bug_when>
    <thetext>listeners have been removed from these elements in the spec;  jsl xsd needs to be updated</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12742</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-01 19:42:27 +0000</bug_when>
    <thetext>Updated in PFD v1.5</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4733</bug_id>
          
          <creation_ts>2013-03-05 20:38:00 +0000</creation_ts>
          <short_desc>RI ItemProcessor need to be optional, throws NPE</short_desc>
          <delta_ts>2013-08-28 21:32:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>arungupta</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12754</commentid>
    <comment_count>0</comment_count>
    <who name="">arungupta</who>
    <bug_when>2013-03-05 20:38:51 +0000</bug_when>
    <thetext>ItemProcessor is optional but Batch RI integrated in GlassFish 4
throws the following exception:

Caused by: java.lang.NullPointerException
    at
com.ibm.batch.container.impl.ChunkStepControllerImpl.initializeChunkArtifacts(ChunkStepControllerImpl.java:717)
    at
com.ibm.batch.container.impl.ChunkStepControllerImpl.invokeCoreStep(ChunkStepControllerImpl.java:645)
    at
com.ibm.batch.container.impl.BaseStepControllerImpl.execute(BaseStepControllerImpl.java:156)
    ... 6 more</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4734</bug_id>
          
          <creation_ts>2013-03-06 07:57:00 +0000</creation_ts>
          <short_desc>RI maven sources.jar is empty</short_desc>
          <delta_ts>2013-03-11 18:42:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>romain_grecourt</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>12755</commentid>
    <comment_count>0</comment_count>
    <who name="">romain_grecourt</who>
    <bug_when>2013-03-06 07:57:12 +0000</bug_when>
    <thetext>The sources.jar published on maven should *not* be empty.
This is used to produce the combined EE API bundles (API / Javadoc).

There should not be any specific layout inside the sources.jar bundle.
e.g.

jar -tvf ~/Downloads/javax.security.jacc-api-1.4-sources.jar 
     0 Mon Mar 04 19:21:00 CET 2013 META-INF/
   125 Mon Mar 04 19:20:58 CET 2013 META-INF/MANIFEST.MF
     0 Mon Mar 04 19:20:50 CET 2013 javax/
     0 Mon Mar 04 19:20:50 CET 2013 javax/security/
     0 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/
 36116 Mon Mar 04 19:20:56 CET 2013 META-INF/LICENSE.txt
 12005 Mon Mar 04 19:20:54 CET 2013 pom.xml
 22217 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/EJBMethodPermission.java
  8309 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/EJBRoleRefPermission.java
 11127 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/HttpMethodSpec.java
  2122 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/package.html
 27320 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/PolicyConfiguration.java
 11243 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/PolicyConfigurationFactory.java
 13850 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/PolicyContext.java
  4671 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/PolicyContextException.java
  6395 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/PolicyContextHandler.java
  7790 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/URLPattern.java
 13291 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/URLPatternSpec.java
 18033 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/WebResourcePermission.java
  8574 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/WebRoleRefPermission.java
 22987 Mon Mar 04 19:20:50 CET 2013 javax/security/jacc/WebUserDataPermission.java</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12812</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-03-11 18:42:43 +0000</bug_when>
    <thetext>I believe this is fixed in the update.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4991</bug_id>
          
          <creation_ts>2013-05-11 03:37:00 +0000</creation_ts>
          <short_desc>Add Java Based JSL</short_desc>
          <delta_ts>2016-03-17 17:13:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>reza_rahman</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>rmannibucau</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13326</commentid>
    <comment_count>0</comment_count>
    <who name="">reza_rahman</who>
    <bug_when>2013-05-11 03:37:38 +0000</bug_when>
    <thetext>It would be very useful for a future version of the specification to add support for a type-safe Java JSL like the following:

@Produces
public Job buildJob() {
    return JobBuilder
        .newJob(&quot;myJob&quot;)
        .addStep(&quot;sendStatements&quot;)
        .addChunk()
        .reader(AcountReader.class)
        .processor(AccountProcessor.class)
        .writer(EmailWriter.class)
        .itemCount(10);
}

This would be more dynamic, fluent and readable than the current XML JSL.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13327</commentid>
    <comment_count>1</comment_count>
    <who name="">reza_rahman</who>
    <bug_when>2013-05-11 03:53:02 +0000</bug_when>
    <thetext>Do let me know if anything needs to be explained further - I am happy to help.

Please note that these are purely my personal views and certainly not of Oracle&apos;s as a company.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14163</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 17:43:08 +0000</bug_when>
    <thetext>Spring Batch provides a similar configuration option using job and step builders (instead of a single builder as proposed previously).  You can read more about it here: http://docs.spring.io/spring-batch/reference/html/configureJob.html#javaConfig</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19110</commentid>
    <comment_count>3</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:08:44 +0000</bug_when>
    <thetext>+1, only open points for me are:

- do we use typed blocks (end of a chunk ends with end() or done() to go back upper level), think it is better to do so to avoid to mess options (typically properties can be messy if not done)
- not explicit but properties should be typed (property(&quot;mySuperProperty&quot;, new MyValue()) to get @Inject @BatchProperty MyValue value)
- Do we use @Produces or a batch event where we can register jobs (I prefer this last option, ie void addMyBatches(@Observers BatchRegistration br) { br.newJob(&quot;myJob&quot;)....; })</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19230</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-21 16:10:47 +0000</bug_when>
    <thetext>So first, I think this is a fair topic to consider for 1.1.

Looking back at the mailing list discussions ( and some of the earlier EG minutes), e.g. discussion starting here:

https://java.net/projects/jbatch/lists/public/archive/2012-03/message/29

It&apos;s clear that the EG did not reject the idea (which would mean we really should only reconsider in a new JSR with a new EG), but simply de-prioritized, recognizing the complexity.

I think a key question of direction is whether we intend this to be a full, parallel job definition mechanism, or only one usable for some simple subset or special cases.

As I start to think through the &quot;full, parallel&quot; mechanim, it seems some cases wouldn&apos;t end up that much simpler than using the standard JAXB model (OK, maybe you&apos;d cut out some intermediate objects along the way).

So I think my point is:  what are we really getting out of this API?  Is it more about keeping simple cases as simple as possible?   Or are there more specific Java patterns we&apos;re enabling in doing so?  E.g the type-checking in Reza&apos;s original example.  Or is it the ability to start the job &quot;anonymously&quot; by-reference handed back from the builder (which could conceivably be added in a new JobOperator method:  startInline(String,Properties)?   

One thing to be wary about in doing only a subset:  assuming we might one day want to expand to the full JSL-based definition capability, we probably want to consider how this should be done for future compatibility.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19823</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 17:13:06 +0000</bug_when>
    <thetext>Closing this:  no one&apos;s working on this actively, plus I personally consider it unlikely we&apos;ll get to it, plus there&apos;s not a huge amount of specific detail that will be abandoned in closing this.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5164</bug_id>
          
          <creation_ts>2013-06-28 07:28:00 +0000</creation_ts>
          <short_desc>JobContext.getExecutionId() returns wrong value (an internal value) when invoked on a partition thread.</short_desc>
          <delta_ts>2015-10-06 16:38:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jimnicolson</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>13620</commentid>
    <comment_count>0</comment_count>
    <who name="">jimnicolson</who>
    <bug_when>2013-06-28 07:28:47 +0000</bug_when>
    <thetext>PROBLEM

Starting with a partitioned batch job utilising a valid PartitionMapper, and using the code below:
 

	@Inject
	private JobContext jobContext;		

	....

	JobOperator jobOperator = BatchRuntime.getJobOperator();
	jobParameters = jobOperator.getParameters(jobContext.getExecutionId());

in methods of each of 

	PartitionReducer
	PartitionCollector
	PartitionAnalyzer

Then 	

	System.out.println/logger.info of (jobParameters) will show an empty properties (lookups also return null)

For the following methods

	PartitionReducer beginPartitionedStep (Expected)

	PartitionAnalyzer analyzeCollectorData
	PartitionAnalyzer analyzeStatus
	PartitionReducer beforePartitionedStepCompletion
	PartitionReducer afterPartitionedStepCompletion

NOTES:

1.	Other Partition* class methods *do* receive a populated JobOperator.getParameters()
2.	It makes no difference if the PartitionMapper properties were added using Properties get or Properties setProperty()
3.	If an initial property is passed in on job start e.g..

	JobOperator jo = BatchRuntime.getJobOperator();
	Properties properties = new Properties();
	
	properties.setProperty(&quot;TEST_PROP&quot;, &quot;TEST_PROP_VALUE)&quot;);

	long jobId = jo.start(jobName, properties);

This property *will* be present in the methods above (but still no PartitionMapper created properties)

ENVIRONMENT

Oracle Linux 6.3 64 bit
Java(TM) SE Runtime Environment (build 1.7.0_21-b11)
Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)

GlassFish Server Open Source Edition 4.0 (build 89) - Standalone / Run On Server (Eclipse Juno)
org.glassfish.main.extras:glassfish-embedded-all:4.0 - Arquillian / Maven 3.0.4

EXAMPLE PROJECT ATTACHED</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13621</commentid>
    <comment_count>1</comment_count>
      <attachid>85</attachid>
    <who name="">jimnicolson</who>
    <bug_when>2013-06-28 07:30:08 +0000</bug_when>
    <thetext>Created attachment 85
Exported Eclipse project with example batch job / maven POM / JARs</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13624</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-06-28 15:13:27 +0000</bug_when>
    <thetext>Looks to me here&apos;s a bug here, but that this use case is not actually supported
by the spec API. You were making use of a bug combined with an implementation-specific detail.

The root cause is that the partition threads&apos; JobContext.getExecutionId() does not return the &quot;top-level&quot; JobExecution&apos;s id.

Rather, it returns an id that the RI generates as an implementation-detail (in order to track the partition execution in a similar way as the way in which we track the top-level job execution).

To make matters more confusing, we then make use of jobParameters for the partition-level object by stuffing the partition properties into them. 

So for the collector, which runs on the partition threads, you are able to see these partition properties purely as an implementation detail (by way of this internal-only execution id as I mentioned). 

For the reducer/analyzer, which run on the main thread, you are actually dealing with the true, correct execution id of the top-level...  For this id, jobOperator.getParameters() correctly returns only the Properties object passed into job start/restart.

So I&apos;d suggest:

1) We leave this open as a bug, but change the description to:  wrong executionId returned by JobContext.getExecutionId() 

2) Maybe you could email the public ML for help in accomplishing your original design goal.

Thanks,
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>13633</commentid>
    <comment_count>3</comment_count>
    <who name="">jimnicolson</who>
    <bug_when>2013-06-28 23:11:14 +0000</bug_when>
    <thetext>Hi Scott

Thanks. Ok with the title change - do you do this or do I (sorry newbie to the Bugzilla process). Never even thought to check Execution Id.

I completely agree about having the PartitionProperties in the Parameters collection in JobContext. I found this very strange. I would have expected to find them as an explicit PartitionProperties or Partition &apos;obbject&apos; field in the StepContext.

Actually the &apos;use case&apos; was simple. I was tracing the logic to verify the processing sequence. Still learning the API.

I had found a need to have a Partition Number. I had to create a property in the PartitionMapper processing. Initially to append to output filenames and then was using it in log messages for tracing.

Hence, I found the inconsistency. Actually, may not be a defined use case but it does seems to me that all information relating to the step shoould be available until the step has finished.

Regards
Jim Nicolson</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19060</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 20:58:49 +0000</bug_when>
    <thetext>This is resolved from an RI perspective.

I&apos;m going to reclassify as &quot;TCK&quot; and leave this open until we add a TCK test.  This was a big gap which caused confusion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19302</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-06 16:37:59 +0000</bug_when>
    <thetext>Closing after new test additions in:
https://github.com/WASdev/standards.jsr352.tck/commit/5323f5ad62d72c9b618c8fef214e96212730ed0c</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>85</attachid>
            <date>2013-06-28 07:30:00 +0000</date>
            <delta_ts>2013-06-28 07:30:08 +0000</delta_ts>
            <desc>Exported Eclipse project with example batch job / maven POM / JARs</desc>
            <filename>nicolson-research-jee7-batch-issue-gf-nnnn.zip</filename>
            <type>application/zip</type>
            <size>79876</size>
            <attacher>jimnicolson</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>5335</bug_id>
          
          <creation_ts>2013-08-29 16:06:00 +0000</creation_ts>
          <short_desc>Metrics timestamp assertions should be loosened with a precision buffer</short_desc>
          <delta_ts>2013-11-05 19:05:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14041</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-08-29 16:06:37 +0000</bug_when>
    <thetext>See discussion on the public mailing list, where the last post was:
https://java.net/projects/jbatch/lists/public/archive/2013-08/message/20</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14453</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-04 17:20:48 +0000</bug_when>
    <thetext>This is a whole lot of verbiage over a small, simple change, but given how long it took to deliver, figured I&apos;d post this code for review before re-publishing TCK in case I missed something.  

I&apos;m planning on adding a &quot;-1 second&quot; buffer into the comparison.

I know an obvious approach would be to provide a configurable precision value.
I think we&apos;re unlikely to need that, and if we do I&apos;d like to understand why better anyway.  Plus then I&apos;d have to maintain what is the &quot;officially-allowed precision range&quot; and maintain that as doc.. so I didn&apos;t.

(You could argue the test is too loose already but at least it enforces that the API is actually implemented in the ballpark sense instead of altogether forgotten.)

If I don&apos;t hear any comments (e.g. from Michael, who raised the issue, we&apos;ll ship this).

Remember the Date(s) are both returned by the API as well as constructed by the tests via:
  long time = System.currentTimeMillis();
  Date ts = new Date(time);

--- Key part of the fix, in code ---
/*
* We want to confirm that &apos;d1&apos; is roughly before &apos;d2&apos;, and also to
* allow for the fact that dates may be stored with a loss of precision.
* 
* Let&apos;s assume then that we only have whole seconds precision (without
* necessarily accounting for any fractional seconds).
* 
* So we can&apos;t simply perform d1 &lt; d2, or even d1 &lt;= d2 (the inclusion of &apos;equals&apos; 
* corrects for a different problem, the problem of running so fast that
* the times for d1 and d2 are the same even though d1 may still have
* been executed first).
* 
* The &quot;worst&quot; case (in terms of highest rounding error), then, is that &apos;d1&apos; gets
* rounded up while &apos;d2&apos; gets rounded down, leaving the rounded &apos;d1&apos; value a full 
* second higher than the rounded &apos;d2&apos; value.
* 
* Therefore we check that d2 minus d1, which before rounding should be &gt;= 0, is
* instead no less than -1000 (1 second).
*/
private static boolean roughlyOrdered(Date d1, Date d2) {
    long time1 = d1.getTime();
    long time2 = d2.getTime();

    long diff = time2 - time1;

    return diff &gt;= -1000 ? true : false;
}</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5370</bug_id>
          
          <creation_ts>2013-09-09 15:27:00 +0000</creation_ts>
          <short_desc>Spec is unclear whether JobOperator methods may/must execute synchronously or not (with TCK implications)</short_desc>
          <delta_ts>2015-09-03 21:07:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>1.0_mr_pending</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>BrentDouglas</cc>
    
    <cc>cf126330</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>radcortez</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14109</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 15:27:09 +0000</bug_when>
    <thetext>Opening this as discussed on our ML with subject &quot;JobOperator synchronous execution and the TCK&quot;.

We could decide to leave the spec alone in which case I think we would then only need a change to the TCK.

However, I&apos;d propose another round of discussion and then making the results clear in the spec, along with a TCK fix.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14160</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 17:05:52 +0000</bug_when>
    <thetext>I&apos;d advocate for an implementation specific option for configuring asynchronous JobOperator behavior for start/restart and make the default synchronous.  This allows the simple use case (kick off a job and wait for it to finish) as the default option with each implementation providing an appropriate way to configure asynchronous options (Spring would use a TaskExecutor, other implementations may use a ThreadPoolExecutor/etc).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14379</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-28 21:53:41 +0000</bug_when>
    <thetext>I propose we deal with this by clarifying that start/restart are asynch from the spec point of view.  

The question of whether an API executes in a blocking/non-blocking manner is a fundamental issue in specifying a portable programming model, especially in an environment like an EE server where threads are always carefully-managed resources.  If the spec needs synch and asynch capabilities we should go ahead and add them to a future release, not leave it up to an implementation-specific mechanism to decide which to use. 

The closest we came to nailing this down was in bug 4110.   Unfortunately, Chris as spec lead only thought that JobOperator#stop() needed clarification explicitly proclaiming this an asynch() method, and did not go ahead and update the start/restart methods accordingly.

All I can really point to in the spec is this in JobOperator#start

* Creates a new job instance and starts the first execution of that
* instance. 

though I think this does suggest asynch over synch.   

The TCK was built on the assumption of asynch execution.    Even in its early forms, the TCK has been built assuming an asynchronous start/restart.  This is why we originally were going to require the implementation provide a callback mechanism.  With Cheng&apos;s help, we reworked this through the public ML into the JobExecutionWaiter SPI to allow for polling of job completion.   

It&apos;s not that the TCK couldn&apos;t be re-engineered to accommodate synchronous start/restart... again, it&apos;s that I think the behavior should be the same across implementations.

Perhaps SpringBatch could do something like:  run the TCK in &quot;asynch&quot; mode to achieve compliance, and then factor &quot;synch&quot; mode as an extension?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14380</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-28 22:28:13 +0000</bug_when>
    <thetext>Scott,

We have a few objections with defaulting to async for the JobOperator&apos;s start/restart behavior.  Specifically:

1.  There isn&apos;t any use of the full JobExecution being returned by the JobOperator if the execution is async.  It will always be in the &quot;STARTING&quot; state and essentially useless.  If the behavior would have been intended to be async from the start, I would have advocated for just returning just the JobExecution id instead.
2.  When you consider most API calls, async as a default is not a normal use case.  Servlets, EJB calls, JDBC, etc.  All of these are sync by default.  I don&apos;t see a precedent within java where this type of behavior should be async by default.  SB has taken the approach that the JobOperator is configured by default to execute the job synchronously (we believe the more intuitive approach from a consumer&apos;s perspective) and allow the user to configure it to be async by overriding our TaskExecutor via Spring injection.
3.  You mention &quot;run the TCK in &quot;asynch&quot; mode to achieve compliance, and then factor &quot;synch&quot; mode as an extension?&quot;  This brings up a separate question about the TCK.  How does an implementation specify impl specific options for executing the TCK (beyond tweaking the properties the TCK already uses)?  I have been running under the assumption that we couldn&apos;t add anything for the TCK&apos;s execution (only defaults would be used).  If this is not the case, it should be documented what is and is not allowed from a customization perspective for an impl to do, yet still be considered passing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14381</commentid>
    <comment_count>4</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-10-29 03:17:55 +0000</bug_when>
    <thetext>At the beginning of the spec, it says &quot;Batch processing is typified by bulk-oriented, non-interactive, background execution.&quot; By calling it background execution, although not a hard requirement, I guess it sets the direction for the entire spec. I automatically assumed async model, though by hindsight, I can see synchronous execution also has its value.

If we look at the key verbs in batch, &quot;start&quot; and &quot;stop&quot;, java developers can easily relate to java thread lifecycle and execution, which implies asynchrony. Due to the fundamental difference than other Java EE applications, I guess async model won&apos;t necessarily be a surprise.

I prefer to have async model as the default. In future releases add portable mechanisms for the client to switch to synchronous execution.  For example, add a method:

long start(String jobName, Properties jobParams, boolean synchronousExecution);

Both start and restart method currently do return a job execution id of type long.

As for which modifications are allowed in TCK testing, just to share my experience.  Users should only be allowed to modify jsr352-tck.properties (to change jsr352.impl.classes, various sleep time, and jvm.options). jvm.options can be used to pass in varios options to the target batch runtime.  The installation of an batch implementation typically also include some config files to customize its behavior, for instance, bin/jberet.properties.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14502</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-06 19:43:42 +0000</bug_when>
    <thetext>(In reply to mminella from comment #3)

Michael, I&apos;m still thinking about this issue, but let me address a couple of your points in the meantime:

&gt; We have a few objections with defaulting to async for the JobOperator&apos;s
&gt; start/restart behavior.  Specifically:
&gt; 
&gt; 1.  There isn&apos;t any use of the full JobExecution being returned by the
&gt; JobOperator if the execution is async.  It will always be in the &quot;STARTING&quot;
&gt; state and essentially useless.  If the behavior would have been intended to
&gt; be async from the start, I would have advocated for just returning just the
&gt; JobExecution id instead.

The return type from start/restart is indeed &apos;long&apos;.  It is only the TCK&apos;s wrapper which returns a JobExecution.  

The purpose of the wrapper is to reduce boilerplate code waiting for an execution to complete, given that the TCK assumed execution was asynchronous.
A further purpose is to allow an implementor to introduce their own mechanism to signify the job is done executing (i.e. COMPLETED, FAILED, STOPPED) in case a means other than the TCK&apos;s built-in polling mechanism is preferred (e.g. a callback).

So, indirectly, I think we&apos;re agreeing the use of &apos;long&apos; return type rather than JobExecution suggests asynch execution.


&gt; 2.  When you consider most API calls, async as a default is not a normal use
&gt; case.  Servlets, EJB calls, JDBC, etc.  All of these are sync by default.  I
&gt; don&apos;t see a precedent within java where this type of behavior should be
&gt; async by default.  SB has taken the approach that the JobOperator is
&gt; configured by default to execute the job synchronously (we believe the more
&gt; intuitive approach from a consumer&apos;s perspective) and allow the user to
&gt; configure it to be async by overriding our TaskExecutor via Spring injection.

Agreed, synch is the default in Java in general.  The thought that async as default was &quot;obvious&quot; in a batch context has obviously been proved incorrect.

&gt; 3.  You mention &quot;run the TCK in &quot;asynch&quot; mode to achieve compliance, and
&gt; then factor &quot;synch&quot; mode as an extension?&quot;  This brings up a separate
&gt; question about the TCK.  How does an implementation specify impl specific
&gt; options for executing the TCK (beyond tweaking the properties the TCK
&gt; already uses)?  I have been running under the assumption that we couldn&apos;t
&gt; add anything for the TCK&apos;s execution (only defaults would be used).  If this
&gt; is not the case, it should be documented what is and is not allowed from a
&gt; customization perspective for an impl to do, yet still be considered passing.

That suggestion seems confusing and I think it&apos;s incomplete.   

What I was trying to get at here was simply the idea that we all decide to agree asynch is the standard behavior and an implementation will run the TCK against it (with asynch behavior, accordingly).

I didn&apos;t mean to get into the details of &quot;modes&quot; of TCK execution for a given implementation.  I was just suggesting:  provide the synch behavior however you want, just as long as we recognize it&apos;s non-standard.

However, even better I think would be to look ahead and consider the how we could provide a portable synch behavior, alongside a portable asynch behavior.   

Would you care to share a proposal then, based on your experience?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14503</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-06 19:47:30 +0000</bug_when>
    <thetext>(In reply to cf126330 from comment #4)
&gt; At the beginning of the spec, it says &quot;Batch processing is typified by
&gt; bulk-oriented, non-interactive, background execution.&quot; By calling it
&gt; background execution, although not a hard requirement, I guess it sets the
&gt; direction for the entire spec. I automatically assumed async model, though
&gt; by hindsight, I can see synchronous execution also has its value.

Yes, we assumed the same, and I agree this is the closest the spec comes to stating this explicitly.... though not explicitly enough.

&gt; As for which modifications are allowed in TCK testing, just to share my
&gt; experience.  Users should only be allowed to modify jsr352-tck.properties
&gt; (to change jsr352.impl.classes, various sleep time, and jvm.options).
&gt; jvm.options can be used to pass in varios options to the target batch
&gt; runtime.  The installation of an batch implementation typically also include
&gt; some config files to customize its behavior, for instance,
&gt; bin/jberet.properties.

Yes, I think Cheng&apos;s answer is more or less complete:  you&apos;re allowed to change the values in &apos;jsr352-tck.properties&apos; (though I&apos;d like to reserve the right to tweak my answer slightly later in case of an unforseen situation).

But if you have any questions at all about what can and cannot be modified in order to pass the TCK, please ask in a separate email.  We can discuss as well as collect the question on one of the TCK-related Wiki pages.

Thanks,</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14572</commentid>
    <comment_count>7</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-14 22:02:12 +0000</bug_when>
    <thetext>&quot;Would you care to share a proposal then, based on your experience?&quot;

When I think of APIs that provide both sync/async options or even thread safe vs not thread safe options, I can&apos;t think of many scenarios where you just add a parameter and you get one version or another.  There isn&apos;t a PreparedStatement#executeUpdate(boolean async) method for example that runs your query asynchronously if you pass in true.  You typically are dealing with a completely different class or group of classes when you move from sync to async.  

The way the JobOperator currently works with Spring Batch is that we use a TaskExecutor to execute the job.  By default, we use a SyncTaskExecutor but allow the user to inject an async implementation if desired (using standard Spring DI).  Obviously this is a very Spring specific example, but it brings me to my point which is that the ability to provide a pluggable way to switch implementations won&apos;t be easy and I wouldn&apos;t advocate for it as part of the 1.0 spec.  The barriers to this are two fold:

  1. Finding an abstraction that works in all environments for a Executor/WorkManager/etc type of feature.
  2. Determining how to apply that abstraction to the JobOperator in a consistent manor.  The fact that the factory that provides the JobOperator (BatchRuntime) is a class instead of an interface, prevents any implementation specific customization to handle something like choosing which implementation to provide.

I&apos;m not saying that these barriers are insurmountable, but I do think that coming up with a standardized way to handle the switching between the two may be too big of a change for 1.0.

One additional point I&apos;d like to bring up with regards to the default of sync vs async debate is the orchestration of jobs.  While SB and the spec have both (correctly) decided not to address orchestration directly (this provides much more flexibility to the end user and is a good thing IMHO), one of the key aspects of orchestrating jobs is knowing when one ends so the next can begin.  Using an async JobOperator, the only practical ways to identify that a job has completed is via some custom code that polls the JobRepository (which is what the TCK/RI do by default).  I think we&apos;d agree that this isn&apos;t a practical solution in a large batch environment.  Sync processing allows the executor to know that a job was complete when the method returns.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14604</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-19 17:54:52 +0000</bug_when>
    <thetext>Michael,

Thanks for writing up your thoughts.   

For the 1.0 timeframe, though, I still think we need to enforce a hard requirement on an asynch start/restart API.

It&apos;s a shame we hadn&apos;t realized this was still subject to interpretation earlier.   While within IBM, we had never considered the thought that start/restart would be anything other than asynch, I don&apos;t think we neglected to communicate our understanding either.

We had a public ML discussion on the subject of the mechanism used by the TCK to wait for completion (thereby assuming asynch), starting here: 

 https://java.net/projects/jbatch/lists/public/archive/2013-03/message/88

Later in this thread Cheng suggested we switch the TCK to allow for polling on job termination rather than forcing the batch implementation to provide a callback mechanism as we&apos;d been requiring up until that point.

 https://java.net/projects/jbatch/lists/public/archive/2013-03/message/104

We refactored the TCK SPI and added a polling implementation as the built-in default in response.

In this same thread, you even mentioned the SB JobLauncher behavior, and I replied (perhaps not firmly enough) that we were only going to support asynch execution in this message:

 https://java.net/projects/jbatch/lists/public/archive/2013-03/message/107

---

You objected to a de facto polling requirement, but there are ways of avoiding this, e.g. a callback mechanism like the one the RI had been using.

I hadn&apos;t wanted to rush into standardizing a synch vs. asynch approach but hadn&apos;t wanted to hold us back either. 

I was offering that mainly in case you wanted to be able to present a synch API with the idea that it wasn&apos;t yet in the standard but that it was likely to be the future direction in 1.1.

---

Long post and long thread, so just to summarize:  our position is start()/restart() must be asynch, the TCK won&apos;t change, and the spec will be clarified via errata in the next maintenance release.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14610</commentid>
    <comment_count>9</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2013-11-19 23:15:39 +0000</bug_when>
    <thetext>This sounds settled but I thought I would put my thoughts down anyhow.

I think this issue goes hand in hand with the one regarding JobExecution immutability. It seems to me that the reason the TCK was assuming that the result of `JobOperator#getJobExecution` would reflect the current state of the running execution is because there is currently no other way to determine when the job has completed than polling the resultant value&apos;s batch status.

I think you could solve these two issue together by making:

- The returned value of `JobOperator#getJobExecution` should be required to reflect the current state of the JobExecution when called and nothing more. If the returned value of JobExecution#getBatchStatus will change should be implementation dependent and not required by the spec or TCK.

- `JobOperator#start` and `JobOperator#restart` return something more like:

`
public interface JobOperation extends Future&lt;JobExecution&gt; {

    long getJobExecutionId();
}
`

Where the result of `JobOperation#get` should return the state of the execution once the batch runtime has finished processing the job and `JobOperation#cancel` should be analogous as `JobOperator#stop`.

The result of `JobOperation#get` should not be required to change based on any subsequent calls to `JobOperator#restart`, `JobOperator#abandon` or the job repository being modified externally. If you have called `JobOperation#get` and there is a call to JobOperator#stop for that job before the call completes, `JobOperation#get` should throw a cancellation exception in the same way that it would for a call to `JobOperation#cancel`.

This will allow the caller to start the job asynchronously or synchronously as required and has the advantage of being familiar for people used to asynchronous programming.

It retains the ability to see the current state of the job during execution through `JobOperator#getJobExecution`JE so you can still poll on either it&apos;s result or `JobOperation#isDone`. Alternatively you can get the result of the job  when it is complete in a blocking manner through `JobOperation#get`.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14874</commentid>
    <comment_count>10</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 21:53:02 +0000</bug_when>
    <thetext>Changed Javadoc for JobOperator&apos;s start and restart methods (I think the delta will be clear enough):

start:

        /**
	 * Creates a new job instance and starts the first execution of that
	 * instance, which executes asynchronously.
         ...

restart:

        /**
	 * Restarts a failed or stopped job instance, 
         * which executes asynchronously.
         ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14900</commentid>
    <comment_count>11</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-09 15:06:11 +0000</bug_when>
    <thetext>Brent,

Sorry, I only just noticed your post as I was making my comment wrapping this up (missed it before).

Thanks for the contribution.

Your proposal seems like a fine starting point where we to try to standardize a blocking execution API.    Though I think a change like that fits more with a possible 1.1 update than treatment as a &quot;spec errata&quot;, and the latter is what I&apos;m trying to fit this bug into.

I&apos;d suggest reopening it as a new bug if you&apos;re interested.  

I&apos;d like to hear what other feedback we get on this issue going forwards to help us make this decision.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19102</commentid>
    <comment_count>12</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 21:07:38 +0000</bug_when>
    <thetext>Closing after opening new bug 7284 to discuss further in 1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5371</bug_id>
          
          <creation_ts>2013-09-09 20:55:00 +0000</creation_ts>
          <short_desc>JobOperatorTests#testAbandoned() assumes earlier JobExecution instance will reflect subsequent status changes</short_desc>
          <delta_ts>2013-11-05 19:05:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14110</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 20:55:42 +0000</bug_when>
    <thetext>See mailing list discussion &quot;JobOperatorTests#testAbandoned()&quot;

Also relevant is Spec Bug 4834.

Assuming we were not going to make any spec updates, we could still fix the TCK, and &quot;loosen&quot; the test logic to allow an implementation to NOT actively update an earlier JobExecution reflecting later status changes.

Thus, we have the bug here in the TCK component.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14156</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 16:11:54 +0000</bug_when>
    <thetext>This bug says that &quot;we could still fix the TCK&quot;.  Is the TCK going to change for this issue (I believe it should)?  This note is ambiguous about what the end result is going to be.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14157</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-16 16:37:09 +0000</bug_when>
    <thetext>Yes, by including the bug in this, the TCK component, we&apos;re saying the TCK should change, regardless of any changes we may or may not make to the spec.

I was wording it in a way to leave it open that we might make such a clarification in the spec.   Sorry if that was confusing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14468</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-04 23:28:49 +0000</bug_when>
    <thetext>I was trying to scan the TCK for other similar assumptions, so we could remove them.   Unfortunately the RI doesn&apos;t make this too easy, so I&apos;m going to assume it&apos;s just this one test method.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5372</bug_id>
          
          <creation_ts>2013-09-09 21:13:00 +0000</creation_ts>
          <short_desc>Evaluation order of multiple transition elements</short_desc>
          <delta_ts>2016-03-17 16:10:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14111</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 21:13:42 +0000</bug_when>
    <thetext>See public ML discussion &quot;evaluation order of multiple transition elements&quot; (though it&apos;s a lot to read through).

The question specific to this bug is indeed the subject of the email thread, the &quot;evaluation order of multiple transition elements&quot;.

(From there I brought up other, related issues, like co-existence of the @next attribute with transition elements as well as exception flow, which could end up getting addressed separately.)

Let me note for what it&apos;s worth that this might be a small or a moot point with respect to the TCK.  I.e. if we have any TCK tests that would fail based on the interpretation of this question, it&apos;s only a couple.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14392</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 16:03:15 +0000</bug_when>
    <thetext>So where do we stand on this issue?  It&apos;s a long thread and I&apos;d like to understand (from the perspective of this specific bug) what the proposed solution is.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14535</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-10 00:05:56 +0000</bug_when>
    <thetext>Having broken out from the original email thread the aspects captured in bugs 5373, 5374, we could discuss the ordering issue in this bug separately.   

So this is a &quot;logically separate&quot; response though obviously right on the heels of my email response to the other two issues.

Again, I&apos;m not sure or don&apos;t recall if there is truly a TCK impact; I&apos;m marking this as &quot;tck_challenge&quot; since I think it&apos;s critical to address in 1.0 and can&apos;t wait until 1.1 for clarification.

----

Proposal: The transition elements are matched in order.  They will not be reordered most to least specific.

The main contrary argument would be the impact to existing SpringBatch XML.  

Something like this will be broken by the proposed spec interpretation:

SB:
&lt;step id=&quot;step1&quot;&gt;
    &lt;next on=&quot;*&quot; to=&quot;step2&quot;/&gt;
    &lt;next on=&quot;FAILED&quot; to=&quot;recoverStep&quot;/&gt;

However, while this is a simple example, and may be the 95% case (or whatever number, I&apos;m just guessing), it&apos;s problematic to state a more general rule for all possible expression comparisons.

The SpringBatch API referenced earlier  in this email thread, which provides this function in SB according to Michael, doesn&apos;t necessarily seem to provide a complete definition we could paste in the spec.   

Assuming there is a complete ruleset, it&apos;s one more thing for an implementation provider and JSL author to learn.   It seems simpler to just say &quot;in order&quot; and therefore more desirable.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14565</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-14 16:42:12 +0000</bug_when>
    <thetext>We&apos;re fine with the above proposal.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14912</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 10:07:25 +0000</bug_when>
    <thetext>---
1) Deleted last paragraph in section 8.2.5.

Replaced with:

 &quot;See section 8.6 for more details about transition elements and section 8.9 for details on transitioning rules.&quot;

---
2) In new section 8.9 (added more for bugs 5373, 5374), added subsection 8.9.1:


8.9.1	Combining Transition Elements

Any combination of transition elements can be included  at the end of a step, flow, or decision definition.    Combinations can include zero, one, or more than one instance of a single type of execution element, e.g. next. 
Transition elements are evaluated in sequential order as they occur within the JSL document.   I.e. the appropriate exit status is compared with the on attribute value of the first transition element in the sequence and, if it matches, then the corresponding transition is perfomed, and the rest of the transition elements are ignored.  If not, the second transition element is evaluated, etc.
Example:
&lt;step id=&quot;Step1&quot;&gt;
	&lt;next on=&quot;RC0&quot; to=Step2/&gt;
	&lt;next on=&quot;RC4&quot; to=Step3/&gt;
	&lt;end on=&quot;RC4&quot; exit-status=DONE/&gt;
	&lt;fail on=&quot;*&quot;/&gt;    &lt;!-- Matches anything, so only makes sense as last transition element--&gt;
&lt;/step&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19099</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 20:55:20 +0000</bug_when>
    <thetext>I wonder if this might be covered already, but leaving it open to consider new tests in TCK.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19817</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 16:10:38 +0000</bug_when>
    <thetext>Will track in:
https://github.com/WASdev/standards.jsr352.tck/issues/27</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5373</bug_id>
          
          <creation_ts>2013-09-09 21:16:00 +0000</creation_ts>
          <short_desc>Co-existence of transition elements with @next attribute PLUS behavior if no transition element @on is matched</short_desc>
          <delta_ts>2016-03-17 16:12:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14112</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 21:16:49 +0000</bug_when>
    <thetext>One of the other two issues arising from ML conversation:  &quot;Evaluation order of multiple transition elements&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14131</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-11 19:00:14 +0000</bug_when>
    <thetext>Besides the question of &quot;Can a @next attribute be present if transition elements are present?&quot; there is also the question of &quot;What happens if no transition element&apos;s @on attribute matches a step&apos;s exit status?&quot;. 

This impacts TCK test:
ExecutionTests#testInvokeJobWithNextElement</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14391</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 15:45:05 +0000</bug_when>
    <thetext>The way the first question is addressed in Spring Batch is that you can use either the next attribute or the transition elements (not both).  The next attribute is essentially a short cut option for a next transition with a complete status. 

The way the second question is addressed goes back to discussions on how transition elements are evaluated. We require that the full scope of possibilities be addressed in your transitions.  It&apos;s like requiring a default option on a switch statement.  If you don&apos;t cover all options, it&apos;s considered a semantic error an the job won&apos;t start.  The reasoning behind this is that we view this like running a class that won&apos;t compile.  We could start the processing and run until we hit the missing semicolon, but why start if it&apos;s an error we can prevent on startup?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14913</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 10:11:22 +0000</bug_when>
    <thetext>I&apos;m going to pass on listing the individual changes here and point to the draft proposal:

https://java.net/projects/jbatch/downloads/download/JSR%20352%20v1.0%20Maintenance%20Release%2020140110%20Draft.TrackChanges.pdf

This includes Word comments published to PDF.  At present there are 9 comments related to Bug 5373 which you can search through.

E.g. &quot;Bug 5373  part 8&quot;

Use search string &quot;5373&quot;

----

Note I incorporated flow transition, which led me to thinking this should be called out as incomplete for the time being (Bug 5690).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14939</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-14 19:00:42 +0000</bug_when>
    <thetext>Section 8.9.4 page 57 2a.
This should also allow the failure of a job during parsing (since this type of error can be determined during parsing).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14947</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-14 20:35:21 +0000</bug_when>
    <thetext>(In reply to mminella from comment #4)
&gt; Section 8.9.4 page 57 2a.
&gt; This should also allow the failure of a job during parsing (since this type
&gt; of error can be determined during parsing).

Good point.   If we didn&apos;t have that I&apos;d still argue Section 13.1 applies as a catch-all but I&apos;ll add it to be sure it&apos;s clear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15133</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 12:54:04 +0000</bug_when>
    <thetext>Added a 10th change for this bug.

Sec. 8.9.4, 2.a. now reads:
-------

a.	Note: transition via next outside of the flow is not permitted.    If this is not detected during job validation (see section 13.1), then at runtime the job execution will end at this point with batch status of FAILED.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15392</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-24 13:51:53 +0000</bug_when>
    <thetext>Per Michael&apos;s email, added parts 11,12:

----------
#11

Section 8.1.2 ends with:

     In this context, &quot;unhandled&quot; simply means an exception thrown by the listener back to the runtime implementation. 
----------

#12

Section 8.2.7 begins with (2nd sentence is new):

Any unhandled exception thrown by any step-level artifact during step processing causes the step to terminate with a batch status of FAILED.  In this context, &quot;unhandled&quot; means an exception thrown by the execution of the artifact back to the runtime implementation which does not result in a skip or a retry as described in Section 8.2.1.4.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19092</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:29:57 +0000</bug_when>
    <thetext>This was a sprawling update...not sure what needs to be added to TCK but certainly something.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19818</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 16:12:16 +0000</bug_when>
    <thetext>Will track in:
https://github.com/WASdev/standards.jsr352.tck/issues/28</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5374</bug_id>
          
          <creation_ts>2013-09-09 21:21:00 +0000</creation_ts>
          <short_desc>Details of exception handling (by container)</short_desc>
          <delta_ts>2016-03-17 16:39:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14113</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 21:21:16 +0000</bug_when>
    <thetext>The last issue arising from the ML discussion &quot;evaluation order of multiple transition elements&quot;.   

This would be a more major issue if it weren&apos;t for the fact that, I believe, for your typical JSL this won&apos;t really be an issue (i.e. the difference btw the RI behavior today and another behavior won&apos;t differ for most JSLs).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14128</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-11 18:30:35 +0000</bug_when>
    <thetext>Did a bit more investigation here.  Michael, it would be helpful if you could confirm.

First, let me extract what I&apos;m calling the &quot;3rd issue&quot; from the email and paste it here.

------------------------------------------------------------------------------

As we were trying to follow the SB behavior here, Michael, could you please chime in and clarify what the 
behavior is regarding failing/transitioning in the case that an exception is thrown reaching back to the container?


Again, though I failed to communicate this in an open discussion, I actually thought we were following
the SB behavior in implementing the RI in the manner we did.

That&apos;s based on this link:
http://static.springsource.org/spring-batch/reference/html/configureStep.html#conditionalFlow

I thought that what the example showed here:

    &lt;step id=&quot;stepA&quot; parent=&quot;s1&quot;&gt;
        &lt;next on=&quot;*&quot; to=&quot;stepB&quot; /&gt;
        &lt;next on=&quot;FAILED&quot; to=&quot;stepC&quot; /&gt;
    &lt;/step&gt;

was a sort of &quot;catching an exception in a JSL transition element&quot;.    I.e. an exception is thrown, so step 
exit status defaults to FAILED, which is then subject to transition element matching.

------------------------------------------------------------------------------

What I found was that SpringBatch 2.2.1 did indeed seem to behave as the RI does in this respect, at least in the single sample I ran.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14158</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 16:38:45 +0000</bug_when>
    <thetext>Scott,

For the scenario you are isolating here, you are correct.  In a Spring Batch job configured as:

    &lt;batch:job id=&quot;personJob&quot;&gt;
        &lt;batch:step id=&quot;step1&quot;&gt;
            &lt;batch:tasklet ref=&quot;failureTasklet&quot;/&gt;
            &lt;batch:next on=&quot;*&quot; to=&quot;step3&quot;/&gt;
            &lt;batch:next on=&quot;FAILURE&quot; to=&quot;step2&quot;/&gt;
        &lt;/batch:step&gt;
        &lt;batch:step id=&quot;step2&quot; next=&quot;step3&quot;&gt;
            &lt;batch:tasklet ref=&quot;failureTasklet&quot;/&gt;
        &lt;/batch:step&gt;
        &lt;batch:step id=&quot;step3&quot;&gt;
            &lt;batch:tasklet ref=&quot;failureTasklet&quot;/&gt;
        &lt;/batch:step&gt;
    &lt;/batch:job&gt;

if an exception is thrown in step1 and the ExitStatus is not changed by a listener, step2 will be executed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14387</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-29 14:26:49 +0000</bug_when>
    <thetext>So where does this leave this issue?  It&apos;s not clear as to what the action items/outcome are from the above comments.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14914</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 10:12:45 +0000</bug_when>
    <thetext>I&apos;m going to pass on listing the individual changes here and point to the draft proposal:

https://java.net/projects/jbatch/downloads/download/JSR%20352%20v1.0%20Maintenance%20Release%2020140110%20Draft.TrackChanges.pdf

This includes Word comments published to PDF.  At present there are 4 comments related to Bug 5373 which you can search through.

E.g. &quot;Bug 5374  pt. 2&quot;

Use search string &quot;5374&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14942</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-14 19:05:48 +0000</bug_when>
    <thetext>Section 8.7 page 47
Can we have the bullet points ordered in order of precidence?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14946</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-14 20:33:12 +0000</bug_when>
    <thetext>(In reply to mminella from comment #5)
&gt; Section 8.7 page 47
&gt; Can we have the bullet points ordered in order of precidence?

Do you mean the three items listed here:

---
A job execution will end under the following conditions:

1. A job-level execution element....

...

---

I don&apos;t see there being a precedence order here.  Those three conditions are peers, you could say.    Or did you mean something else?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19103</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 21:21:11 +0000</bug_when>
    <thetext>Moving to TCK as I recall this being under-tested.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19821</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 16:39:39 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/29</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5375</bug_id>
          
          <creation_ts>2013-09-09 21:30:00 +0000</creation_ts>
          <short_desc>Spec contradicts itself when talking about uninitialized exit status (TCK assumes &apos;null&apos;)</short_desc>
          <delta_ts>2015-09-03 16:35:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14114</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-09 21:30:38 +0000</bug_when>
    <thetext>As noted in ML discussion: &quot;ExecuteTests#testMyStepContextBatchlet question&quot;, the TCK assumes that a JobContext.getExitStatus() will return &apos;null&apos; if setExitStatus() has not been called. 

As mentioned in the email thread, maybe it should be returning the BatchStatus, e.g. STARTED.

TCK: Assuming no spec change, this affects a large number of TCK tests though it might be possible to abstract away the difference in the TCK.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14159</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 16:47:34 +0000</bug_when>
    <thetext>Just to point out, the place that the spec states the ExitStatus matches the BatchStatus by default is page 47 in section 8.7:

&quot;
The batch and exit status of the job is set as follows:
    1. Batch status is initially set to STARTING by the batch runtime. Immediately before starting the first step, the batch runtime sets the batch status to STARTED. Exit status is initially set to the string form of the batch status.
&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14507</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-07 05:32:40 +0000</bug_when>
    <thetext>I&apos;m thinking about just leaving this alone, rather than updating the TCK.

Within the Javadoc itself (for JobContext and StepContext), the behavior of getExitStatus() is clearly specified in the manner that the TCK expects.  I.e. if setExitStatus() hasn&apos;t been called, then a &apos;null&apos; is returned.

It could be confusing, I agree, to reconcile this with the wording in 8.7 and 8.7.1:  &quot;Exit status is initially set to the string form of the batch status&quot;.

However this could be clarified by saying that the exit status in this context, is the exit status seen via the JobExecution/StepExecution (by the JobOperator).

It is not necessarily obvious that the exit status described in 8.7, 8.7.1 MUST at all times have the same value as that returned by the getExitStatus() methods.  Without the Javadoc description, it would be a reasonable and obvious assumption, but we have the description here.

Let&apos;s step back and think about how this API would actually be used.

What value is there in a batch artifact getting a runtime-provided value on StepContext.getExitStatus()?   If the artifact has control, then the BatchStatus must be either STARTED or STOPPING.  Maybe one could do something different depending on which of the two but the same could be accomplished via getBatchStatus().

To me it seems the only value is to see a value that some other artifact in the job/step has set into setExitStatus().  This can be accomplished just as well with a &apos;null&apos; initial value as it can with a value reflecting the current BatchStatus.

Does this really seem worth updating the TCK or excluding tests for?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14571</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-14 20:03:27 +0000</bug_when>
    <thetext>I&apos;m confused about the javadoc you&apos;re referring to in the StepContext and JobContext.  On page 94 of the spec, the javadoc for StepContext#setExitStatus(String status) states:

&quot;If setExitStatus was not called or was called with a null value, then the exit status defaults to the batch status of the step.&quot;

This is clearly in line with section 8.7 as I pointed out that states that the status is initially set to the BatchStatus.  The corresponding getter (StepContext#getExitStatus() just implies that null is a possible value, not that it is the default return value if the setExitStatus was not called.  In fact, I would argue that the setter verbiage goes even further since it says that if it is called with a null value (aka myStepContext.setExitStatus(null);) it should still be set to the BatchStatus.

The same language is used in the javadoc on the JobContext.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14592</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-18 21:28:15 +0000</bug_when>
    <thetext>(In reply to mminella from comment #3)
&gt; I&apos;m confused about the javadoc you&apos;re referring to in the StepContext and
&gt; JobContext.  On page 94 of the spec, the javadoc for
&gt; StepContext#setExitStatus(String status) states:
&gt; 
&gt; &quot;If setExitStatus was not called or was called with a null value, then the
&gt; exit status defaults to the batch status of the step.&quot;

The full paragraph is:

* The setExitStatus method assigns the user-specified exit status for
* the current step. When the step ends, the exit status of the step is
* the value specified through setExitStatus. If setExitStatus was not
* called or was called with a null value, then the exit status
* defaults to the batch status of the step.

So the last sentence (mentioning the defaulting) follows the sentence:  &quot;When the step ends...&quot;.   If you read it this way, that the default is applied once the step ends, then it&apos;s consistent with my interpretation.  

---

But in any case, I think we&apos;ve reached the end of the road trying to find clarity looking back over the existing spec wording.  We are interpreting this differently and built the RI and TCK with a different, though I think reasonable, interpretation.  I think it would help then to update the spec, through an errata, to clarify the behavior here.

So I&apos;m proposing, again, clarifying the spec that the defaulting of exit status to batch status doesn&apos;t occur until after the job/step execution finishes (loosely speaking... maybe I&apos;m glossing over a detail or two but not one that&apos;s come up in this discussion).

This would then leave the TCK unchanged.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14593</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-18 21:40:58 +0000</bug_when>
    <thetext>I still disagree, even with the sentence I pointed out in it&apos;s full context.  What you are describing is that the default is applied at the end.  That doesn&apos;t make it the defaultthat makes it the end result.  I view this as nothing more than a minor error in the javadoc on the getExitStatus.  Everywhere else in the spec is consistent in that the default value for the ExitStatus should be the BatchStatus.  The only way that the status could be null in any scenario is if you assume that null is the &quot;default&quot; during the execution of the step when setExitStatus has not been called.  From a developer&apos;s standpoint, that seems like a very unintuitive interpretation.  From the developer&apos;s perspective, I now have two &quot;defaults&quot;.  One while the step is executing (null) and one once it ends (the BatchStatus).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14597</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-18 21:51:14 +0000</bug_when>
    <thetext>(In reply to mminella from comment #5)
&gt;  The only way that the status could be
&gt; null in any scenario is if you assume that null is the &quot;default&quot; during the
&gt; execution of the step when setExitStatus has not been called.  From a
&gt; developer&apos;s standpoint, that seems like a very unintuitive interpretation. 
&gt; From the developer&apos;s perspective, I now have two &quot;defaults&quot;.  One while the
&gt; step is executing (null) and one once it ends (the BatchStatus).

Yes, that&apos;s exactly what I&apos;m proposing.  I don&apos;t think it&apos;s that complicated, but it does deserve some explanation.   

Basically, while the step artifacts are executing, &apos;exitStatus&apos; is just a bean property of JobContext/StepContext.   The more detailed behavior described in 8.7 applies only once the step/job is no longer executing, at which time exit status becomes a property of JobExecution/StepExecution and is also (for step exit status) relevant for transitioning between execution elements.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14598</commentid>
    <comment_count>7</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-18 21:58:18 +0000</bug_when>
    <thetext>You&apos;re saying that the StepExeuction&apos;s ExitStatus and the StepContexts&apos;s ExitsStatus wouldn&apos;t be consistent?  Now we have two ExitStatuses for the same step at the same time, one in the StepContext and one in the StepExecution.  Is that correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14601</commentid>
    <comment_count>8</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-11-19 14:43:27 +0000</bug_when>
    <thetext>One other note.  Although we keep talking about this in the scope of the Step (StepContext and StepExecution), I believe the JobContext and JobExecution have the same semantics.  Because of that, we should consider how that defaulting behavior applies at the job level as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14602</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-19 14:53:22 +0000</bug_when>
    <thetext>(In reply to mminella from comment</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14603</commentid>
    <comment_count>10</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-19 15:01:24 +0000</bug_when>
    <thetext>(In reply to mminella from comment #7)

When a job/step begins executing, the exitStatus is initialized to null.

When execution completes, the exitStatus, if not currently set to a non-null value, defaults to batch status.

So there&apos;s only one exit status &quot;at a time&quot;, but the rules in play are different depending on whether we&apos;re executing or not.   

This fits well with the idea that this &quot;exit status&quot; has a different significance once execution is over (e.g. it then is potentially used to transition between steps).
----

Let me back up and point out that I&apos;m more resistant to change only because the TCK is already out there.   Changing the behavior at this point means the change must be picked up by all implementations.   It&apos;s not that I&apos;m claiming my interpretation is clearly superior.

My references to the spec have been to show that there is something in there to back our view of this behavior, that we&apos;re not blatantly contradicting the spec yet marching forwards only because of the TCK implementation.   I think the spec is unclear.... not in complete contradiction with the TCK.

Your proposal is a bit simpler than mine... but I don&apos;t think it offers any more utility.   

So I&apos;m still planning on leaving the TCK alone, and adding a clarification as a spec errata in our next maintenance release.

Also in reply to comment #8, I am considering both job/step in this response.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14884</commentid>
    <comment_count>11</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-08 22:46:24 +0000</bug_when>
    <thetext>OK, this is a decent-sized change since there are assertions scattered throughout.

The bottom line will be that the job/step exit status is initialized to &apos;null&apos;, and is only defaulted to batch status when job/step execution ends. 

Again, I don&apos;t claim this is superior to the other interpretation, (that the exit status defaults to batch status at any point).  But we had an ambiguity and the TCK took this approach, so I&apos;m going with that and hoping that this won&apos;t be too great a burden on migration of legacy SB apps.

------------------
Six changes here:
------------------

1) (This is only tangentially related, but it seemed close enough and small enough to lump together rather than using another bug:)

At the end of the main paragraph of Section 8.5 (Decision), change last sentence from:

  The decider may set a new exit status to facilitate the transition choice.

to: 

  The decider return value will also be set as the current value of the job exit status, in addition to being matched against the decisions own child transition elements to decide the next transition.

---

2) Sec. 8.7 (2nd paragraph):

Change from:

  A job and each step in a job end with a batch status and exit status value. Batch status is set by the batch runtime; exit status may be set through the Job XML or by the batch application. By default, the exit status is the same as the batch status. Note if a batch artifact explicitly sets the exit status that overrides the default. The batch and exit status values are available in the JobContext and StepContext runtime objects.....

to:

  A job and each step in a job end with a batch status and exit status value. Batch status is set by the batch runtime; exit status may be set through the Job XML or by the batch application.  The exit status for a job and a step will be initially set to null.   At the time that the job or step completes execution, if the exit status is equal to null, it will then be defaulted to the string value of the batch status, which will be its final value.   The batch and exit status values are available in the JobContext and StepContext runtime objects, and the exit status can be set explicitly via any batch artifact.....

---

3) Also Sec. 8.7 

Change from (i.e. delete the last line shown in the current text):

 The batch and exit status of the job is set as follows:

 1.  Batch status is initially set to STARTING by the batch runtime. Immediately before starting the first step, the batch runtime sets the batch status to STARTED. Exit status is initially set to the string form of the batch status.

To:
 
  The batch and exit status of the job is set as follows:

 1.  Batch status is initially set to STARTING by the batch runtime.  Immediately before starting the first step, the batch runtime sets the batch status to STARTED.  

---

4) Sec. 8.7.1

Remove sentence:

 &quot;Step exit status is initially set to the same value as batch status.&quot;

---

5) Sec. 8.7.1

Change last sentence to:

  &quot;If no batch artifact sets the exit status, the batch runtime will default the value to the string form of the batch status value of the step when step execution completes.&quot;

---

6) Sec. 8.7.2.

Change last sentence in first paragraph to:

  &quot;If the exit status is not set it defaults to batch status at the end of step execution, the same as for a non-partitioned step.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15393</commentid>
    <comment_count>12</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-24 14:09:37 +0000</bug_when>
    <thetext>Change #7 (from M. Minella comment): 

Rework change #2 above (in this same bug) to rephrase &quot;defaulted&quot;.  The sentence in question now reads:

&quot;At the time that the job or step completes execution, if the exit status is equal to null, it will then be set by the runtime implementation to the string value of the batch status, which will be its final value.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19093</commentid>
    <comment_count>13</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:35:29 +0000</bug_when>
    <thetext>I gather the TCK must have already been enforcing this, so am assuming no new changes needed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5379</bug_id>
          
          <creation_ts>2013-09-10 17:57:00 +0000</creation_ts>
          <short_desc>TCK ExecutionTests.testInvokeJobChunkWithFullAttributes challenge:  SB wants to fail JSL</short_desc>
          <delta_ts>2013-11-06 20:10:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14120</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-10 17:57:58 +0000</bug_when>
    <thetext>As discussed in ML subject &quot;TCK ExecutionTests.testInvokeJobChunkWithFullAttributes&quot;, the SB impl wants to fail this JSL invalid.

I view this as deserving of a warning message at most, but respect that point.

If no one else has a strong opinion (e.g. a strong opinion that this JSL should not be invalidated and should be allowed to run on any JSR 352 implementation), I&apos;d move to just exclude this test from the TCK, since it&apos;s not adding much value to the remaining tests.

Marking this as SPEC since it&apos;s conceivable something could be said in the spec, though it might be addressable just in the TCK.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14161</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-16 17:34:34 +0000</bug_when>
    <thetext>Per the spec (section 13.1):

The batch runtime must perform schema validation during JobOperator start processing before the start method returns to the caller. A schema validation error results in JobStartException. The implementation has two choices for handling semantic errors in the JSL:

    1. Do semantic validation during JobOperator start processing before returning to the caller. If there is a semantic validation error, the implementation must throw JobStartException.
    2. Do semantic validation after job execution begins. If a semantic validation error occurs, the implementation must end the job in the FAILED state. The implementation is advised to log sufficient error information to enable problem resolution.

Spring Batch chooses option 1.  It sounds like the RI and TCK expect option 2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14162</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-16 17:41:42 +0000</bug_when>
    <thetext>Michael, for this particular JSL, the RI and TCK do not view this as a semantically invalid job.   It&apos;s not a matter of how we expect invalidation to be performed.

We can either:

1) address this in the spec, and get clear whether this is valid and should be no-op&apos;d, or whether it is actually invalid.

  or

2) Leave this open and exclude this test from the TCK.

I was leaning towards 2).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14376</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-10-28 18:54:00 +0000</bug_when>
    <thetext>I have no objection to option 2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14505</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-06 20:10:27 +0000</bug_when>
    <thetext>Resolved by excluding test from TCK</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5385</bug_id>
          
          <creation_ts>2013-09-11 18:36:00 +0000</creation_ts>
          <short_desc>TCK tests (DeciderTests#testDeciderCannotbeFirstElementOnStart, etc. ) do not properly support either JobStartException or execution with FAILED</short_desc>
          <delta_ts>2013-11-05 19:05:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14129</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-11 18:36:12 +0000</bug_when>
    <thetext>Besides
DeciderTests#testDeciderCannotbeFirstElementOnStart

This test looks wrong in a separate but related manner
FlowTransitioningSteps#testFlowTransitionToStepOutOfScope()</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5389</bug_id>
          
          <creation_ts>2013-09-11 20:41:00 +0000</creation_ts>
          <short_desc>In Sec. 10.7.1, should we have said we require a &quot;no-arg&quot; explicit or implicit constructor rather than a &quot;default constructor&quot;</short_desc>
          <delta_ts>2015-09-03 14:58:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14137</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-11 20:41:52 +0000</bug_when>
    <thetext>The concern is that &quot;default constructor&quot; is imprecise since it implies implicit and excludes an explicit, no-arg constructor.

Probably would have just let this slide, but since it overlapped some other confusion (in which the TCK&apos;s batch.xml had a bunch of extraneous entries), I&apos;ll just open it though it&apos;s very minor.  Unless someone can show that &quot;default constructor&quot; is correct.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14844</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 23:15:14 +0000</bug_when>
    <thetext>Changed wording to read:

2.	Use of batch.xml to load batch artifacts requires the availability of a zero-argument constructor (either a default constructor or an explicitly-defined, no-arg constructor).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5401</bug_id>
          
          <creation_ts>2013-09-19 17:38:00 +0000</creation_ts>
          <short_desc>Clean up assertion messages</short_desc>
          <delta_ts>2015-09-03 13:15:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>suggestion</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14177</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-19 17:38:45 +0000</bug_when>
    <thetext>The messaging through out the TCK is not consistent (many copy paste errors).  Just a couple examples:

* ChunkTests#testChunkRetryOnError() - All of the messages say it&apos;s for execution #1 even though the job is executed 3 times.
* ChunkTests#testChunkNoProcessorDefined() - the METHOD variable is defined as testChunkDefaultItemCount (incorrect method).  The same error occurs in a number of tests.

There are other areas with these types of issues.  A quick read through the tests should highlight most of them.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19076</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 13:15:17 +0000</bug_when>
    <thetext>Moved to:
https://github.com/WASdev/standards.jsr352.tck/issues/3</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5403</bug_id>
          
          <creation_ts>2013-09-20 19:18:00 +0000</creation_ts>
          <short_desc>Spec unclear on skipping part of an Exception hierarchy</short_desc>
          <delta_ts>2016-03-17 17:10:55 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14180</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-20 19:18:40 +0000</bug_when>
    <thetext>This bug is in reference to the email conversation started here: https://java.net/projects/jbatch/lists/public/archive/2013-09/message/12

In short, the spec is not clear on how the &lt;include&gt; and &lt;exclude&gt; logic works for the evaluation of an exception to be skipped/retried/etc.  In Spring Batch, the logic is based on this statement:

&quot;For any exception encountered, the skippability will be determined by the nearest superclass in the class hierarchy. Any unclassifed exception will be treated as &apos;fatal&apos;. The order of the &lt;include/&gt;and &lt;exclude/&gt; elements does not matter.&quot; [http://docs.spring.io/spring-batch/reference/html/configureStep.html#configuringSkip]

The TCK interprets the spec as apply include elements, then exclude elements.  So if we have the following exception hierarchy:

MyParentException --&gt; MyChildException --&gt; MyGrandchildException 

and we configure skip logic as follows:
&lt;skippable-exception-classes&gt;
    &lt;include class=&quot;MyParentException&quot;/&gt;
    &lt;include class=&quot;MyGrandchildException&quot;/&gt;
    &lt;exclude class=&quot;MyChildException&quot;/&gt;
&lt;/skippable-exception-classes&gt;

the job is skip MyParentException and NOT skip either MyChildException or MyGrandchildException.  My expectation would be that MyParentException and MyGrandchildException should be skipped and only MyChildException should be considered a fatal exception.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14378</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-28 21:02:12 +0000</bug_when>
    <thetext>I agree that given the choice between the current algorithm used by the RI &amp; TCK to combine include/exclude(s) and the alternative Michael mentioned, the alternative is better.   It&apos;s definitely more expressive and arguably more intuitive.

I would like to update both the TCK and the spec, then, accordingly.

My concern is to abide by whatever rules exist so as to not break anyone who&apos;s passing the TCK based on the current interpretation.  

Still trying to sort through these issues but plan to have an update shortly.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14508</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-07 05:38:43 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #1)
&gt; I agree that given the choice between the current algorithm used by the RI &amp;
&gt; TCK to combine include/exclude(s) and the alternative Michael mentioned, the
&gt; alternative is better.   It&apos;s definitely more expressive and arguably more
&gt; intuitive.
&gt; 
&gt; I would like to update both the TCK and the spec, then, accordingly.
&gt; 
&gt; My concern is to abide by whatever rules exist so as to not break anyone
&gt; who&apos;s passing the TCK based on the current interpretation.  
&gt; 
&gt; Still trying to sort through these issues but plan to have an update shortly.

Since this is only affects a test or two.. I think what we should do is:

1) exclude the test in the 1.0 release
2) update the spec in the (presumed) maintenance release to clarify include-exclude-include behavior as Michael suggested 
3) update the TCK by reworking this test at the same maintenance release.  

That leaves 1.0 a bit underspecified in this area, but hopefully those following this thread can set a precedent until 1.1.    

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14528</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-09 19:06:30 +0000</bug_when>
    <thetext>Will mark with &apos;tck_1.0&apos; to remind us to formally deliver the exclusion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14837</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 03:35:29 +0000</bug_when>
    <thetext>Would like to fix the behavior in a presumed 1.1 spec update and at that time, re-introduce a corrected form of this test.   I don&apos;t think I&apos;ll bother opening a bug just yet, when we haven&apos;t even started on 1.1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15801</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-05-09 17:15:31 +0000</bug_when>
    <thetext>Just remembered this change fell through the cracks.   When I first closed it out I thought it would be against JCP best practice to introduce a breaking change with a spec errata type of maintenance release.

However, we have other changes in our MR that are similarly disruptive (of edge cases).  

So I&apos;m going to write this up and add it to the current MR change log.  I do remember we all agreed on the outcome here.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15858</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-05-15 21:55:13 +0000</bug_when>
    <thetext>In Section 8.2.1.4.1 Skipping Exceptions:
(similar changes to retry exception paragraphs in Sections
8.2.1.4.2
8.2.1.4.5)

Change this text:
----------------

  The list of exception that will be skipped is specified in the skippable-exception-classes element on the child include element. One or more include child elements may be specified to specify the exception classes or superclasses that will be skipped. The list of exceptions to be skipped can be reduced by the exclude child element. 

To this text:
----------------

A given exception will be skipped if it &quot;matches&quot; an &apos;include&apos; child element of the &apos;skippable-exception-classes&apos; element, though this might be negated (and the exception not skipped) if it also &quot;matches&quot; an &apos;exclude&apos; child element of &apos;skippable-exception-classes&apos;.

The behavior is determined by the &quot;nearest superclass&quot; in the class hierarchy.

To elaborate, in this context, &quot;matches&quot; means the following:  For an include (or exclude) element C with @class attribute value T, an exception E &quot;matches&quot; C when either E is of type T or E&apos;s type is a subclass of T.

When an exception E &quot;matches&quot; both one or more &apos;include&apos; and one or more &apos;exclude&apos; elements, then there will be one type T1 among all the matching include/exclude elements such that all other distinct matching element types are superclasses of T1 (because of Java&apos;s single inheritance).    If T1 only occurs in a matching include element then include (skip) this exception.  If T1 appears in a matching exclude element (even if it also appears in a matching include element), then exclude (don&apos;t skip) this exception.

----------------

With this approach I think a more natural XSD would allow freedom to intermix the includes vs. excludes.. which we still don&apos;t allow, but that&apos;s a slightly more disruptive change and I&apos;m not sure it&apos;s worth it until someone complains more.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19083</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 15:24:00 +0000</bug_when>
    <thetext>Assigning to TCK.

As far as the proposed XSD change, will track along with the greater issue of
https://java.net/bugzilla/show_bug.cgi?id=7282</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19822</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 17:10:55 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/30</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5407</bug_id>
          
          <creation_ts>2013-09-22 13:16:00 +0000</creation_ts>
          <short_desc>JobThreadRootControllerImpl throws NPE on transitioner when partitioned batchlet stopped</short_desc>
          <delta_ts>2015-09-01 21:28:59 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>thomas_haines</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14187</commentid>
    <comment_count>0</comment_count>
      <attachid>93</attachid>
    <who name="">thomas_haines</who>
    <bug_when>2013-09-22 13:16:49 +0000</bug_when>
    <thetext>Created attachment 93
Small maven test to reproduce bug

When stopping a partitioned batchlet, JobThreadRootControllerImpl throws a NullPointerException at line 288:

IController stoppableElementController = transitioner.getCurrentStoppableElementController();

It can be reproduced with the attached simple job using the RI (SE).

Usage/stack trace below:

$ mvn test

Running org.sample.PartitionTest
21:15:30.597 [main] WARN  org.sample.PartitionTest 29 - java.lang.NullPointerException
java.lang.IllegalStateException: java.lang.NullPointerException
	at com.ibm.jbatch.container.impl.PartitionedStepControllerImpl.stop(PartitionedStepControllerImpl.java:112) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at com.ibm.jbatch.container.impl.JobThreadRootControllerImpl.stop(JobThreadRootControllerImpl.java:289) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at com.ibm.jbatch.container.impl.BatchKernelImpl.stopJob(BatchKernelImpl.java:152) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at com.ibm.jbatch.container.api.impl.JobOperatorImpl.stop(JobOperatorImpl.java:441) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at org.sample.PartitionTest.testStopPartition(PartitionTest.java:23) ~[test-classes/:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_25]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_25]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_25]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_25]
	at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:47) ~[junit-4.11.jar:na]
	at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12) ~[junit-4.11.jar:na]
	at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:44) ~[junit-4.11.jar:na]
	at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271) ~[junit-4.11.jar:na]
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70) ~[junit-4.11.jar:na]
	at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner$3.run(ParentRunner.java:238) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner.access$000(ParentRunner.java:53) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229) ~[junit-4.11.jar:na]
	at org.junit.runners.ParentRunner.run(ParentRunner.java:309) ~[junit-4.11.jar:na]
	at org.apache.maven.surefire.junit4.JUnit4TestSet.execute(JUnit4TestSet.java:53) ~[na:na]
	at org.apache.maven.surefire.junit4.JUnit4Provider.executeTestSet(JUnit4Provider.java:123) ~[na:na]
	at org.apache.maven.surefire.junit4.JUnit4Provider.invoke(JUnit4Provider.java:104) ~[na:na]
	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.7.0_25]
	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) ~[na:1.7.0_25]
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.7.0_25]
	at java.lang.reflect.Method.invoke(Method.java:606) ~[na:1.7.0_25]
	at org.apache.maven.surefire.util.ReflectionUtils.invokeMethodWithArray(ReflectionUtils.java:164) ~[surefire-api-2.10.jar:2.10]
	at org.apache.maven.surefire.booter.ProviderFactory$ProviderProxy.invoke(ProviderFactory.java:110) ~[surefire-booter-2.10.jar:2.10]
	at org.apache.maven.surefire.booter.SurefireStarter.invokeProvider(SurefireStarter.java:175) ~[surefire-booter-2.10.jar:2.10]
	at org.apache.maven.surefire.booter.SurefireStarter.runSuitesInProcessWhenForked(SurefireStarter.java:107) ~[surefire-booter-2.10.jar:2.10]
	at org.apache.maven.surefire.booter.ForkedBooter.main(ForkedBooter.java:68) ~[surefire-booter-2.10.jar:2.10]
Caused by: java.lang.NullPointerException: null
	at com.ibm.jbatch.container.impl.JobThreadRootControllerImpl.stop(JobThreadRootControllerImpl.java:287) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at com.ibm.jbatch.container.impl.BatchKernelImpl.stopJob(BatchKernelImpl.java:152) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	at com.ibm.jbatch.container.impl.PartitionedStepControllerImpl.stop(PartitionedStepControllerImpl.java:108) ~[com.ibm.jbatch-runtime-all-1.0.jar:na]
	... 33 common frames omitted</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15373</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-18 21:31:33 +0000</bug_when>
    <thetext>Pushed fix into Git (6a1fe05f838e61a47e96b2a073d3a20417d91de5).  Not sure when we&apos;ll push to Maven quite yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19066</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:28:59 +0000</bug_when>
    <thetext>Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>93</attachid>
            <date>2013-09-22 13:16:00 +0000</date>
            <delta_ts>2013-09-22 13:16:49 +0000</delta_ts>
            <desc>Small maven test to reproduce bug</desc>
            <filename>partition-fail.tgz</filename>
            <type>application/octet-stream</type>
            <size>4884</size>
            <attacher>thomas_haines</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>5412</bug_id>
          
          <creation_ts>2013-09-24 14:33:00 +0000</creation_ts>
          <short_desc>DeciderTests#testDeciderExitStatusIsSetOnJobContext and step looping</short_desc>
          <delta_ts>2014-01-03 03:47:20 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_1.0</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14207</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-09-24 14:33:26 +0000</bug_when>
    <thetext>In DeciderTests#testDeciderExitStatusIsSetOnJobContext, the job that it executes runs (decider_transitions_on_restart.xml) is configured with steps that form a loop (step1 --&gt; decider1 --&gt; flow1 --&gt; decider1, etc). Per sections 8.2, 8.2.5, 8.3, 8.4, and 8.6.1 of the spec, this is not allowed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14208</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-09-24 16:03:34 +0000</bug_when>
    <thetext>I can&apos;t argue with your reading of the spec.  

I&apos;m responsible for this, I wrongly thought that it was only re-execution of a step that was disallowed. 

You might find my rationale for thinking this interesting, though.

It&apos;s because it&apos;s not as confusing to deal with a re-executing decision (on restart). According to Sec 10.8, Part 3d., the decider always re-executes on a restart.  

So I think this could be fixed solely in the TCK.

But if it strikes people as interesting to be able to lift the restriction on re-execution of a decision, then maybe we put that on the table and add this to the SPEC column?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14529</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-09 19:09:15 +0000</bug_when>
    <thetext>Let&apos;s address this by:

 1. First fixing the TCK by shipping equivalent tests which use separate decisions so as not to loop.  (The tests are important so I want to fix and retain them, not exclude).

 2. Tagging as &apos;future&apos; and consider lifting the restriction later.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14785</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-12-17 17:21:14 +0000</bug_when>
    <thetext>Just to note, the following tests all also use an XML with a loop configured in it:
* DeciderTests#testDeciderTransitionFromFlowAndAllowRestart
* DeciderTests#testDeciderTransitionFromFlowAndAllowRestartFalse
* DeciderTests#testDeciderTransitionFromStepAndAllowRestart
* DeciderTests#testDeciderTransitionFromStepAndAllowRestartFalse
* DeciderTests#testDeciderTransitionFromStepWithinFlowAndAllowRestart
* DeciderTests#testDeciderTransitionFromStepWithinFlowAndAllowRestartFalse</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14786</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-12-17 17:26:35 +0000</bug_when>
    <thetext>Sorry.  I missed these two in my previous comment (they also are configured with a loop):

* DeciderTests#testDeciderTransitionFromSplitAndAllowRestart
* DeciderTests#testDeciderTransitionFromSplitAndAllowRestartFalse</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14840</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 03:47:20 +0000</bug_when>
    <thetext>Reviewed the relevant tests (thanks for listing them Michael) and for each JSL was able to &quot;break apart&quot; the single decision into multiple, similar decisions.   

Confirmed that there was no interesting test logic being exercised in having been using a single decision element previously.   

In the test method source I went and added the comments explain the @assertion, @test_Strategy tags explaining what the tests are supposed to be testing (e.g. the fact that decider return value becomes job exit status, etc.).   

I know there are quite a few methods missing these comments, though I only added them for now for these eight.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5431</bug_id>
          
          <creation_ts>2013-10-02 14:35:00 +0000</creation_ts>
          <short_desc>ItemProcessListener#onProcessError has javadoc from ItemProcessListener#afterProcess</short_desc>
          <delta_ts>2015-10-22 02:07:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>BrentDouglas</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>m_edgar</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14240</commentid>
    <comment_count>0</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2013-10-02 14:35:10 +0000</bug_when>
    <thetext>Except from artifact resolved from maven central with descriptor:

&lt;pre&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;javax.batch&lt;/groupId&gt;
                &lt;artifactId&gt;javax.batch-api&lt;/artifactId&gt;
                &lt;version&gt;1.0&lt;/version&gt;
            &lt;/dependency&gt;
&lt;/pre&gt;

 which I understand to be the RI of this spec.

&lt;pre&gt;
	/**
	 * The afterProcess method receives control after an item 
	 * processor processes an item.  The method receives the item processed 
	 * and the result item as an input.
	 * @param item specifies the item about to be processed.
	 * @param result specifies the item to pass to the item writer. 
	 * @throws Exception if an error occurs.
	 */
	public void afterProcess(Object item, Object result) throws Exception;
	/**
	 * The afterProcess method receives control after an item 
	 * processor processes an item.  The method receives the item processed 
	 * and the result item as an input.
	 * @param item specifies the item about to be processed.
	 * @param ex specifies the exception thrown by the item processor.
	 * @throws Exception
	 */
	public void onProcessError(Object item, Exception ex) throws Exception;
&lt;/pre&gt;

The issue being that the javadoc from #onProcessError should describe #onProcessError rather than #afterProcess.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14358</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-25 18:03:55 +0000</bug_when>
    <thetext>Reclassifying as this error appears in the spec as well as the RI.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14517</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-08 00:29:53 +0000</bug_when>
    <thetext>Since we already have a lot of bugs.... maybe I can sneak another one into this one:

In the spec, StepExecution still says: 
 getUserPersistentData();
but the RI/TCK say
 getPersistentUserData()</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14879</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-08 16:02:26 +0000</bug_when>
    <thetext>Fixed this and another small detail in ItemProcessListener&apos;s javadoc.

Also fixed ItemWriteListener&apos;s javadoc which had some copy/paste errors wrongly reflecting the ItemReadListener text.

Here are excerpts including the new versions of all changed Javadoc:

ItemProcessListener:
---------------------

	/**
	 * The afterProcess method receives control after an item 
	 * processor processes an item.  The method receives the item processed 
	 * and the result item as an input.
	 * @param item specifies the item processed by the item processor.
	 * @param result specifies the item to pass to the item writer. 
	 * @throws Exception if an error occurs.
	 */
	public void afterProcess(Object item, Object result) throws Exception;
	/**
	 * The onProcessError method receives control after an 
	 * item processor processItem throws an exception.  The method 
	 * receives the item sent to the item processor as input. 
	 * @param item specifies the item the processor attempted to process.
	 * @param ex specifies the exception thrown by the item processor.
	 * @throws Exception if an error occurs
	 */
	public void onProcessError(Object item, Exception ex) throws Exception;

=========================

ItemWriteListener:
------------------

	/**
	 * The beforeWrite method receives control before 
	 * an item writer is called to write its items.  The 
	 * method receives the list of items sent to the item 
	 * writer as an input.
	 * @param items specifies the items about to be 
	 * written.
	 * @throws Exception is thrown if an error occurs.
	 */
	public void beforeWrite(List&lt;Object&gt; items) throws Exception;
	/**
	 * The afterWrite method receives control after an 
	 * item writer writes its items.  The method receives the 
	 * list of items sent to the item writer as an input.  
	 * @param items specifies the items written by the item writer.
	 * @throws Exception is thrown if an error occurs.
	 */
	public void afterWrite(List&lt;Object&gt; items) throws Exception;
	
	/**
	 * The onWriteError method receives control after an 
	 * item writer writeItems throws an exception.  The method 
	 * receives the list of items sent to the item writer as input. 
	 * @param items specifies the items which the item writer
	 * attempted to write.
	 * @param ex specifies the exception thrown by the item 
	 * writer.
	 * @throws Exception is thrown if an error occurs.
	 */
	public void onWriteError(List&lt;Object&gt; items, Exception ex) throws Exception;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16852</commentid>
    <comment_count>4</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-09-18 20:13:45 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #1)
&gt; Reclassifying as this error appears in the spec as well as the RI.

Scott-
You mention that the error appears in the RI - are you referring to ChunkStepControllerImpl @ line 379? I&apos;m working with ItemProcessListener#onProcessError and have found that the first parameter will always be null when an exception occurs in processItem. Is that RI bug covered by this issue or should a new one be opened?

Mike</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19097</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 20:49:36 +0000</bug_when>
    <thetext>(In reply to m_edgar from comment #4)
&gt; I&apos;m working with
&gt; ItemProcessListener#onProcessError and have found that the first parameter
&gt; will always be null when an exception occurs in processItem. Is that RI bug
&gt; covered by this issue or should a new one be opened?

This was fixed in the RI in 
https://github.com/WASdev/standards.jsr352.jbatch/commit/1679181c
and released in 1.0.1.

Moving to TCK as a new test candidate (verify items passed to onXXXError listeners).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19356</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-10-22 02:07:50 +0000</bug_when>
    <thetext>Fixed in https://github.com/WASdev/standards.jsr352.tck/commit/f89b47e33920838b1355d50e329a5dc415cd6f4e</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5490</bug_id>
          
          <creation_ts>2013-10-24 18:50:00 +0000</creation_ts>
          <short_desc>Clarify JobContext/StepContext properties;  fix TCK to not depend on writable Properties</short_desc>
          <delta_ts>2015-09-03 21:22:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14355</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-24 18:50:45 +0000</bug_when>
    <thetext>This is mainly a TCK bug... (see public ML discussion with subject &quot;...Should StepContext.getProperties() be allowed to hold application data?&quot;.

However I&apos;m listing it in &apos;spec&apos; category since it would only help to clarify the expectations here, namely:

1) the Properties are not necessarily writable.
2) the runtime may provide additional properties in addition to the ones corresponding to JSL elements.  

We might debate whether 2) is really worth saying, but it is here noted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14481</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-05 19:06:53 +0000</bug_when>
    <thetext>Note the 2013-11-06 update of the SE TCK has resolved this issue from the TCK perspective (by switching to use transient user data).

Leaving the bug open to track a spec clarification.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14867</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 18:54:10 +0000</bug_when>
    <thetext>*** Bug 4710 has been marked as a duplicate of this bug. ***</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14871</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 20:36:36 +0000</bug_when>
    <thetext>Javadoc updated as follows:

JobContext:
----------------------------------------

java.util.Properties getProperties()

The getProperties method returns the job level properties specified in a job definition.

A couple notes:

    There is no guarantee that the same Properties object instance is always returned in the same (job) scope.
    Besides the properties which are defined in JSL within a child &lt;properties&gt; element of a &lt;job&gt; element, the batch runtime implementation may choose to include additional, implementation-defined properties. 

Returns:
    job level properties
----------------------------------------

StepContext:
----------------------------------------
java.util.Properties getProperties()

The getProperties method returns the step level properties specified in a job definition.

A couple notes:

    There is no guarantee that the same Properties object instance is always returned in the same (step) scope.
    Besides the properties which are defined in JSL within a child &lt;properties&gt; element of a &lt;step&gt; element, the batch runtime implementation may choose to include additional, implementation-defined properties. 

Returns:
    step level properties
----------------------------------------</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19104</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 21:22:51 +0000</bug_when>
    <thetext>Not sure what we could test here in the TCK so closing.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5498</bug_id>
          
          <creation_ts>2013-10-28 14:59:00 +0000</creation_ts>
          <short_desc>Add &quot;mark FAILED&quot; to BatchStatus state transitions</short_desc>
          <delta_ts>2015-09-03 20:57:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14373</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-10-28 14:59:43 +0000</bug_when>
    <thetext>Should state transition include mention that, for something like a JVM that dies... SOMEONE must set a job status to FAILED in order to restart.

See Mailing List dicusssion:
https://java.net/projects/jbatch/lists/public/archive/2013-10/message/33


Add, for example, 
E.g. in Sec. 10.8:

&quot;In the case of a job that ...... e..g hung JVM.... etc....  
  It is expected that an implementation provides some implementation-specific mechanism for transitioning BatchStatus to FAILED state, so that it can be restarted.  This mechanism can be executed automatically by the implementation or via an implementation-defined manual operation.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14894</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-08 23:07:02 +0000</bug_when>
    <thetext>At the very end of Section 8.7, (after both numbered lists), add the following completely new paragraphs:

--------

  In addition to these conditions and events which are well-defined by this specification, it is also recognized that the runtime may be forced to make another transition of job and step batch status.    

  For example, a JVM hang may cause a job to appear in STARTED state even though it is no longer running.  The specification forbids running multiple executions of a given job instance at the same time.   In order to recover and allow restart it is expect that a batch runtime implementation might provide a mechanism to automatically or through user intervention mark the appropriate job and step execution(s) as FAILED  (i.e. set the batch status as FAILED).   

  The details are left entirely to the implementation, we are just recognizing here that this is a valid state transition.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5533</bug_id>
          
          <creation_ts>2013-11-07 05:05:00 +0000</creation_ts>
          <short_desc>stop/end/fail exit-status should affect job exit status, not step (as claimed in spec).</short_desc>
          <delta_ts>2015-09-03 21:24:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>1.0_mr_pending</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14506</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-07 05:05:32 +0000</bug_when>
    <thetext>For each of stop/end/fail, the spec says that the &apos;exit-status&apos; attribute specifices the step exit status rather than the job exit status.

That&apos;s contrary to 4).   The TCK as I recall, (and looking quick it looks like BatchletRestartStateMachineTests would be an example) assumes this affects
the job exit status which fits with rule 4).

So I think we should treat this as a spec bug... and update the spec to clarify this is the job &apos;exit-status&apos;.  

That interpretation would also makes the last part of 8.7.1 meaningless. 

Step termination may be optionally configured in the Job XML using the terminating transition elements, fail, end, or stop. These elements can also set the exit status. Note that setting the exit status programmatically through the StepContext object overrides setting the exit status through any of these element types.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14530</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-09 21:12:02 +0000</bug_when>
    <thetext>Let&apos;s also use this to fix the spec typo on p. 45:

saying that for &apos;stop&apos; element&apos;s restart attribute &quot;This is a required attribute.&quot;

As the XSD shows, it&apos;s actually optional.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14906</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-09 21:44:55 +0000</bug_when>
    <thetext>The first 6 changes are the same two copied three times (for each of fail, end, stop).  Then there are a few additonal related ones.  

Since we had some discussion on the public ML, it seemed worthy of the example I included below.

------------------------------------------------------------------------------

1) Changed Section 8.6.2 (Fail Element) initial paragraph to:

The fail element is used to terminate the job at the conclusion of the current step or flow. The job batch status is set to FAILED.   This does not, however, directly affect the batch status of the parent (containing) step of the fail element.   Multiple fail elements may be specified in the current containment scope.   The fail element is supported as a child of the step, flow, and decision elements.  

2) Also in 8.6.2, change &apos;exit-status&apos; attribute description to:

Specifies the new exit status for the job. It must be a valid XML string value.  This is an optional attribute.  If not specified, the job-level exit status is unchanged.  This attribute does not directly change any step exit status (particularly the step which is the parent of this fail element).

---

3) Changed Section 8.6.3 (End Element) initial paragraph to:

The end element is used to terminate the job at the current step.  The job batch status is set to COMPLETED.  This does not, however, directly affect the batch status of the parent (containing) step of the end element.  Multiple end elements may be specified in the current containment scope. The end element is supported as a child of the step, flow, and decision elements.

4) Also in 8.6.3, change &apos;exit-status&apos; attribute description to:

Specifies the new exit status for the job. It must be a valid XML string value.  This is an optional attribute.  If not specified, the job-level exit status is unchanged.  This attribute does not directly change any step exit status (particularly the step which is the parent of this end element).

---

5) Changed Section 8.6.4 (Stop Element) initial paragraph to:

The stop element is used to terminate the job after the current step or flow.  If the stop element matches the exit status, the job-level batch status is then set to STOPPED.   This does not, however, directly affect the batch status of the parent (containing) step of the stop element.   Multiple stop elements may be specified in the current containment scope.  The stop element is supported as a child of step, flow, and decision elements.

6) Also in 8.6.4, change &apos;exit-status&apos; attribute description to:

Specifies the exit status for the job. It must be a valid XML string value.  This is an optional attribute.  If not specified, the job-level exit status is unchanged.  This attribute does not directly change any step exit status (particularly the step which is the parent of this stop element).

---

7) In 8.6.4 (Stop Element), change the last sentence of the &apos;restart&apos; attribute description to:

This is an optional attribute.

---

8) Bigger change, with example to clarify..

Replace entire paragraph (i.e. delete old paragraph) starting with:
 &quot;Step termination may be optionally configured....&quot;

with replacement paragraphs (with example):


  An important point to note is that transition elements do not affect the batch and exit status of their containing step (for a step with one or more child transition elements), but only potentially affect the batch and exit status of the job.

Example:
  &lt;step id=FS1&gt;
        &lt;batchlet  &gt;
	&lt;next on=&quot;RC0 /&gt;
	&lt;fail on=&quot;RC4 exit-status=BAD/&gt;
	&lt;fail on=&quot;RC8 /&gt; 
 &lt;/step&gt;

Suppose for the above example JSL snippet, FS1s batchlet executes normally with an exit status of RC4.     Then step FS1s batch status will end up as COMPLETED, and FS1s exit status will end up as RC4.   The jobs batch status will end up as FAILED and the jobs exit status will end up as BAD.    Likewise, if the batchlet completes with an exit status of RC8 the steps batch and exit status will be COMPLETED and RC8, respectively, while the jobs batch and exit status will be FAILED and FAILED (assuming the job exit status hasnt been set and defaults in this case).

Note the implications for restart processing.   For example, a completed step wont re-run just because the step includes a transition element failing the job on the original step executions exit status. See section 10.8 for more on restart processing.

9) Sec. 8.7.2 Exit Status for Partitioned Steps
It&apos;s hard to separate out the change for this particular bug from changes for others.

The key point to note here is that we no longer say the step exit status is affected by &quot;1. transition elements stop, end, fail&quot;, which had appeared in the numbered list.  (The list is gone now).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14941</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-14 19:04:50 +0000</bug_when>
    <thetext>Section 8.6.2
In a number of areas, the new verbiage refers to a &quot;parent (containing) step&quot;.  Can we drop the word parent and just use containing?  Since inheritance was originally a feature that was in the spec (and I&apos;m hoping will be resurrected in a future version), I&apos;d rather just leave any verbiage that implies inheritance out of the current version.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14945</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-14 20:28:06 +0000</bug_when>
    <thetext>Hadn&apos;t thought of that context as a source of confusion.

I was hedging I think in case anyone thought that &quot;containing&quot; was less precise than parent...  But I think &quot;containing&quot; would be clear enough and avoid inheritance confusion.

Going to add &quot;1.0_mr_planned&quot; to the whiteboard tag to queue up this change as a TODO.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15134</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 13:09:31 +0000</bug_when>
    <thetext>Replaced &quot;parent&quot; with &quot;containing&quot;.  Refer to the in-document change history (via comments) in the new draft to see exactly where.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19105</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 21:24:32 +0000</bug_when>
    <thetext>As mentioned before I think the BatchletRestartStateMachineTests tests already enforce this.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5583</bug_id>
          
          <creation_ts>2013-11-20 15:36:00 +0000</creation_ts>
          <short_desc>CheckpointAlgorithm needs to specify timeunit (seconds) and other javadoc fixes</short_desc>
          <delta_ts>2015-09-03 17:42:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14613</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2013-11-20 15:36:42 +0000</bug_when>
    <thetext>CheckpointAlgorithm method
int checkpointTimeout() throws Exception

does not specify the timeunit (seconds) for the return value in the current javadoc: 

http://docs.oracle.com/javaee/7/api/javax/batch/api/chunk/CheckpointAlgorithm.html

Its javadoc contains a @param, but this method has no param.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14843</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 20:13:35 +0000</bug_when>
    <thetext>Just looking at this again.  I ran Checkstyle against the API package, and got 157 warnings.   A good chunk of these reflect the fact that we didn&apos;t comment each of the exception constructors, which I don&apos;t think is a big deal.But I&apos;m going to have to spend some time sorting through this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14908</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-09 23:11:00 +0000</bug_when>
    <thetext>Fixed this one method with this Javadoc text:

	/**
	 * The checkpointTimeout is invoked at the beginning of a new 
	 * checkpoint interval for the purpose of establishing the checkpoint 
	 * timeout. 
	 * It is invoked before the next checkpoint transaction begins. This 
         * method returns an integer value, which is the timeout value (expressed
         * in seconds) which will be used for the next checkpoint transaction.  
         * This method is useful to automate the setting of the 
	 * checkpoint timeout based on factors known outside the job 	
	 * definition. 
	 * 
	 * @return the timeout interval (time unit = seconds) to use for the 
         * next checkpoint interval 
	 * @throws Exception thrown for any errors.
	 */
	public int checkpointTimeout() throws Exception;

Made some other changes..  I don&apos;t think it&apos;s too interesting to list them all.  A couple were bugs but most were additions of things that had been omitted up until now.

One I caught was:  in the spec we have a method described as StepExecution#getUserPersistentData but in the RI and TCK it&apos;s been changed to StepExecution#getPersistentUserData.  So I updated the spec accordingly (I may have mentioned this in another bug).

Note the spec contains a lot of the Javadoc but not 100% of the RI&apos;s API Javadoc, so not every update will go into the spec.   Will try to refresh the spec with the latest Javadoc but this is a bit of a manual merge and my master copy is the RI.   

In other words, help keep me honest here if you see additional bugs in Javadoc.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5597</bug_id>
          
          <creation_ts>2013-11-26 21:54:00 +0000</creation_ts>
          <short_desc>BatchletRestartStateMachineTests#testAllowStartIfCompleteRestartExecution  off-by-1 error omits test clause</short_desc>
          <delta_ts>2014-01-03 03:38:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_1.0</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14641</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-11-26 21:54:36 +0000</bug_when>
    <thetext>In BatchletRestartStateMachineTests#testAllowStartIfCompleteRestartExecution, the loop:

  for (int i = 1; i &lt; 6; i++)

fails to check the status on execution #6, which was the original intent.

---

Will have to think a bit about what mechanism to use to fix this... especially given the fact that this is adding a new requirement to executors (though an uncontroversial one hopefully).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14838</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 03:38:16 +0000</bug_when>
    <thetext>Reviewed the test and convinced myself that this should be an uncontroversial addition.  I.e. it seems very unlikely that an implementation could be fully compliant with the rest of the TCK, yet not pass this new assertion.  

So the test was fixed to perform checking on all six loop iterations.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5602</bug_id>
          
          <creation_ts>2013-11-28 12:31:00 +0000</creation_ts>
          <short_desc>BatchStatus in JobStatus should be always initialised</short_desc>
          <delta_ts>2015-09-03 16:11:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ccerbo</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>ccerbo</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14649</commentid>
    <comment_count>0</comment_count>
    <who name="">ccerbo</who>
    <bug_when>2013-11-28 12:31:27 +0000</bug_when>
    <thetext>JobStatus has two constructors, but only in the second one the BatchStatus is set to STARTING. I think, it should be STARTING in both cases.

Otherwise when I try to restart a Job that was interrupted by killing the JVM (SE modus), the following exception is thrown (because JobStatus#batchStatus is null):

java.lang.IllegalStateException: On restart, we didn&apos;t find an earlier batch status.
	at com.ibm.jbatch.container.jobinstance.JobExecutionHelper.validateJobInstanceNotCompleteOrAbandonded(JobExecutionHelper.java:183)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14901</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-09 15:18:04 +0000</bug_when>
    <thetext>Thanks for the description.  Yes, looks like an easy change.

In noting this, I&apos;m also acknowledging we plan on actually delivering this fix but I don&apos;t have a target date yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19087</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:11:56 +0000</bug_when>
    <thetext>Fixed in java.net Git repo commit:
83ff53fdc546e109a4ad24b5c34976859b8c3d08

Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5614</bug_id>
          
          <creation_ts>2013-12-03 23:08:00 +0000</creation_ts>
          <short_desc>TCK expects JobExecution to be updated as job runs</short_desc>
          <delta_ts>2014-01-03 03:42:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_1.0</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14679</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-12-03 23:08:18 +0000</bug_when>
    <thetext>This is essentially re-opening of 5371.  The TCK expects that a JobExecution is being updated behind the scenes instead of getting a new instance before checking the state.  The list below is what I have currently identified and will add tests to this list as I find more.

* JobOperatorTests#testInvokeJobWithUserStop()
* ParallelExecutionTests#testStopRunningPartitionedStep()
* ParallelExecutionTests#testStopRestartRunningPartitionedStep()
* StopOrFailOnExitStatusWithRestartTests#testInvokeJobWithUserStopAndRestart()

My guess is that most of the places JobOperatorBridge#*AndWaitForResult are called will need updates.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14839</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-03 03:42:22 +0000</bug_when>
    <thetext>Fixed all these and will also mention that I found another similar issue with the testInvokeJobWithUserStopAndRestart() test.

If we&apos;re going to look at the BatchStatus before waiting for a terminating status, then we should allow we might see a status of STARTING (we&apos;d been expecting STARTED).   Fixed this as well.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5655</bug_id>
          
          <creation_ts>2013-12-18 19:50:00 +0000</creation_ts>
          <short_desc>ChunkTests for skipping writes don&apos;t go far enough</short_desc>
          <delta_ts>2015-09-03 14:24:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_future</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14790</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-12-18 19:50:21 +0000</bug_when>
    <thetext>ChunkTests#testChunkSkipWrite and ChunkTests#testChunkSkipWriteExceedSkip verify that the list the SkipWriteListener receives does not have any nulls in it, but it does not verify the number of items in the list (or that the items are the correct ones for that matter).  We noticed this on accident by just wrapping the Spring Batch equivalent of this listener.  In SB, by default, we only pass in the item that was skipped (instead of all of the items in the current chunk as the spec requires).  When we wrap the SB functionality (passing a new list that contains only the skipped item to the listener), the test passes even though the implemented behavior is incorrect.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19078</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 14:24:51 +0000</bug_when>
    <thetext>Moving to:
https://github.com/WASdev/standards.jsr352.tck/issues/5</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5675</bug_id>
          
          <creation_ts>2013-12-31 15:53:00 +0000</creation_ts>
          <short_desc>Metric values are 0 when batch runs in a partition</short_desc>
          <delta_ts>2015-09-01 21:05:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>radcortez</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>m_edgar</cc>
    
    <cc>radcortez</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14827</commentid>
    <comment_count>0</comment_count>
    <who name="">radcortez</who>
    <bug_when>2013-12-31 15:53:28 +0000</bug_when>
    <thetext>When running a job with a partition, the Metric array from the StepExecution has all it&apos;s values equal to 0. Removing the partition, the Metric array shows the expected values for the data processed.

You can check a couple of test cases the reproduce the problem here:

https://arungupta.ci.cloudbees.com/job/Java%20EE%207%20Samples%20on%20GlassFish-cb/76/testReport/org.javaee7.batch.sample.chunk.partition/BatchChunkPartitionTest/testBatchChunkPartition/

https://arungupta.ci.cloudbees.com/job/Java%20EE%207%20Samples%20on%20GlassFish-cb/76/testReport/org.javaee7.batch.sample.chunk.mapper/BatchChunkMapperTest/testBatchChunkMapper/

And here is the code:

https://github.com/radcortez/javaee7-samples/tree/master/batch/chunk-mapper
https://github.com/radcortez/javaee7-samples/tree/master/batch/chunk-partition</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14828</commentid>
    <comment_count>1</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2013-12-31 21:26:28 +0000</bug_when>
    <thetext>Since I believe it to be related, it&apos;s worth noting that the persistent user data is also not available for partitioned steps. I&apos;m guessing that a solution won&apos;t be possible with the 1.0 specification (since the persistent data can&apos;t be aggregated like the Metrics can be, possibly).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14829</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-12-31 22:38:40 +0000</bug_when>
    <thetext>Hi, I had realized the Metrics weren&apos;t set up correctly for partitioned steps, thanks for opening the bug to track this.

---

Question to m_edgar:  what issue are you having with the persistent user data?  

I&apos;m wondering if this is working as designed and your issue relates to the fact that each partition gets its own StepContext, and along with it its own persistent data, in addition to the top-level thread&apos;s StepContext and persistent data.   

Could you give some sample code and explain?

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14832</commentid>
    <comment_count>3</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-01-02 01:04:31 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #2)

Scott - 
The persistent data is working as expected within the partitions as they execute. However, my issue is with accessing the data via the job operator and StepExecution list. Since only the execution representing the parent thread of the step is returned, none of the details of the partitions is available. 

It seems that the missing metrics from the parent of the step is the same situation, since they are present on the child records as seen in the job repository. 

Would a modified runtime which returns both the parent as well as the children step executions for a particular step still be in compliance with the specification? It seems to me that it (the spec) doesn&apos;t necessarily indicate whether the StepExecution list returned by the job operator are for the parent, the children, or both.

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15128</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 11:36:05 +0000</bug_when>
    <thetext>While we could improve the behavior in the RI alone w/o a spec update, this isn&apos;t the first time we&apos;ve touched on a need to possibly consider from a spec view how to view the partition-level equivalent of StepExecution.  

Marking as &quot;SPEC&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17060</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-01 03:36:33 +0000</bug_when>
    <thetext>I&apos;m breaking off the idea of a partition-level StepExecution into Bug 6490, since this would require a new API.

For this bug, 5675, we&apos;ll just fix the RI to aggregate the metrics.   I started it but haven&apos;t finished yet.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17076</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-05 19:46:05 +0000</bug_when>
    <thetext>Fixed in:
https://github.com/WASdev/standards.jsr352.jbatch/commit/8a82576ae3f85aaf9d00c09045e63c8f1055b342</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17077</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-05 19:47:52 +0000</bug_when>
    <thetext>Fixed in:
https://github.com/WASdev/standards.jsr352.jbatch/commit/8a82576ae3f85aaf9d00c09045e63c8f1055b342

We aggregate the metrics (not mentioned in spec IIRC but probably non-controversial).  We only do the summation on a successful execution.   If we blow up before then you&apos;ll never see the metrics again (avoids the need to understand when they need updating).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17085</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-07 11:26:22 +0000</bug_when>
    <thetext>Extended fix to case where partition runs from a split-flow in:

https://github.com/WASdev/standards.jsr352.jbatch/commit/151a0060b89d0a4f5f81ed9a942c100525d79834</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19062</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:05:52 +0000</bug_when>
    <thetext>Marking as resolved, now that the RI 1.0.1 version has been released.

I&apos;ll just note that the behavior of aggregating the metrics should probably be considered to be an RI-specific behavior at this time (not required by the standard).   If someone feels a need to clarify this at the spec level, please raise a new issue.  I think it&apos;s OK to leave this for now.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5690</bug_id>
          
          <creation_ts>2014-01-07 15:54:00 +0000</creation_ts>
          <short_desc>Flow/Split transitioning &amp; termination not fully defined</short_desc>
          <delta_ts>2015-09-03 20:56:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14864</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 15:54:53 +0000</bug_when>
    <thetext>See public ML discussion: &quot;DISCUSSION: Dealing with the fact that Flow and Split Transitioning incompletely defined in 1.0 Maintenance release spec errata&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14916</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 10:21:32 +0000</bug_when>
    <thetext>I consider this still up for discussion..more so than usual.

I&apos;m writing it up though since I took the step of including it in my draft PDF.. so it&apos;s &quot;advanced through the process&quot; in that sense.

Three changes:

---
1) Replaced &quot;Split termination processing&quot; in Sec. 8.4. with new subsection:


8.4.1	Split Termination Processing - Incomplete

The effort of the initial 1.0 final release specification  to define split termination processing is recognized as incomplete.   This is related to the recognition that flow transitioning is incomplete (section 8.9.5).

As such, there is no well-defined mechanism for passing back status from the individual child flows of a split and aggregating them into a status at the split level.   There is, accordingly, no termination based on the status of the constituent flows performed after a split execution.   

However, the implementor must be aware that a split may have a child flow where the flow itself or a flows child (step, decision, etc.) causes the job execution to terminate.    This could be via an end, stop, or fail transition element, or via an unhandled exception.

In such a case the job should then cease execution before transitioning past the current, containing split, on to the next execution element.

Typically only one such element (in one single flow) would terminate job execution, with a corresponding batch and exit status that would then be set by the implementation as the job-level batch status and exit status, since typically the whole split would be intended to complete.

The spec does not make an effort, then, to define the outcome if more than one flow within a split produced a terminating status.     A suggestion, though, is that a FAILED batch status should be given preference to STOPPED, which should be given preference to COMPLETED status, and a natural corollary might be to bubble up the associate exit status as the job-level exit status as well.

----
2)  Added new subsection 8.9.5 to new section 8.9 (which was added for other bugs)

8.9.5 Flow-level Transitions Undefined

It is recognized that the specification is incomplete with respect to how exactly flow transition elements are evaluated.   Though the list in section 10.8 has an assertion in rule 3.e. that suggests using the exit status of the last contained execution element as a flow-level exit status, this does not seem to be a complete definition.     For example, what if the last execution element within the flow is a split?

This might be rectified in a later revision of this specification.  In the meantime it is suggested to avoid using flow-level transition elements in light of this ambiguity.
----
3) Added this sentence to the end of Rule 3.e. within section 10.8:

(Note that Section 8.9.5 describing a problem such that this statement is considered incomplete.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14940</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-01-14 19:04:08 +0000</bug_when>
    <thetext>Section 8.4.1 &amp; Section 8.9.5
I don&apos;t think we can leave the spec saying &quot;this section is incomplete&quot;.  We need to have an answer of some kind in order for it to be a final version of the spec.  Either we disallow splits or we allow them and define the rules for it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14944</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-14 20:14:30 +0000</bug_when>
    <thetext>It seems too heavy-handed to react to an incomplete specification by adding an errata saying this is flat-out illegal.    

Maybe saying &quot;this section is incomplete&quot; is the wrong way to package it, but I feel like it is legitimate to say &quot;the behavior with this combination of elements is undefined&quot;.   

I think we need to do something here.  

Another option might be to first try to reach consensus on what flow/split transitioning should entail, and then decide whether it seems legitimate to add that as a spec errata or not.    I took the approach I did since my guess was that whatever we&apos;d come up with would be hard to &quot;sell&quot; as purely an errata, but that&apos;s just my opinion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19100</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 20:56:26 +0000</bug_when>
    <thetext>Since this has been left &quot;undefined&quot;, I can&apos;t see what we could test here. Closing.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5691</bug_id>
          
          <creation_ts>2014-01-07 20:57:00 +0000</creation_ts>
          <short_desc>&quot;Looping&quot; should be clarified?</short_desc>
          <delta_ts>2016-03-17 19:48:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>14872</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-07 20:57:10 +0000</bug_when>
    <thetext>It&apos;s been bothering me somewhat that the prohibition on looping is not precisely defined... enough to write something up.

Note this builds on the concept laid out in Sec. 10.8 during restart where we transition through the job definition, as we determine what does and doesn&apos;t need to be executed/re-executed (though &quot;transitioned to&quot; isn&apos;t quite precisely defined either).

Any thoughts?

------------------------------------------------------------------------------

8.6.6.1	Loop definition

The specification prohibits next and to attribute values that result in a loop.  More precisely, this means that no execution element can be transitioned to twice within a single job execution.     

This wording is purposely written this way rather than merely saying no execution element can be executed twice within a single job execution.     Say step1 executed to completion during an initial execution which ultimately failed, and upon restart we transitioned past step1 without executing it since it had already completed, but we subsequently transitioned (back) to step1.   This may only be a single execution of step1 during a single job execution, but it still violates the looping prohibition.

The runtime may detect potential loops in an initial validation phase, as described in section 13.1, or may only detect loops once they occur.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>14915</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-10 10:14:55 +0000</bug_when>
    <thetext>Added new subsection under new section 8.9 (added for Bugs 5732-4).
---

8.9.3	Loop definition

The specification prohibits next and to attribute values that result in a loop.  More precisely, this means that no execution element can be transitioned to twice within a single job execution.     

This wording is purposely written this way rather than merely saying no execution element can be executed twice within a single job execution.     Say step1 executed to completion during an initial execution which ultimately failed, and upon restart we transitioned past step1 without executing it since it had already completed, but we subsequently transitioned (back) to step1.   This may only be a single execution of step1 during a single job execution, but it still violates the looping prohibition.

The runtime may detect potential loops in an initial validation phase, as described in section 13.1, or may only detect loops once they occur.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19098</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 20:51:56 +0000</bug_when>
    <thetext>Might be nice to have the invalid JSL example I mentioned, where you didn&apos;t actually execute an element twice but you &quot;looped back&quot; to it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19824</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:48:12 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/31</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5746</bug_id>
          
          <creation_ts>2014-01-28 00:26:00 +0000</creation_ts>
          <short_desc>@Inject @BatchProperty should work for job level properties</short_desc>
          <delta_ts>2017-04-08 08:25:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>reza_rahman</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>diherbalselalu</cc>
    
    <cc>issues</cc>
    
    <cc>matias-uy</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15038</commentid>
    <comment_count>0</comment_count>
    <who name="">reza_rahman</who>
    <bug_when>2014-01-28 00:26:37 +0000</bug_when>
    <thetext>Currently this type of injection does not work in the RI which is surprising. The spec itself seems ambiguous as to whether job level properties can be injected.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15041</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-01-28 15:33:30 +0000</bug_when>
    <thetext>Let me restate what I think you&apos;re saying.

If you have:

&lt;job&gt;
 &lt;properties&gt;
   &lt;property name=&quot;x&quot;...
     ...
    &lt;step id=&quot;step1&quot;&gt;
      &lt;batchlet ..&gt;
         &lt;properties/&gt;  &lt;!-- EMPTY --&gt;
&lt;/job&gt;

Then you will NOT be able to inject this into the batchlet:

@BatchProperty(name=&quot;x&quot;) 

---
I&apos;d have to agree with you that the spec doesn&apos;t make this extremely clear.

All I see now is that in Section 9.3 we have:

&quot;Note batch properties are visible only in the scope in which they are defined.&quot;
---

Recognizing the ambiguity we did consult the mailing list, and, as I recall, we tried to enforce this behavior in the TCK (we had some other issues with properties so I&apos;d have to go back and check if it&apos;s still enforced).

---

At least maybe we should add something here for the spec errata maintenance release we&apos;re working on currently.    (I&apos;d do a more careful search to be sure we didn&apos;t have better language.

I wouldn&apos;t jump to look at changing this behavior though (e.g. in a possible 1.1), as it would seem to introduce compatibility issues.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15142</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 20:27:07 +0000</bug_when>
    <thetext>Added the following two changes.  

Note the second is only peripherally related, I just used it as an opportunity to more precisely state the defaulting behavior when @BatchProperty is used without a corresponding JSL property.

---

1)  Added new section:

9.3.2	Scope of property definitions for @BatchProperty injection

The rules governing the definition of properties for injection via @BatchProperty deserve some extra explanation and an example.
For a given artifact, the only properties that are injectable via @BatchProperty are those which are defined at the level of the artifact itself (i.e. as children of the properties element which is in turn a child of the very element defining the artifact:  batchlet, reader, listener, etc.).
In particular, just because an artifact definition is contained (at some level of nesting) within a job element and (for most artifacts) within a step element as well, it is NOT the case that the job properties and step properties are themselves injectable into that artifact via @BatchProperty.     This is the case even though these job and step properties are available for resolving the artifact-level property definitions via the jobProperties substitution mechanism (see section 8.8.1.2) .

The following example should make this more clear:

Example JSL:
&lt;job&gt;
 &lt;properties&gt;
   &lt;property name=&quot;x&quot; value=xVal/&gt;
     ...
    &lt;step id=&quot;step1&quot;&gt;
      &lt;batchlet ref=MyBatchlet&gt;
         &lt;properties&gt; 
             &lt;property name=y value=#{jobProperties[x]}/&gt;
         &lt;/properties&gt;
 
Example Java (MyBatchlet from JSL above):
  // WONT WORK! - There is no property x in scope for this injection
  @Inject @BatchProperty(name=&quot;x&quot;);    

  // WILL WORK  Gets value xVal
  @Inject @BatchProperty(name=&quot;y&quot;);  

------------------------------------------------------------------------------

2) Changed the last portion of Section 9.3.1 to:

The value of the annotated field is assigned by the batch runtime if a corresponding property element with a matching name is specified in the JSL in the scope that applies to the batch artifact in question. If the JSL property value resolves to the empty string (either explicitly set to the empty string literal or resolving to an empty string via property substitution  see section 8.8), no assignment is made and the resulting value is undefined by the batch specification.    The resulting value might simply be the Java default value, however using various dependency injection technologies may produce different results.  The resultant behavior may be defined by the particular dependency injection technology used in the runtime environment and so is outside the scope of this specification.

Example:
import javax.inject.Inject;
import javax.batch.api.BatchProperty;
public class MyItemReaderImpl {
	@Inject @BatchProperty String fname;
}

Behavior:

When the batch runtime instantiates the batch artifact (item reader in this example),  it assigns  the 
value of the property with name equal to fname provided in the job XML to the corresponding @BatchProperty field named fname.  If no value is defined in JSL, the Java default (null)  is assigned or some other default is provided by a particular dependency injection technology.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15150</commentid>
    <comment_count>3</comment_count>
    <who name="">cf126330</who>
    <bug_when>2014-02-14 16:46:05 +0000</bug_when>
    <thetext>In the above example, [x] should be [&apos;x&apos;]
&lt;property name=y value=#{jobProperties[x]}/&gt;

I also prefer to make artifact properties self-contained. Many batch artifacts are developed as off-the-shelf components, and assume no direct influence from their enclosing job or step properties.  If some artifact properties (flags, feature configurations, etc) are not defined, then the artifact class expects this property is not there and will use a sensible default.

@Named
public class MyReader implements ItemReader {
  //debug flag should be configured only thru myReader properties in job xml
  @Inject
  @BatchProperty
  private String debug;

  public void readItem() throws Exception {
    if(debug!=null) {...

    }

}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16859</commentid>
    <comment_count>4</comment_count>
    <who name="">matias-uy</who>
    <bug_when>2014-09-20 18:28:26 +0000</bug_when>
    <thetext>Is this bug related to this other bug?:
https://java.net/bugzilla/show_bug.cgi?id=6420</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16864</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-22 13:43:50 +0000</bug_when>
    <thetext>(In reply to matias-uy from comment #4)
&gt; Is this bug related to this other bug?:
&gt; https://java.net/bugzilla/show_bug.cgi?id=6420

This &quot;bug&quot; (in 5746) turns out to be &quot;working as designed&quot;, and the spec was updated to clarify this.

I haven&apos;t had a chance to look at Bug 6420 yet though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16865</commentid>
    <comment_count>6</comment_count>
    <who name="">matias-uy</who>
    <bug_when>2014-09-22 15:40:02 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #5)
&gt; (In reply to matias-uy from comment #4)
&gt; &gt; Is this bug related to this other bug?:
&gt; &gt; https://java.net/bugzilla/show_bug.cgi?id=6420
&gt; 
&gt; This &quot;bug&quot; (in 5746) turns out to be &quot;working as designed&quot;, and the spec was
&gt; updated to clarify this.
&gt; 
&gt; I haven&apos;t had a chance to look at Bug 6420 yet though.

I am sorry for the word&apos;s choice. I&apos;m uruguaian and do not speak english like I would like (spanish is my matternal language). I did not mean that it was a bug of the framework. What I tried to say was if this thing that you were discussing was related with Bug 6420 (I am not sure that Bug 6420 is even a bug).

Thanks! Matias</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19825</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:50:17 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/32</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543606</commentid>
    <comment_count>8</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:23:51 +0000</bug_when>
    <thetext>Just keep write what you are passionate about, and the visitors will come to your post. http://warungkopi.okezone.com/thread/612507/obat-miom-alami

Very nice post. I just bookmark your page and want to says that I have truly enjoyed browsing your weblog posts. Thanks https://docs.google.com/document/d/1oTQDEXPEScqivTSyj8VKN5FuF4ZiE7yBYDjnNk6oeOk/

This article gives the light in which we could notice the reality. This can be very nice one and gives indepth information. Gratitude for this good article. http://colivre.net/diherbal/obat-miom-herbal-tanpa-operasi</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543614</commentid>
    <comment_count>9</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:24:36 +0000</bug_when>
    <thetext>As part of a school thesis for research I&apos;ve got to search sites with relevant information on given topic and provide them to teacher our opinion and the article. Your blog helped me a lot.  https://xplor.xl.co.id/t5/Lounge/Obat-Herbal-Diabetes-Tipe-2/m-p/45448

This really is my first time visit here. From the tons of comments on your articles, I imagine I am not just one having all the enjoyment here! https://web.alvernia.edu/eportfolio/view/view.php?id=13287

I just couldn&apos;t leave your website before telling you that I truly enjoyed the best quality details you present for your visitors? Will be returning again frequently to check up on brand new article. https://cs.byu.edu/job-posting/obat-herbal-diabetes-melitus-tipe-2</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543615</commentid>
    <comment_count>10</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:25:33 +0000</bug_when>
    <thetext>Your article had provided me with another point of view on this topic. I had no idea that things will most likely work on this fashion as well. Thank you for sharing your perspective. http://colivre.net/diherbal/obat-asam-urat-alami-paling-ampuh

I would really like to thank you for your effectively written article it&apos;s useful and  your writing design helped me to it without the difficulty. Thanks alot : ) http://uiupdate.ui.ac.id/blog-entry/obat-herbal-asam-urat-paling-ampuh

I found useful information on this topic as Now i&apos;m taking care of a company project. Thanks a lot posting relative information and its now becoming easier to completely finish this project http://scoophot.com/blog/471421ae-34e3-4c79-8370-6c9563146df7</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5748</bug_id>
          
          <creation_ts>2014-01-28 17:49:00 +0000</creation_ts>
          <short_desc>#{jobProperties} property resolution unavailable within JSL partition</short_desc>
          <delta_ts>2015-09-01 20:45:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>m_edgar</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15042</commentid>
    <comment_count>0</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-01-28 17:49:09 +0000</bug_when>
    <thetext>Following up on the recent discussion on the public mailing list.

In PartitionPropertyResolverImpl, null values are sent to each child element&apos;s resolver rather than the parent properties which contain the job properties.

------ Scott Kurz example below:

So this would maybe net out to something like this example collector
property &apos;xx&apos; not getting set up correctly.

&lt;step id=&quot;step1&quot;&gt;
  &lt;properties&gt;
    &lt;property name=&quot;stepProp&quot; value=&quot;stepPropValue&quot; /&gt;
  &lt;/properties&gt;
  &lt;batchlet ...
    &lt;properties&gt;
      &lt;property name=&quot;partitionString&quot; value=&quot;#{partitionPlan[&apos;part&apos;]}&quot; /&gt;
    &lt;/properties&gt;
  &lt;/batchlet&gt;
  &lt;partition&gt;
    &lt;plan partitions=&quot;5&quot;&gt;
      &lt;properties partition=&quot;0&quot;&gt;
        &lt;property name=&quot;part&quot; value=&quot;string 0&quot; /&gt;
      &lt;/properties&gt;
      ....
    &lt;/plan&gt;
    &lt;collector ref=&quot;PartitionIDCollector&quot;&gt;
      &lt;properties&gt;
        &lt;property name=&quot;xx&quot; value=&quot;#{jobProperties[&apos;stepProp&apos;]&quot; /&gt;
      &lt;/properties&gt;
    &lt;/collector&gt;
  &lt;/partition&gt;
&lt;/step&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19057</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 20:45:50 +0000</bug_when>
    <thetext>Fixed in 
https://github.com/WASdev/standards.jsr352.jbatch/commit/83ff53fdc546e109a4ad24b5c34976859b8c3d08

Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5752</bug_id>
          
          <creation_ts>2014-01-29 17:16:00 +0000</creation_ts>
          <short_desc>Weld reinitializes for every bean lookup</short_desc>
          <delta_ts>2015-09-01 20:48:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>justinwesley</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15051</commentid>
    <comment_count>0</comment_count>
    <who name="">justinwesley</who>
    <bug_when>2014-01-29 17:16:46 +0000</bug_when>
    <thetext>class WeldSEBatchArtifactFactoryImpl will re-initialize Weld for every component lookup. This causes problems with the lookup of batch artifacts. Weld should only be initialized once throughout the JVM.

Example code can be found at https://github.com/justin-wesley/jbatch-bug</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19058</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 20:48:31 +0000</bug_when>
    <thetext>Fixed in https://github.com/WASdev/standards.jsr352.jbatch/commit/b1a178619a2d7741f86bf0eecb2040ed9501eed7.

Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5780</bug_id>
          
          <creation_ts>2014-02-12 02:54:00 +0000</creation_ts>
          <short_desc>Spec should clarify StepExecution values passed to Decider on a restart</short_desc>
          <delta_ts>2016-03-17 19:51:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15113</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-12 02:54:47 +0000</bug_when>
    <thetext>See recent ML discussion:

https://java.net/projects/jbatch/lists/public/archive/2014-02/message/5</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15145</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 22:47:51 +0000</bug_when>
    <thetext>Pulled out Section 10.8 description of rules involved in restart processing and broke out into an overview section (10.8.3) followed by a slight rewrite of the original 10.8 (now in 10.8.4).

I think the overview should make it much clearer what the details are really referring to.   I also think I was able to make the language a bit more precise in a couple places.  

Let me also note that this update isn&apos;t trying to resolve a spec ambiguity..it&apos;s just trying to simply spell out one single spec interpretation and not leave as much for the reader to figure out what&apos;s being described.  

One more note:  the formatting is awful.  Maybe just wait for the new PDF which I plan to send out tomorrow (2/14).

------------------------------------------------------------------------------


10.8.3	Execution Sequence on Restart  Overview

On the initial execution of a JobInstance, the sequence of execution is essentially:
 1.	Start at initial execution element
 2.	Execute the current execution element
 3.	Either:
  a.	 Transition to next execution element (and go to step 2. above)    OR
  b.	 Terminate execution

On a restart, i.e. a subsequent   execution of a JobInstance, the sequence of execution is similar, but the batch implementation must, in addition, determine which steps it does and does not need to re-execute.
So on a restart, the sequence of execution looks like:
 1.	Start at restart position 
 2.	Decide whether or not to execute (or re-execute) the current execution element 
 3.	Either:
  a.	  Transition to next execution element (and go to step 2. above)    OR
  b.	  Terminate execution

So it follows that for restart we need:  a definition of where in the job definition to begin;  rules for deciding whether or not to execute the current execution element;  and rules for performing transitioning, especially taking into account that all steps relevant to transitioning may not have execute on this (restart) execution.      These rules are provided below.

10.8.4	Execution Sequence on Restart  Detailed Rules

Upon restart, the job is processed as follows:

 1.	Substitutions are processed.

 2.	Start by setting the current position to the restart position.  The restart position is either: 
   a.	the execution element identified by the &lt;stop&gt; elements restart attribute if that is how the previous execution ended; else

   b.	the initial execution element determined the same as upon initial job start, as described in section 8.2.5 Step Sequence;

 3.	Determine if the current execution element should re-execute:
   a.	If the current execution element is a COMPLETED step that specifies allow-restart-if-complete=false, then transition based on the exit status for this step from the previous completed execution.    If the transition is a next transition, then repeat step 3 here with the value of next as the new, current execution element.   Or, if the transition is a terminating transition such as end, stop, or fail, then terminate the restart execution accordingly.

   b.	If the current execution element is a COMPLETED step that specifies allow-restart-if-complete=true, then re-run the step and transition based on the new exit status from the new step execution.    As above, either repeat step 3 with the next execution element or terminate the new execution as the transition element 

   c.	If the current execution element is a STOPPED or FAILED step then restart the step and transition based on the exit status from the new step execution. 
Note if the step is a partitioned step, only the partitions that did not complete previously are restarted.  This behavior may be overridden through the PartitionPlan, as specified in section 10.9.4 PartitionPlan.

   d.	If the current execution element is a decision, execute the decision (i.e. execute the Decider) unconditionally.    The Deciders decide method is passed a StepExecution array  as a parameter.    This array will be populated with the most-recently completed StepExecution(s) for each corresponding step.    E.g. some StepExecution(s) may derive from previous job executions and some from the current restart (execution).    A single decision following a split could even have a mix of old, new StepExecution(s) in the same array. 

   e.	If the current  execution element is a flow, transition to the first execution element in the flow and perform step 3 with this as the current element.   When restart processing of the flow has completed, then follow the same rules which apply during the original execution (see section 8.9) to transition at the flow level to the next execution element, and repeat step 3 with that element as the current element.
Note the same rules regarding transitioning within a flow during an original execution apply during restart processing as well.

   f.	If the current execution element is a split, proceed in parallel for each flow in the split.  For each flow, repeat step 3 with the flow element as the current element.   When all flows in the split have been processed, follow the split&apos;s transition to the next execution element and repeat step 3 with that element as the current element.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19095</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:41:38 +0000</bug_when>
    <thetext>Leaving this open..it&apos;s conceivable every detail just might already be enforced by the 1.0 TCK.. but if we can review for gaps let&apos;s do so.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19096</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:42:41 +0000</bug_when>
    <thetext>Leaving this open..it&apos;s conceivable every detail just might already be enforced by the 1.0 TCK.. but if we can review for gaps let&apos;s do so.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19826</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:51:24 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/33</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5784</bug_id>
          
          <creation_ts>2014-02-13 11:53:00 +0000</creation_ts>
          <short_desc>Consider declaring StepExecution/JobExecution/Metric to implements Serializable in future?</short_desc>
          <delta_ts>2016-03-09 22:18:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15129</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-02-13 11:53:35 +0000</bug_when>
    <thetext>The getters involved return properties which are already Serializable (except StepExecution#getMetrics).   

Is there value in letting an application easily persist this itself, or should it maybe always have to get this anew from the job repository?

Opening for consideration as maybe a minor improvement.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15139</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2014-02-13 14:51:45 +0000</bug_when>
    <thetext>Adding the requirement of Serializable at the interface level begins to prescribe how the job repository functions instead of leaving that up to the implementers.  There is no reason to need to serialize one of these objects otherwise.  With SB, we have defined columns for the various attributes so the data is query able in a normal way.  I&apos;d advocate for leaving this up to the various implementations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19072</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-02 20:07:16 +0000</bug_when>
    <thetext>Getting back to this one....  my thought here is that this wouldn&apos;t be prescribing how the job repository functions, it would be allowing an app to persist this info without going back to the job repository (say if it lacks a connection or wishes to cache).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19783</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-09 22:18:19 +0000</bug_when>
    <thetext>Since I&apos;m still the only one who&apos;s ever suggested this, just going to forget about it.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5806</bug_id>
          
          <creation_ts>2014-02-20 19:45:00 +0000</creation_ts>
          <short_desc>JobExecution returned by jobOperator.getJobExecutions(jobInstance) has null parameters</short_desc>
          <delta_ts>2015-09-01 21:00:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>RI_only</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>m_edgar</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15187</commentid>
    <comment_count>0</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-02-20 19:45:58 +0000</bug_when>
    <thetext>Job parameters on JobExecution objects returned by jobOperator.getJobExecutions(jobInstance) are null. The RI de-serializes the properties from the database in jobOperatorGetJobExecutions(long jobInstanceId), but they are not set on the corresponding JobExecution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17057</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-01 01:45:05 +0000</bug_when>
    <thetext>Fixed runtime with test in commit:
https://github.com/WASdev/standards.jsr352.jbatch/commit/9aedb7f72e619685dd3b1e9787374e121b66926f</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19061</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:00:06 +0000</bug_when>
    <thetext>Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5833</bug_id>
          
          <creation_ts>2014-02-27 18:50:00 +0000</creation_ts>
          <short_desc>Ant build does not properly set exit code on failure</short_desc>
          <delta_ts>2015-09-03 14:14:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>suggestion</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15260</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2014-02-27 18:50:08 +0000</bug_when>
    <thetext>When running &quot;ant&quot; in the TCK home directory, if a TCK tests fails or some other test configuration error occurs (say a missing jar from classpath), the ant build will indicate from testng that there was some sort of failure but ant will exit in BUILD SUCCESS. The process will also report an exit code of 0.

If a failure of some sort occurs, it should be reported as so and a non 0 exit code should be returned.

A simple fix to build.xml that I have found is adding the following after &lt;/testng&gt; and before &lt;/target&gt;:

&lt;fail if=&quot;tests.failed&quot; message=&quot;JSR-352 TCK TESTS FAILED&quot;/&gt;

This should be fixed so running the TCK can be integrated into other build tools and accurately determine if the test suite was successful.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19077</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 14:14:24 +0000</bug_when>
    <thetext>This has been added to the master branch using:

 &lt;testng ... haltonfailure=&quot;true&quot;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5834</bug_id>
          
          <creation_ts>2014-02-28 06:36:00 +0000</creation_ts>
          <short_desc>deploy tcks on central</short_desc>
          <delta_ts>2015-09-02 19:59:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>suggestion</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15265</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2014-02-28 06:36:10 +0000</bug_when>
    <thetext>Hi,

at the moment a big part of tcks are on central but not tcks themself. It would be great to get the whole needed dependencies available simply by dependency and avoiding the need to play with a zip.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19071</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-02 19:59:26 +0000</bug_when>
    <thetext>We still have the zip but I&apos;m not sure there&apos;s much left now than updating the official TCK doc to explain how to run against Maven artifacts &quot;Officially&quot;.

Opened 
 https://github.com/WASdev/standards.jsr352.tck/issues/1
so closing this.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5873</bug_id>
          
          <creation_ts>2014-03-10 15:27:00 +0000</creation_ts>
          <short_desc>Clarify when CheckpointAlgorithm#beginCheckpoint is invoked</short_desc>
          <delta_ts>2016-03-17 19:52:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15336</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-10 15:27:52 +0000</bug_when>
    <thetext>See ML discussion thread starting at:

https://java.net/projects/jbatch/lists/public/archive/2014-03/message/1</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15431</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-26 19:50:40 +0000</bug_when>
    <thetext>Marking with ri_1.0 to reflect that, in addition to updating the spec, we also need to fix the RI as noted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17053</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 21:00:17 +0000</bug_when>
    <thetext>Fixed in:
https://github.com/WASdev/standards.jsr352.jbatch/commit/1679181c55a5267a15feade1bba35fffd4d401c4</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19827</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:52:03 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/34</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5875</bug_id>
          
          <creation_ts>2014-03-10 20:19:00 +0000</creation_ts>
          <short_desc>When the first readItem() in a chunk return &apos;null&apos;, is this a zero-item chunk or is this not a new chunk after all?</short_desc>
          <delta_ts>2016-03-17 19:52:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15339</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-10 20:19:48 +0000</bug_when>
    <thetext>See discussion:
 https://java.net/projects/jbatch/lists/public/archive/2014-02/message/12</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15436</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-27 17:31:39 +0000</bug_when>
    <thetext>One simple change to the spec, and one too complicated to show more than a sample.

The simple change was to the Java doc for: ItemWriter#writeItems 

Change to:
	
	/**
	 * The writeItems method writes a list of item
	 * for the current chunk.
	 * @param items specifies the list of items to write.
	 * This may be an empty list (e.g. if all the
	 * items have been filtered out by the 
	 * ItemProcessor).
	 * @throws Exception is thrown for any errors.
	 */
	public void writeItems(List&lt;Object&gt; items) throws Exception;

------------------------

The more complicated change was to the flow outlines in 11.6-11.10.

Decided that this was a zero-item chunk (rather than &quot;not a chunk&quot;).  Illustrated most simply by 11.6 which will look like:

...
9.  &lt;repeat until no more items (i.e. while readItem hasn&apos;t returned &apos;null&apos;) &gt; {
    a.  &lt;begin checkpoint interval [&lt;begin chunk transaction&gt;]&gt;
    b.  &lt;repeat until checkpoint criteria reached OR readItem returns &apos;null&apos;&gt; {
        i.  &lt;-&gt;ItemReader.readItem // thread A
        ii. // if readItem returns non-null
            1.  &lt;-&gt;ItemProcessor.processItem // thread A
            2.  // if processItem returns non-null, &lt;add item to writeItems buffer&gt;
    c.  }
    d.  // if at least one non-null value has been successfully read in the present chunk
        i.    &lt;-&gt;ItemWriter.writeItems // thread A
    e.  &lt;-&gt;[ItemReader.checkpointInfo] // thread A
    f.  &lt;-&gt;[ItemWriter.checkpointInfo] // thread A
    g.  &lt;Store StepContext persistent area&gt;
    h.  [&lt;commit chunk transaction&gt;]
10. }
....

------------------------------------------------------------------------------

In addition, RI should be fixed to allow for an empty List being passed to ItemWriter#writeItems().</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15443</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-28 14:14:07 +0000</bug_when>
    <thetext>As noted in Brent&apos;s email, we have a TCK issue here as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15494</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-04-04 14:36:44 +0000</bug_when>
    <thetext>In Draft 5, making one further change as discussed in my last post:
https://java.net/projects/jbatch/lists/public/archive/2014-04/message/0

In Sec. &quot;11.7	Partitioned Chunk Processing &quot;:
Deleting outline entry 5.e.ix, (otherwise leaving the rest unchanged).

The reason is:  now that we are clear that the collector will always be called at the end of the last chunk (even a zero-item chunk), there is no need for yet another call.

This leaves the TCK behaving per spec (in a somewhat roundabout way).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15913</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-05-27 21:55:20 +0000</bug_when>
    <thetext>Noting that I messed up in producing the MR spec draft when reflecting the last change noted above.

In Section 11.7, it should read:

...
5. &lt;-&gt;[PartitionMapper.mapPartitions] // thread A // per partition - on thread Px:
  a. [&lt;begin transaction&gt; ]
  b. &lt;-&gt;ItemReader.open // thread Px
  c. &lt;-&gt;ItemWriter.open // thread Px
  d. [&lt;commit transaction&gt; ] 
  e. &lt;repeat until no more items (i.e. while readItem hasn&apos;t returned &apos;null&apos;) &gt; { 
       i. &lt;begin checkpoint interval [&lt;begin chunk transaction&gt;]&gt; 
       ...
       vii. &lt;Store (partition-local) StepContext persistent area&gt;
       viii. [&lt;commit chunk transaction&gt;]
       ix. &lt;-&gt;[PartitionCollector.collectPartitionData] // thread Px
  f. }
  g. [&lt;begin transaction&gt; ]
  h. &lt;-&gt;ItemWriter.close // thread Px
  i. &lt;-&gt;ItemReader.close // thread Px
  j. [&lt;commit transaction&gt; ]
6. [&lt;begin transaction&gt; ] // thread A
7. // Actions 9-12 run continuously until all partitions end.


------------------------------------------------------------------------------

That is, the collector gets called after the chunk transaction is committed, even if it is a &quot;zero-item&quot; chunk.   The collector does not get called after reader/writer close.

In my last draft I had wrongly remove the collector call in 5.e.ix, when I meant to remove the collector call in 5.k. 

------------------------------------------------------------------------------</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17052</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-30 21:00:00 +0000</bug_when>
    <thetext>Fixed a piece of this in the RI with:

https://github.com/WASdev/standards.jsr352.jbatch/commit/1679181c55a5267a15feade1bba35fffd4d401c4

Changed behavior so we don&apos;t call writeItems with an empty list.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19828</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:52:38 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/35</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5878</bug_id>
          
          <creation_ts>2014-03-11 14:19:00 +0000</creation_ts>
          <short_desc>Tests needed for property injection (see Bug 5746)</short_desc>
          <delta_ts>2015-09-03 14:26:54 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_future</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15345</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-11 14:19:03 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19079</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 14:26:54 +0000</bug_when>
    <thetext>Will track differently.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5879</bug_id>
          
          <creation_ts>2014-03-11 14:19:00 +0000</creation_ts>
          <short_desc>Tests needed for include/exclude exceptions in hierarchy for skip/retry (See Bug 5403)</short_desc>
          <delta_ts>2015-09-03 14:27:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard>tck_future</status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15346</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-11 14:19:54 +0000</bug_when>
    <thetext>See Bug 5403</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19080</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 14:27:24 +0000</bug_when>
    <thetext>Will track differently.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5911</bug_id>
          
          <creation_ts>2014-03-28 14:17:00 +0000</creation_ts>
          <short_desc>Clarify partition restart processing, PartitionPlan properties, and persistent user data for partitioned steps.</short_desc>
          <delta_ts>2015-09-03 16:25:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15444</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-28 14:17:35 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15458</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-31 16:41:11 +0000</bug_when>
    <thetext>Made these six updates:

1) For the Javadoc of PartitionPlan, updated class-level doc to:

 * A PartitionPlan contains: 
 * &lt;ol&gt;
 * &lt;li&gt;number of partition instances &lt;/li&gt;
 * &lt;li&gt;number of threads on which to execute the partitions&lt;/li&gt;
 * &lt;li&gt;substitution properties for each Partition (which can be
 * referenced using the &lt;b&gt;&lt;i&gt;#{partitionPlan[&apos;propertyName&apos;]}&lt;/i&gt;&lt;/b&gt; 
 * syntax. &lt;/li&gt;	  
 * &lt;/ol&gt; 

and changed getPartitionProperties() Javadoc to:

/**
 * Gets array of Partition Properties objects for Partitions.
 * &lt;p&gt;
 * These can be used in Job XML substitution using  
 * substitution expressions with the syntax:
 *   &lt;b&gt;&lt;i&gt;#{partitionPlan[&apos;propertyName&apos;]}&lt;/i&gt;&lt;/b&gt;
 * &lt;p&gt;
 * Each element of the Properties array returned can  
 * be used to resolving substitutions for a single partition.
 * In the typical use case, each Properties element will
 * have a similar set of property names, with a 
 * substitution potentially resolving to the corresponding
 * value for each partition.
 * 
 * @return Partition Properties object array
 */

----

2) Enhanced example at the end of Section 8.8.1.4 to:

E.g. Given job, job1: 
&lt;job id=&quot;job1&quot;&gt;
	&lt;step id=&quot;step1&quot;&gt;
		&lt;chunk&gt;
			&lt;reader ref=&quot;MyReader&gt;
				&lt;properties&gt;
					&lt;property name=&quot;infile.name&quot; 
						   value=&quot;file#{partitionPlan[&apos;myPartitionNumber&apos;]}.txt&quot;/&gt;
					&lt;property name=&quot;outfile.name&quot; 
						   value=&quot;#{partitionPlan[&apos;outFile&apos;]}&quot;/&gt;
				&lt;/properties&gt;
			&lt;/reader&gt;
			&lt;writer ref=&quot;MyWriter&quot;/&gt;
		&lt;/chunk&gt;
		&lt;partition&gt;
			&lt;mapper ref=&quot;MyMapper&quot;/&gt;
		&lt;/partition&gt;
	&lt;/step&gt;
&lt;/job&gt;

and MyMapper implementation: 

public class MyMapper implements PartitionMapper { 
	public PartitionPlan mapPartitions() { 
		PartitionPlanImpl pp= new PartitionPlanImpl();
		pp.setPartitions(2);
		Properties p0= new Properties();
		p0.setProperty(&quot;myPartitionNumber&quot;, &quot;0&quot;);
		p0.setProperty(&quot;outFile&quot;, &quot;outFileA.txt&quot;);

		Properties p1= new Properties();
		p1.setProperty(&quot;myPartitionNumber&quot;, &quot;1&quot;);
		p1.setProperty(&quot;outFile&quot;, &quot;outFileB.txt&quot;);
		Properties[] partitionProperties= new Properties[2];
		partitionProperties[0]= p0;
		partitionProperties[1]= p1;
		pp.setPartitionProperties(partitionProperties);
		return pp;
	}
}
The step1 chunk would run as two partitions, with the itemReader property &quot;infile.name&quot; resolved to &quot;file0.txt&quot; and &quot;file1.txt&quot; for partitions 0 and 1, respectively.  Also, itemReader property &quot;outfile.name&quot; would resolve to &quot;outFileA.txt&quot;, and &quot;outFileB.txt&quot; for partitions 0 and 1, respectively.

----

3) At the end of Section 8.2.6.1, added: 

Note the specification does not attempt to guarantee order of partition execution with respect to the order within a statically or dynamically-defined plan.

----

4) Changed Javadoc for StepExecution#getPersistentUserData to:

	/**
	 * Get persistent user data.
	 * &lt;p&gt;
	 * For a partitioned step, this returns
	 * the persistent user data of the 
	 * &lt;code&gt;StepContext&lt;/code&gt; of the &quot;top-level&quot;
	 * or main thread (the one the &lt;code&gt;PartitionAnalyzer&lt;/code&gt;, etc.
	 * execute on).   It does not return the persistent user
	 * data of the partition threads. 
	 * @return persistent data 
	 */	
         public Serializable getPersistentUserData();

----

5) Added clarification at the end of Section 9.4.1.1.  It now ends with:

&quot;For a partitioned step, there is one StepContext for the parent step/thread;  there is a distinct StepContext for each sub-thread and each StepContext has its own distinct persistent user data for each sub-thread.&quot;

----

6) Added clarification to 2nd paragraph in Sec. 10.8.4, Rule 3.c.

It now reads:

&quot;Note if the step is a partitioned step, only the partitions that did not complete previously are restarted.  This behavior may be overridden through the PartitionPlan, as specified in section 10.9.4 PartitionPlan.  Note for a partitioned step, the checkpoints and persistent user data are loaded from the persistent store on a per-partition basis (this is not a new rule, but a fact implied by the discussion of checkpoints in Section 8.2.6 and the Step Context in Section 9.4.1.1, which is summarized here for convenience).&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19091</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:25:22 +0000</bug_when>
    <thetext>Since we kept Bug 5919 open for TCK updates, we can close this one, since neither of the TODOs is particularly clear-cut.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>5919</bug_id>
          
          <creation_ts>2014-03-31 18:31:00 +0000</creation_ts>
          <short_desc>Spec doesn&apos;t fully describe PartitionPlan override and the use of PartitionMapper</short_desc>
          <delta_ts>2016-03-17 19:53:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>15461</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-03-31 18:31:12 +0000</bug_when>
    <thetext>The current description in Sec. 9.5.1:

&quot;Note the PartitionMapper is not invoked during job restart.  The Batch Runtime remembers the partition plan from the first JobExecution and uses it on all  subsequent JobExecutions for the same JobInstance.&quot;

is not what the RI does.   The RI seems to call the mapper on the restart.


I&apos;d like to look at this more to understand if we can simply treat this as a bug in the RI, or if the spec is lacking in some way and a new clarification is needed.   Also plan to look at what behaviors the TCK is enforcing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15472</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-04-01 18:22:23 +0000</bug_when>
    <thetext>It looks like we did discuss this right before the final release though it didn&apos;t make it into the final spec.

Kaushik pointed me to this exchange between him and Cheng:
https://java.net/projects/jbatch/lists/public/archive/2013-05/message/6

This looks to me like a bug we must fix... this isn&apos;t just an elaboration to clarify.

The conclusions I&apos;d draw from that thread, (which hopefully we can all agree on):

1) The mapper is called on every execution, including restarts.

2) The override on the plan built by the mapper on the current execution directs the runtime whether or not to throw away the partition data (# of partitions, checkpoints, persistent user data) from the previous execution.  This means the &apos;override&apos; is meaningless on the initial execution.

3) Though the number of partitions is persisted, the getPartitionProperties() values are not.  The potential partition plan substitution properties (this is better described in Bug 5911&apos;s change) for this execution are obtained from the current execution&apos;s mapper&apos;s plan&apos;s getPartitionProperties() return value.

4) In this context the partitions are effectively &quot;numbered&quot;, even though there is no spec API to access this number. For each index &apos;i&apos; into the Properties[] returned by getPartitionProperties() on the original execution, the runtime must associate &apos;i&apos; with both a Properties object (an element of the return value array) and the partition execution data: whether the partition completed or not, the checkpoint values, and the persistent user data.    Call this partition execution data &quot;partition execution data[i]&quot;.     This association must occur so that, on a new (restart) execution, the element # i  of the Properties[] returned by getPartitionProperties() is associated with the same &quot;partition execution data[i]&quot;.
--

If someone could condense that #4 more simply I&apos;d be happy to replace it...


In writing this, I can see yet a couple other ambiguities:

1)  Though the spec says in Section 10.8.4 3.c. that completed partitions don&apos;t restart, we didn&apos;t precisely pin down what completed means.    Might be an opportunity for an extra listener to get called (or not) but this doesn&apos;t hugely concern me.

2) One could ask if an exception should be thrown if the plan doesn&apos;t have the same number of elements in the getPartitionProperties() array as the number returned by getPartitions()?   I&apos;d sort of like to say this is allowed (prevent an implementation from invalidating it), not sure though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15498</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-04-04 18:21:29 +0000</bug_when>
    <thetext>Made two changes:

1) Section 9.5.1 ends with (after intf definition):

See section 10.9.4 for details on the PartitionPlan result value type.

The PartitionMapper, when defined, is invoked upon every execution, including restarted executions. For  a full discussion of the behavior on restart, including how to override particular details of the PartitionPlan built by the previous execution, see Section 10.8.5.

2) Added Sec. 10.8.5 with subsections (see draft for better formatting):

 PartitionMapper on Restart

When the  PartitionMapper is invoked at the beginning of a step which has been executed within a previous job execution, the first and most important decision for the mapper implementor to make is whether or not to keep the previous partitions or to begin the new execution with new partition definitions.
This decision is communicated to the batch implementation via the &apos;partitionsOverride&apos; property of the PartitionPlan built by the mapper, i.e. the result of PartitionPlan&apos;s getPartitionsOverride() method.
This property directs whether or not the partitions used in  the previous execution of this step will or will be used (i.e. the relevant data carried forward and applied) within the current execution of this step.    (As a consequence, the value of this property has no real meaning when the mapper is first called on the first execution of this step).

10.8.5.1	partitionsOverride = False 

Three rules apply in the case where override is set to &apos;false&apos;:

10.8.5.1.1	Number of Partitions Must Be Same 

The key idea here is that the mapper must build a partition plan with the same number of partitions  that were used in the previous execution of this step.   As a consequence, it is an error for the partition plan to return (via getPartitions()) a different number than the number of partitions established by the plan the last time this step was executed.  
10.8.5.1.2	Partition Properties Populated From Current Plan

Though the number of partitions in the previous plan is persisted, the Properties[] returned by the previous PartitionPlan&apos;s getPartitionProperties() is not.    On a new execution of this step, it is the current return value of PartitionPlan#getPartitionProperties() which is used to populate the pool of potential &apos;partitionPlan&apos; substitutions (see Section 8.8.1.4).
10.8.5.1.3	&quot;Numbering&quot; of Partitions via Partition Properties

Upon execution of this step, the batch implementation will associate each element of the Properties[] returned by PartitionPlan#getPartitionProperties() with a single partition, in order to potentially resolve &apos;partitionPlan&apos; substitutions (see Section 8.8.1.4) for a single partition.   During the course of execution of each partition, the batch implementation will capture data such as checkpoint values, persistent user data, etc.
Upon a new execution of this step during restart, the batch implementation must ensure that a similar mapping occurs.  That is, the elements of the new Properties[] returned by the PartitionPlan#getPartitionProperties() built by the mapper must be mapped to the partitions in the same order as the earlier elements of the earlier Properties[] were mapped (for resolving &apos;partitionPlan&apos; substitutions).
E.g., the following must hold:
Earlier Execution:   
partitionPlanProps[] = mapper.getPartitionPlan().getPartitionProperties();
partitionPlanProps[0]  ---maps to---&gt;  partition leaving off at checkpoints R0, W0
partitionPlanProps[1]  ---maps to---&gt;  partition leaving off at checkpoints R1, W1

Current Execution:
newPartitionPlanProps[] = mapper.getPartitionPlan().getPartitionProperties();
newPartitionPlanProps[0]  ---maps to---&gt;  partition resuming at checkpoints R0, W0
newPartitionPlanProps [1]  ---maps to---&gt;  partition resuming at checkpoints R1, W1

In the shorthand above, &quot;maps to&quot; simply means that the Properties object on the left is used to potentially resolve the &apos;partitionPlan&apos; substitutions for the give partition, before it executes as described.

10.8.5.2	partitionsOverride = True

In this case,  all partition execution data:  checkpoints, persistent user data, etc. from the earlier execution are discarded, and the new PartitionPlan built by the new execution of the PartitionMapper may define either the same or a different number of partitions;  the new P artitionPlan&apos;s getPartitionProperties() return value will be used to resolve &apos;partitionPlan&apos; substitutions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>15506</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-04-07 15:47:13 +0000</bug_when>
    <thetext>Added two more parts after Cheng&apos;s comments today:

#4 (a deletion)
----------------

For the Javadoc for &apos;PartitionPlan#setPartitionsOverride&apos;, deleted the last sentence in the first paragraph:

 &quot;The default is false.&quot;

#5 (reworded for clarification):
------------------------------

For PartitionPlan#setThreads (and getThreads), change to:

/**
 * Set maximum number of threads requested to use to run 
 * partitions for this step. A value of &apos;0&apos; requests the batch 
 * implementation to use the partition count as the thread 
 * count.  Note the batch runtime is not required to use
 * this full number of threads; it may not have this many
 * available, and may use less.
 * 
 * @param count specifies the requested thread count
 */
 public void setThreads(int count);</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19084</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 15:32:41 +0000</bug_when>
    <thetext>Seems like there&apos;s probably something here that should be added to the TCK.  Not sure what exactly though, but leaving this open.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19829</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-17 19:53:58 +0000</bug_when>
    <thetext>https://github.com/WASdev/standards.jsr352.tck/issues/36</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6155</bug_id>
          
          <creation_ts>2014-06-17 17:27:00 +0000</creation_ts>
          <short_desc>ExternalizableString requires a no-args constructor</short_desc>
          <delta_ts>2015-09-03 15:39:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>TCK</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>BrentDouglas</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16095</commentid>
    <comment_count>0</comment_count>
    <who name="">BrentDouglas</who>
    <bug_when>2014-06-17 17:27:25 +0000</bug_when>
    <thetext>com.ibm.jbatch.tck.artifacts.reusable.ExternalizableString requires a no-args constructor to satisfy Externalizable requirements.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19085</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 15:39:45 +0000</bug_when>
    <thetext>Fixed in 
https://github.com/WASdev/standards.jsr352.tck/commit/1b667c61248e15be813f56c7fefa25b0feedd822</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6259</bug_id>
          
          <creation_ts>2014-07-23 19:15:00 +0000</creation_ts>
          <short_desc>Exception in ChunkStepControllerImpl causes rollback of subsequent step/job status</short_desc>
          <delta_ts>2014-10-07 14:50:08 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>m_edgar</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16421</commentid>
    <comment_count>0</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-07-23 19:15:37 +0000</bug_when>
    <thetext>When an exception occurs in chunk processing (ChunkStepControllerImpl#invokeChunk), additional exceptions that occur during the reader/writer close methods allow for the transaction rollback call to be skipped. Since setRollbackOnly has already been called, subsequent updates to the JBatch database are not committed. The result is that jobs/steps are left in the last state committed to the JBatch database.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16422</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-07-23 20:22:44 +0000</bug_when>
    <thetext>Thanks m_edgar for reporting this... sorry but I&apos;m not quite following.

So the scenario starts with an exception coming from the chunk read/process/writer loop... causing a rollback.

What is the next step in the sequence?   

The close() is supposed to happen in a new transaction, so I&apos;m not following what the link is here.

Thanks,
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16423</commentid>
    <comment_count>2</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-07-23 20:34:59 +0000</bug_when>
    <thetext>Scott,

The setRollbackOnly is called in the finally block when a throwable occurred. After that, the reader and writer close methods are called. Following those, rollback is called on the transactionManager.

The issue I am seeing is that if an exception is thrown from the reader or writer close methods, rollback is never called on the transactionManager and subsequent updates to the JBatch database tables are made in a transaction that has setRollbackOnly set to true.

Here is the code I am referring to. Notice that the rollback is called after the two close calls, either of which may throw an unchecked BatchContainerRuntimeException.

if (caughtThrowable != null) {
    transactionManager.setRollbackOnly();
    logger.warning(&quot;Caught throwable in chunk processing.......
    readerProxy.close();
    writerProxy.close();
    transactionManager.rollback();
    logger.exiting(sourceClass, &quot;invokeChunk&quot;);
    throw new BatchContainerRuntimeException ......
} else {
    .....

Just for more context, I am specifically seeing this when an exception is thrown in the reader&apos;s open method, which is called prior to the read/process/write loop immediately after the beginning of a transaction.


Thanks,
Michael</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16985</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-10-07 11:02:49 +0000</bug_when>
    <thetext>Pushed change in 79a64f4ca7b9bcc002ff5e1c4c0e74649e7a3c82.  

Another fix is that while the spec clearly says in &quot;Rollback Procedure&quot; at the end of Sec. 11.9, that the reader and writer are closed before ChunkListener.onError, the RI had been doing it in the reverse order.  Fixed this too.

Noticed a set of problems here which I&apos;m opening up new bugs for.  
Bug 6456 is in the same area of &quot;close&quot; processing, the rest aren&apos;t hugely related so I won&apos;t mention them here.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6415</bug_id>
          
          <creation_ts>2014-09-17 13:21:00 +0000</creation_ts>
          <short_desc>SkipHandler Logging to System.out</short_desc>
          <delta_ts>2015-09-01 21:29:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>m_edgar</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16840</commentid>
    <comment_count>0</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-09-17 13:21:27 +0000</bug_when>
    <thetext>com.ibm.jbatch.container.impl.SkipHandler @ 261 prints &quot;## NO SKIP&quot; directly to System.out rather than through the logger. 

Running a process with retry exceptions that aren&apos;t skipped could print quite a few of these. Very minor - just wanted to open an issue to track it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17062</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-03 15:49:11 +0000</bug_when>
    <thetext>Fixed in 9364b8eae4b28f6c288da424c5d3209d8c693c91.   Will close when we release 1.0.1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19067</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:29:49 +0000</bug_when>
    <thetext>Fixed in 1.0.1 release.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6420</bug_id>
          
          <creation_ts>2014-09-20 01:54:00 +0000</creation_ts>
          <short_desc>Partition Plan won&apos;t work when inside a split</short_desc>
          <delta_ts>2015-09-01 20:15:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>matias-uy</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>kewlmain</cc>
    
    <cc>matias-uy</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16856</commentid>
    <comment_count>0</comment_count>
    <who name="">matias-uy</who>
    <bug_when>2014-09-20 01:54:14 +0000</bug_when>
    <thetext>The following example is just a:
job
  split
    flow
      step
        chunk
        partition

The problem is that the parameters set in the partition plan wont work if I put the flow inside a split. If you delete the split and just put the flow inside the job, it works properly. The following example wil print just:
null
null

but if I delete the split, it will print
valueTest1
valueTest2

Thanks! Matias

==========
JOB XML
==========

&lt;job id=&quot;myJob&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; version=&quot;1.0&quot;&gt;
    &lt;split id=&quot;mySplit&quot;&gt;
        &lt;flow id=&quot;myFlow&quot;&gt;
            &lt;step id=&quot;myStep&quot; &gt;
                &lt;chunk&gt;
                    &lt;reader ref=&quot;testbatch.MyItemReader&quot;&gt;
                        &lt;properties&gt;
                            &lt;property name=&quot;prop1&quot; value=&quot;#{partitionPlan[&apos;prop1&apos;]}&quot;/&gt;
                        &lt;/properties&gt;
                    &lt;/reader&gt;
                    &lt;writer ref=&quot;testbatch.MyItemWriter&quot;/&gt;
                &lt;/chunk&gt; 
                &lt;partition&gt;
                    &lt;plan partitions=&quot;2&quot; &gt; 
                        &lt;properties partition=&quot;0&quot;&gt; 
                            &lt;property name=&quot;prop1&quot; value=&quot;valueTest1&quot;/&gt; 
                        &lt;/properties&gt;
                        &lt;properties partition=&quot;1&quot;&gt; 
                            &lt;property name=&quot;prop1&quot; value=&quot;valueTest2&quot;/&gt; 
                        &lt;/properties&gt;
                    &lt;/plan&gt;
                &lt;/partition&gt;   
            &lt;/step&gt;
        &lt;/flow&gt;
    &lt;/split&gt;
&lt;/job&gt; 

==========
READER
==========


package testbatch;

import javax.batch.api.BatchProperty;
import javax.batch.api.chunk.AbstractItemReader;
import javax.inject.Named;

@Named
public class MyItemReader extends AbstractItemReader {

    @BatchProperty
    String prop1;

    @Override
    public Object readItem() throws Exception {
        System.out.println(prop1);
        return null;
    }
}

==========
MAIN
==========


package testbatch;

import javax.batch.operations.JobOperator;
import javax.batch.runtime.BatchRuntime;

public class TestBatch {

    public static void main(String[] args) {
        JobOperator jobOperator = BatchRuntime.getJobOperator();
        jobOperator.start(&quot;myJob&quot;, null);
    }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16866</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-22 16:28:14 +0000</bug_when>
    <thetext>This looks like a new bug (new problem).  It doesn&apos;t look like it&apos;s a duplicate of another.  I just recreated it as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16945</commentid>
    <comment_count>2</comment_count>
    <who name="">matias-uy</who>
    <bug_when>2014-10-02 00:16:20 +0000</bug_when>
    <thetext>(In reply to ScottKurz from comment #1)
&gt; This looks like a new bug (new problem).  It doesn&apos;t look like it&apos;s a
&gt; duplicate of another.  I just recreated it as well.

Thanks for the answer!
Is there any news of this bug?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17135</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-15 15:19:58 +0000</bug_when>
    <thetext>Fixed in: 
https://github.com/WASdev/standards.jsr352.jbatch/commit/5bf853ff83882815f46223c3f714bdcac5bfc8f9</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19056</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 20:15:41 +0000</bug_when>
    <thetext>Fixed in 1.0.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6424</bug_id>
          
          <creation_ts>2014-09-22 18:14:00 +0000</creation_ts>
          <short_desc>jbatch does not work within a OSGi war and ejb in Glassfish</short_desc>
          <delta_ts>2014-11-17 09:47:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kewlmain</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16867</commentid>
    <comment_count>0</comment_count>
      <attachid>183</attachid>
    <who name="">kewlmain</who>
    <bug_when>2014-09-22 18:14:41 +0000</bug_when>
    <thetext>Created attachment 183
OSGi Hybrid wab project

I&apos;m currently evaluating the javaee batch runtime and its rererence implementation with Glassfish 4.1.

I&apos;m trying to get the BatchRuntime to work within a Hybrid (OSGi) war and ejb bundle/project, but it does not work how I would expect it.

I already posted my issue to the Glassfish forum, but thought maybe this is a bug and decided to open an issue.

Following the quotation of my post from the Glassfish forum:

&quot;Since a couple of days I&apos;m trying to get JSR-352 to work within of an OSGI War or Ejb in Glassfish 4.1, but it fails on the on the most important part. The execution of the batch job itself.
I&apos;m not sure whether it is a issue of Glassfish or the reference implementation itself, but the BatchRuntime (JobOperator) outputs it would and did execute the job but the actual Batchlet never gets called. I checked this by including a logging statement within the batchlet process method and to be sure I event placed code to create a temp file but both never happend.
If I deploy the war package as simple webapplication everything works as it should do.

Attatched you will find a simple OSGi WAB project. if you placed it under domain/autodeploy/bundles the package gets installed and started and the job itselfs seems to be executed by the batch runtime, but like i mention nothing of the Batchlet implementation will be executed.

I tried to trace the probleme and noticed by setting the &quot;com.ibm.jbatch&quot;-Logger to finest, that the execution stops or more like &apos;disappears&apos; when the BatchWorkUnit.class should be execution.

I think the project is correct configured. Everything but the batch runtime works. Maybe someone can reproduced this probleme with the attatched war-file.

This is what I did:
- first I registered the &quot;com.ibm.jbatch&quot; logger and set it to finest via the admin gui.
- then to test I deployed the war as a nomal web application and looked whether the expected console output would get printed out.
- afterwards I undeployed the web application and installed the package as osgi bundle by copying the package the {domain}/autodeploy/bundles. The bundle gets installed and started without any errors and the ejb gets registered as OSGi service. The singleton bean gets called and the batch runtime executes the job.xml, but the expected output in the console never gets printed.

What do I miss or is this a bug ?
I don&apos;t know, should I report this as bug ? And if so, to which bugtracker should I report this issue? The one of Glassfish or the one of the JSR352 reference implementation of javaee ?&quot;

I attatched the test project.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17136</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-16 01:43:46 +0000</bug_when>
    <thetext>I just recreated this, but am not sure what the batch RI should be doing differently, so I&apos;m just going to close this for now.

We are getting an ExecutorService set on us from Glassfish via our SPI, which we&apos;re then calling via our jbatch SPIDelegatingThreadPoolServiceImpl.
Since it seems like jbatch is calling ExecutorService#execute() here, I&apos;m not sure what the problem is.

Not knowing much about thread pools in Glassfish, I&apos;m not sure if it&apos;s just a generic issue configuring whatever thread pool / executor service you&apos;re getting in this case (with the WAB), or if there is something specific to batch and the integration of jbatch in Glassfish at issue here.  

If you find more and think there is something jbatch should be doing different please raise another issue. 

Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17141</commentid>
    <comment_count>2</comment_count>
    <who name="">kewlmain</who>
    <bug_when>2014-11-17 09:47:03 +0000</bug_when>
    <thetext>Yeah, you&apos;re right! 

The problem is glassfish&apos;s JavaEE-OSGi integration. I traced the probleme and created and updated the issue https://java.net/jira/browse/GLASSFISH-21216?jql=project%20%3D%20GLASSFISH%20AND%20priority%20%3D%20Major%20ORDER%20BY%20created%20DESC%2C%20key%20DESC. 
It seems like the web and ejb OSGi bundles are not flagged as an active application, which the ManagedExecuterService of Glassfish checks before executing a thread, otherwise skipping the execution.

As far I can tell jbatch does everything right, but glassfish does not what I would expect. Now the question is, whether this the desired behaviour of glassfish - which I doubt.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>183</attachid>
            <date>2014-09-22 18:14:00 +0000</date>
            <delta_ts>2014-09-22 18:14:41 +0000</delta_ts>
            <desc>OSGi Hybrid wab project</desc>
            <filename>osgi-batch-test.zip</filename>
            <type>application/zip</type>
            <size>5864</size>
            <attacher>kewlmain</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>6426</bug_id>
          
          <creation_ts>2014-09-23 16:38:00 +0000</creation_ts>
          <short_desc>Stop during a partitioned step blows up if some partitions are already complete (leaving others still executing)</short_desc>
          <delta_ts>2015-09-01 21:27:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>
    
    <cc>m_edgar</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>16870</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-23 16:38:09 +0000</bug_when>
    <thetext>Sorry, I don&apos;t have the recreate factored in a form to share, but hopefully the problem description is clear enough.   

The stack trace looks something like:

javax.batch.operations.JobExecutionNotRunningException: JobExecution with execution id of 2is not running.
        at com.ibm.jbatch.container.impl.BatchKernelImpl.stopJob(BatchKernelImpl.java:150)
        at com.ibm.jbatch.container.impl.PartitionedStepControllerImpl.stop(PartitionedStepControllerImpl.java:108)
        ... 33 more

------------------------------------------------------------------------------

The test, once written, might be a TCK candidate I&apos;d say.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16872</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-23 17:01:59 +0000</bug_when>
    <thetext>Pushed runtime change in commit 3f2331a05ea  but leaving open for test.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16902</commentid>
    <comment_count>2</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2014-09-24 15:33:43 +0000</bug_when>
    <thetext>I was just about to report this - It seems as though the SplitControllerImpl has similar logic.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>16903</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-09-24 16:26:32 +0000</bug_when>
    <thetext>(In reply to m_edgar from comment #2)
&gt; I was just about to report this - It seems as though the SplitControllerImpl
&gt; has similar logic.

Thx m_edgar!...didn&apos;t think to look at the split-flow case.  Just pushed that fix as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19065</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:27:13 +0000</bug_when>
    <thetext>Fixed in 1.0.1 release.

Split-flow fix was in
https://github.com/WASdev/standards.jsr352.jbatch/commit/151a0060b89d0a4f5f81ed9a942c100525d79834

Not sure why I&apos;d thought this was so interesting as a TCK candidate; instead just closing now.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6494</bug_id>
          
          <creation_ts>2014-11-05 18:40:00 +0000</creation_ts>
          <short_desc>For partitioned steps, allow-start-if-complete=true does not result in re-running the partitions</short_desc>
          <delta_ts>2016-04-20 15:21:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17075</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2014-11-05 18:40:21 +0000</bug_when>
    <thetext>In jbatch we only re-run the top-level portion of the partitioned step when  allow-start-if-complete=true.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19063</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-01 21:08:50 +0000</bug_when>
    <thetext>Marking this as &quot;SPEC&quot;.   It could only help to clarify in the spec wording, and add a TCK test.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19962</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-04-18 15:53:14 +0000</bug_when>
    <thetext>Added TCK test in 1.1 (only, even though this is 1.0-level function) in:
https://github.com/WASdev/standards.jsr352.tck/commit/904c014783949363ed853a7e77ce3799f538f6eb</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19963</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-04-18 15:53:40 +0000</bug_when>
    <thetext>Reminder: Need to go back and point test to new spec clarification when I add it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19974</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-04-20 15:21:42 +0000</bug_when>
    <thetext>I think this is clear enough in the spec, and any ambiguity resolved by the new TCK test. Closing.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>6742</bug_id>
          
          <creation_ts>2015-02-12 21:49:00 +0000</creation_ts>
          <short_desc>Stopping a Chunk causes IllegalStateException</short_desc>
          <delta_ts>2015-09-03 16:04:27 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>m_edgar</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17671</commentid>
    <comment_count>0</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-02-12 21:49:58 +0000</bug_when>
    <thetext>When stopping a partitioned chunk step that is currently executing, the RI sets an internal status value of &apos;finished&apos; to true (ChunkStepControllerImpl # readAndProcess).

// This will force the current item to finish processing on a stop request
if (stepContext.getBatchStatus().equals(BatchStatus.STOPPING)) {
    currentChunkStatus.setFinished(true);
}

The loop completes (correctly) as a result, and records read thus far are written.

A subsequent method call to updateNormalMetrics in the same class results in readCount being decremented by 1. This causes the filter count to become negative, causing the IllegalStateException.

Following that, a rollback is attempted (in the finally block of invokeChunk) which results in another exception since there is no active transaction at the point where updateNormalMetrics is called.

Ultimately, a partition of the step ends up in a FAILED state rather than STOPPED.

I haven&apos;t had time to investigate if this is specific to partitioned chunks or not. I suspect that a non-partitioned step would also end up as FAILED.

On the surface, it seems as though stopping a step and the completion of a step need to be differentiated when decrementing the readCount during the update of metrics.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17672</commentid>
    <comment_count>1</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-02-12 21:52:31 +0000</bug_when>
    <thetext>Just to add - this does not affect the work in the chunk since it was already committed prior to the metric updates where the exception occurs. The only impact here is that the metrics are not accurate and the step status is failed rather than stopped.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17673</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-02-12 22:24:39 +0000</bug_when>
    <thetext>Hi, let me first ask if this is version 1.0 you&apos;re running against?  Or is this the latest code from GitHub (built into Maven as 1.0.1-b07)?

As an aside, sorry for 1.0.1 taking so long to release.. since it involves bundle/JAR renames I wanted to give Glassfish a chance to complete integration testing.

Seems like Bug 5407, Bug 6426 are in the somewhat general area, so just wanted to check (since these were fixed).

Thanks,
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17679</commentid>
    <comment_count>3</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-02-13 17:24:08 +0000</bug_when>
    <thetext>I&apos;m running with the 1.0.1-b07 release from Maven (on Oracle). I will try to put together a test job to reproduce it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17706</commentid>
    <comment_count>4</comment_count>
      <attachid>195</attachid>
    <who name="">m_edgar</who>
    <bug_when>2015-02-20 03:09:48 +0000</bug_when>
    <thetext>Created attachment 195
Junit test with JSL demonstrating issue</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>17707</commentid>
    <comment_count>5</comment_count>
      <attachid>196</attachid>
    <who name="">m_edgar</who>
    <bug_when>2015-02-20 03:11:10 +0000</bug_when>
    <thetext>Created attachment 196
Proposed patch

Possible patch - decrement the item reader only when a null item is read from the reader rather than separately during metrics update</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18328</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-05-09 11:07:50 +0000</bug_when>
    <thetext>
Thanks m_edgar, I think I fixed at least the metrics IllegalStateException in:

https://github.com/WASdev/standards.jsr352.jbatch/commit/41fe2829927fb28bedbd9c44cafa3210cd2cbd6a

(and included essentially your test in the previous commit).  


I noticed your comment about the rollback issue too but didn&apos;t get around to looking at that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18331</commentid>
    <comment_count>7</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-05-11 02:31:40 +0000</bug_when>
    <thetext>Thanks Scott. Regarding the rollback exception, this occurs when an exception occurs following the chunk commit. Specifically, when endCheckpoint, invokeCollectorIfPresent, or updateNormalMetrics (as in this case) are called.

Since the transaction has been committed, when the logic in the &apos;catch&apos; runs, an IllegalStateException is thrown when calling setRollbackOnly. This prevents the calls to the reader and writer close methods, as well as the call to any chunk listener onError methods. 

Lastly, the call to rollback in the finally cause triggers an additional IllegalStateException. One possibility may be to check the status from the transaction manager and skip the setRollbackOnly and rollback calls if the status is STATUS_NO_TRANSACTION.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18332</commentid>
    <comment_count>8</comment_count>
    <who name="">m_edgar</who>
    <bug_when>2015-05-11 02:41:31 +0000</bug_when>
    <thetext>Just to add some additional context to my previous comment, here are the locations I referenced in ChuckStepControllerImpl, invokeChunk.

try {
  ...

  while (true) {
    ...

    transactionManager.commit(); &lt;-- End of TX

    checkpointManager.endCheckpoint(); &lt;-- possible exception #1

    invokeCollectorIfPresent(); &lt;-- possible exception #2

    updateNormalMetrics(chunkToWrite.size()); &lt;-- possible exception #3

    ...
  }
} catch (Throwable t) {
  try {
    logger.log(Level.SEVERE, &quot;Failure in Read-Process-Write Loop&quot;, t);
    transactionManager.setRollbackOnly();  &lt;-- IllegalStateException

    callReaderAndWriterCloseOnThrowable(t);

    if (t instanceof Exception) {
      callChunkListenerOnError((Exception)t);
    }

    stepContext.getMetric(MetricImpl.MetricType.ROLLBACK_COUNT).incValue();
  } finally {
    transactionManager.rollback(); &lt;-- IllegalStateException
  }
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19086</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-03 16:04:27 +0000</bug_when>
    <thetext>IllegalStateExc portion fixed in:
https://github.com/WASdev/standards.jsr352.jbatch/commit/00a487cdde32a7477263dd4b659d9470b5ed8deb

Thanks for the writeup.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>195</attachid>
            <date>2015-02-20 03:09:00 +0000</date>
            <delta_ts>2015-02-20 03:09:48 +0000</delta_ts>
            <desc>Junit test with JSL demonstrating issue</desc>
            <filename>jbatch-bug-6742-test.zip</filename>
            <type>application/octet-stream</type>
            <size>2119</size>
            <attacher>m_edgar</attacher>
            

          </attachment>
          <attachment
              isobsolete="0"
              ispatch="1"
              isprivate="0"
          >
            <attachid>196</attachid>
            <date>2015-02-20 03:11:00 +0000</date>
            <delta_ts>2015-02-20 03:11:10 +0000</delta_ts>
            <desc>Proposed patch</desc>
            <filename>ChunkStepControllerImpl.patch</filename>
            <type>text/plain</type>
            <size>1512</size>
            <attacher>m_edgar</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>6830</bug_id>
          
          <creation_ts>2015-03-19 23:54:00 +0000</creation_ts>
          <short_desc>ChunkListener.onError() method not invoked before retry rollback</short_desc>
          <delta_ts>2015-05-14 13:55:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>cf126330</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>17879</commentid>
    <comment_count>0</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-03-19 23:54:06 +0000</bug_when>
    <thetext>8.2.1.4.4 Default Retry Behavior - Rollback
...

If the optional ChunkListener is configured on the step, the onError method is called before rollback.
&lt;/quote&gt;

When testing on GlassFish, ChunkListener.onError() method is not invoked for a retryable exception from reader. 

RetryReadListener.onRetryReadException() method is correctly invoked.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18362</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-05-14 03:47:40 +0000</bug_when>
    <thetext>Just looking at the code, I&apos;d expect we&apos;ve fixed this and the problem would not exist in a nightly build of GlassFish from the past few months.   

Are you testing in one of the official release versions then?   

(Sorry this has been such a slow response, you might not remember !)

Do you have a test handy?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>18365</commentid>
    <comment_count>2</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-05-14 13:55:01 +0000</bug_when>
    <thetext>I was testing against GF 4.1 release.  I just tried GF 5/13 nightly and verified that the problem no longer exists.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7287</bug_id>
          
          <creation_ts>2015-09-05 09:15:00 +0000</creation_ts>
          <short_desc>Add a HTTP API on top of JobOperator</short_desc>
          <delta_ts>2016-03-16 14:43:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>cf126330</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19112</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:15:54 +0000</bug_when>
    <thetext>Idea is to let easily integrate with batches even remotely.

We can abuse of JAX-RS 2 in term of server and client if needed - but not sure at this point, depends if the API provides DTO or not.

Implemetations should provide the server part IMO and the spec can provide DTO.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19204</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-11 15:50:18 +0000</bug_when>
    <thetext>Can you please elaborate on this.  What do you see the spec-defined DTO looking like?   Perhaps just give an example for a single operation.

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19205</commentid>
    <comment_count>2</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-11 16:15:16 +0000</bug_when>
    <thetext>Here is a sample: https://github.com/apache/incubator-batchee/tree/master/gui/jaxrs/jaxrs-common/src/main/java/org/apache/batchee/jaxrs/common</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19237</commentid>
    <comment_count>3</comment_count>
    <who name="">cf126330</who>
    <bug_when>2015-09-23 13:48:18 +0000</bug_when>
    <thetext>+1 for at least providing standard batch-related DTO.

It will simplify batch application developers&apos; work to standardize this common and reusable set of DTO.  It may also be used by batch spec implementations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19238</commentid>
    <comment_count>4</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-23 14:25:46 +0000</bug_when>
    <thetext>Still trying to understand..so the proposal is to standardize something like the package:

https://github.com/apache/incubator-batchee/blob/master/gui/jaxrs/jaxrs-common/src/main/java/org/apache/batchee/jaxrs/common/
?

Including or not including JBatchResource?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19239</commentid>
    <comment_count>5</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-23 16:06:02 +0000</bug_when>
    <thetext>I&apos;d define the HTTP API, not yet sure it we need JAXRS detail or not. Having JBatchResource as an interface can be nice for everybody:

- server/impl are used to get interfaces
- client can be generated through proxying in 1 line without any more work for anyone</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19240</commentid>
    <comment_count>6</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-23 19:20:14 +0000</bug_when>
    <thetext>So one thread of thought here is we should provide DTOs for certain JobOperator-related classes, like javax.batch.runtime.*.

Not sure which way I&apos;m leaning, but why don&apos;t we open a separate issue for the pure DTO angle?

As for exposing JobOperator over HTTP API, that seems to be heading towards territory we&apos;ve purposely left out of this JSR, so I&apos;m leaning towards rejecting that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19242</commentid>
    <comment_count>7</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2015-09-23 19:21:35 +0000</bug_when>
    <thetext>See Bug 7318.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19243</commentid>
    <comment_count>8</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-23 19:43:22 +0000</bug_when>
    <thetext>Well the idea would be to get a management API - think there is something planned in EE as well. Maybe we should ping them to see if they want to take it over their spec rather than here (would make sense)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19811</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-16 14:43:14 +0000</bug_when>
    <thetext>I&apos;m not clear what&apos;s still being proposed so closing this for now.
Note we have the separate Bug 7318 for the DTO.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7292</bug_id>
          
          <creation_ts>2015-09-05 09:37:00 +0000</creation_ts>
          <short_desc>chains support</short_desc>
          <delta_ts>2016-03-16 14:20:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>SPEC</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rmannibucau</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19117</commentid>
    <comment_count>0</comment_count>
    <who name="">rmannibucau</who>
    <bug_when>2015-09-05 09:37:25 +0000</bug_when>
    <thetext>Issue: I have a library of generic components and need to chain them before going to the next step of a chunk.


Here is a &quot;schema&quot; of the flow: reader1 -&gt; reader2 -&gt; processor1 -&gt; processor2 -&gt; ... -&gt; processorN -&gt; writer1 and writer2


Points to discuss:
- how to define a chain? simply providing a list for each component?
- what behavior for each components? for readers/processors it seems natural to sequence them but for writers we could parallelize them optionnally</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19810</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-03-16 14:20:39 +0000</bug_when>
    <thetext>As we&apos;ve mentioned before on the mailing list, since the JSR 352 EG went with a single reader, processor, and writer, I think we should leave it at that for now.  


Perhaps a future JSR could reconsider this, learning from implementation-specific innovations.  

As mentioned in this thread,
https://java.net/projects/jbatch/lists/public/archive/2015-10/message/5
I still think it&apos;s worth considering if there are any changes we should make to facilitate parameterization of the children (or chained) artifacts, but we don&apos;t have an issue on the table open for that even at this point.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>7514</bug_id>
          
          <creation_ts>2016-02-03 04:56:00 +0000</creation_ts>
          <short_desc>BatchJobUtils#purgeOwnedRepositoryData(String tagName) throws unexpected exception</short_desc>
          <delta_ts>2016-02-03 14:44:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>RI</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>MOVED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>haotian</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>19674</commentid>
    <comment_count>0</comment_count>
    <who name="">haotian</who>
    <bug_when>2016-02-03 04:56:25 +0000</bug_when>
    <thetext>When calling BatchJobUtils#purgeOwnedRepositoryData(String tagName), if the datasource is not available or the batch schema not created, both will throw NullPointerException

Expected Results:

1) If the available datasource not available, a meaningful exception should be thrown rather than NullPointerException.

2) If the batch schema not created, then this method should return silently because there is no data to purge.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>19677</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2016-02-03 14:44:00 +0000</bug_when>
    <thetext>Moving to GitHub (this bugzilla is now only being used for spec and some TCK issues):

https://github.com/WASdev/standards.jsr352.jbatch/issues/45

Thanks.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>115857</bug_id>
          
          <creation_ts>2016-09-16 12:33:00 +0000</creation_ts>
          <short_desc>a good behavier +1-855 880-8488 What is the Number for delta Airlines</short_desc>
          <delta_ts>2016-10-06 17:59:37 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>rikki3004</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>133083</commentid>
    <comment_count>0</comment_count>
    <who name="">rikki3004</who>
    <bug_when>2016-09-16 12:33:53 +0000</bug_when>
    <thetext>a good behavier +1-855 880-8488 What is the Number for delta Airlines
Call Delta Airlines +1-855 880-8488
Call on this number +1-855 880-8488 for Delta Airlines Reservations. You can use this number for Reservations, Exchanges, Ticket Booking, Flight Timing etc.
Delta Airlines Reservations Phone Number
Delta Airlines airfare sale
Delta Airlines booking
Delta Airlines booking number
Delta Airlines booking phone number
Delta Airlines cheap fares
Delta Airlines cheap flights
Delta Airlines cheap tickets
Delta Airlines contact number
Delta Airlines customer care
Delta Airlines customer care number
Delta Airlines customer care phone number
Delta Airlines customer service
Delta Airlines customer service number
Delta Airlines customer service phone number
Delta Airlines customer support
Delta Airlines customer support number
Delta Airlines customer support phone number
Delta Airlines flight booking
Delta Airlines flight schedules
Delta Airlines flights
Delta Airlines last minute flights
Delta Airlines online booking
Delta Airlines phone number
Delta Airlines reservation
Delta Airlines reservation number
Delta Airlines reservation phone number
Delta Airlines ticket booking
Delta Airlines ticket booking number
Delta Airlines ticket booking phone number
Delta Airlines ticket change
Delta Airlines ticket number
Delta Airlines ticket reservation
Delta Airlines tickets on sale
Delta Airlines tollfree number

Delta Airlines Customer Care Phone Number
Delta Airlines Customer Service Phone Number 
Delta Airlines Helpline Phone Number  
Delta Airlines Toll Free Phone Number 
Delta Airlines Customer Service Phone Number 
Delta Airlines Customer Support  
Delta Airlines Contact Number 
Delta Airlines Phone Number  
Delta Airlines Booking Number 
Delta Airlines Toll Free Number 
Delta Airlines Reservation Number 
Delta Airlines Helpline Number +1-855 880-8488 
Delta Airlines Customer Care Number +1-855 880-8488 
People Search For The Delta Airlines Phone Number When They Want To Book Reservations 
With Delta Airlines. So Here We Are On This Video To Show Delta Airlines Phone Number. Call Us And Get Discounts. They Can Call Us Regarding Any Query For Delta Airlines Flights. And Get Discounted rates.
Delta Airlines Booking Number,
Delta Airlines Toll Free Number,
Delta Airlines Reservation Number,
Delta Airlines Helpline Number,
Delta Airlines Customer Care Number,
American airlines helpline number 
Delta airlines helpline number
jetblue airways helpline number
alaska airlines helpline number
spirit airlines helpline number
Allegiant airlines helpline number
virgin america helpline number
American airlines customer service number
Data airlines customer care number
Southwest airlines online tickets 
Delta airlines customer service
jetblue airways customer service
alaska airlines customer service
spirit airlines customer service
Allegiant airlines customer service
virgin america customer service
Cheap Flight Tickets to atlanta
Low Cost Airline Tickets to Austin,
Last minute airline tickets to New york,
Cheap airline tickets to New orleans
Cheap airline tickets to Los Angeles
Booking air ticket online for chicago
cheap flights to Jacksonville 
cheap flights to honolulu
Cheap flights to atlanta
Online cheap flights tickets to atlanta
Low cost flights to atlanta
Low price airline tickets to atlanta
Low cost airline tickets to atlanta
cheapest flights tickets.
Discounted airline tickets from students/military
Best flight deals to atlanta.
Best flight deals to atlanta
Economy flight tickets to atlanta
Economy flights to atlanta.
Economy airline tickets
Last minute cheap flights to atlanta.
Last minute air tickets
Reservation airline ticket
Online flight ticket reservation to atlanta
Online flight ticket booking
Airfare to atlanta
Cheap Flight Tickets
Low Cost Airline Tickets
Low Cost Flight Tickets
Reservation flight tickets
Reservation airline ticket
Online international air ticket booking
flight ticket booking online international
Airfares cheap ticket
Last minute flights for cheaps
Booking air ticket
Booking air ticket online
Cheap Air Tickets
Last minute flights
Cheap Airline Tickets
Cheap Airways Tickets
Cheap Flight Tickets Online
Cheap Flight Ticket Online
Low Price Airline Tickets</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>209338</bug_id>
          
          <creation_ts>2017-01-03 18:40:00 +0000</creation_ts>
          <short_desc>???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION</short_desc>
          <delta_ts>2017-04-05 20:07:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>Ericjon</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>226934</commentid>
    <comment_count>0</comment_count>
    <who name="">Ericjon</who>
    <bug_when>2017-01-03 18:40:38 +0000</bug_when>
    <thetext>???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE 85-57-55-00-44&gt;&gt;&lt;&lt; COLOARDO Intuit Quickbooks Payroll Support Phone number NEW YORK Ronny Georgia ^^^855-755-000-4&gt;&gt;Intuit Quickbooks Customer Support Phone 

Number Texas Georgia &lt;&lt;&lt;&lt;85-57-55-00-44&gt;&gt;&gt;&gt; Intuit Quickbooks Enterprise Customer Support Number ^^^^&lt;&gt;TEXAS&lt;&gt;&lt;&gt;185/575-50+044&lt;&gt; &lt;&gt;&lt;&gt;^^ New York Quickbooks Payroll Support 

Phone Number (New York) ro&gt;&gt;se&gt;&gt; California ((1-877)75-5:-0044)))) Coloardo Intuit Quickbooks Payroll Support Phone Number  New  york Pine :the :shake New Jersy 1 85 57 55 00 

44()()( 24/7 Georgia Intuit Quickbooks Payroll SUPPORT Phone Number Colorado Georgia 85&quot;&quot;57&quot;&quot;55&quot;&apos;00&quot;&quot;44 New York Intuit Quickbooks customer support toll free number Texas 

Intuit )(&gt;1-855-755-004-4&gt;() Georgia Quickbooks Payroll Customer Support Number Ohio USA sandy (New Jersey) !^^1-855-755&lt;004-4  Georgia Quickbooks Intuit Payroll Technical 

toll free Support Number Texas 185}}575{{500{{44 New Jersey Quickbooks Payroll Support Phone toll free numberro&quot;&quot;mio{{{}}}}}} 1!! 855!!755!!0044 I ntuit Quickbooks Enterprise 

Payroll Customer S upport toll free number&gt;&gt;&gt;&gt;&gt;&gt; Texas &apos;&apos;&apos;1*855{755}00-44-- New JerseyIntuit Quickbooks Point Of Sale Technical Support toll free Number tata bye bye New York 

***1 855 7----55 00--44--  Texas Quickbooks Payroll Support Phone Number Usa 24-7https://java.net/bugzilla/show_bug.cgi?id=173087 Ohio rocoarto 85&apos;&apos;57&apos;&apos;55&apos;&apos;00&apos; {}{}{} OHIo 

{}California{} Support Number For Quickbooks Support @@California@@ ++1-855-755-0044++ New York ++ Quickbooks Payroll Support Phone Number @@@@18557550044@@@@ &lt;&lt;TExas&gt;&gt; 

Quickbooks Customer Support Phone NumbER &lt;&gt;@&lt;&gt;@&lt;&gt;18557550044&lt;&gt;@&lt;&gt;@&lt;&gt; {{tEXAS}} qUICKBOOKS cUSTOMER sUPPORT nUMBER [JAPAN] [[New York]] ??1-855-755-0044?? ((California)) 

Quickbooks Payroll Customer Support number &lt;&lt;@@ California @@&gt;&gt; 1 855 755 0044 {{Ohio}} Quickbooks Point Of Sale Support Number USA &lt;&gt;@&lt;&gt;18557550044&lt;&gt;@&lt;&gt; {{{{teXAS}}} 

qUICKBOOKS pOINT OF SALE SUPPORT NUMBER @@1&lt;&gt;855&lt;&gt;755&lt;&gt;0044@@ Quickbooks Payroll customer support number 24/7 Californian +++18557&lt;&gt;550044++ {{Texas}} Quickbooks Payroll 

Customer support number ??&lt;@&gt;?1.85.57.55.00.44?&lt;@&gt;? Texas? California ? Quickbooks Payroll Customer Support Phone Number Quickbooks PAYROLL Customer Support Toll Free number 

Texas 1.85.57.55.00.44 Ohio HORNN BLOW &lt;teXAS&gt; &lt;&lt;1.8.5.5.7.5.5.0.0.4.4&gt;&gt; &lt;cALIFORNIA&gt; qUICKBOOKS pAYROLL sUPPORT tOLL fREE NUMBER ????1~85~57~55~00~44???? @Texas@California@ 

?Quickbooks  ?Customer ?Support ?Phone ?Number Aap Ki Adalat ????1*8*5*5*7*5*5*0*0*4*4????  {{Texas}} [California] Quickbooks Point Of Sale Support Number ????? {}{%}{}

1=85~57-55*00.44{}{%}{} Ohio//Texas\\ Quickbooks Payroll Support Phone Number Connecticut Bahamas 1*855*755_0044 QuickBooks Payroll Support Number New Hampshire New York/ 

California 1{855}{755}{0044} QuickBooks Enterprise Customer Support Number California/Los Angeles 1(855)-(755)-(0044)? Bahamas Quickbooks desktop support number Connecticut 

Bahamas 1*855*755_0044 {ALASKA} QuickBooks Payroll Support Number Georgia/New York Intuit 1*855*755_0044&lt;&gt;&lt;&gt; QuickBooks Customer Support Number (IOWA) Alabama ?(1{855}{755}

{0044} Intuit QuickBooks Support Number 24/7 Montgomery Birmingham, Montgomery, Mobile, Huntsville, Tuscaloosa Connecticut 1(855)-(755)-(0044) Quickbooks Point Of sale 

support numbeer Hartford Birmingham, Montgomery, Mobile, Huntsville, Tuscaloosa @@Alaska@@ 1(855)-(755)-(0044) @&lt;&gt;@New York@&lt;&gt;@ Intuit QuickBooks Support Number Juneau 

Anchorage, Fairbanks, Juneau, Sitka, Ketchikan ???Arizona??? 1(855)-(755)-(0044) Intuit QuickBooks Support Number Phoenix, Tucson, Mesa, Chandler, Glendale &lt;&lt;&gt;&gt; OHi&lt;&lt;&gt;&gt; ?

1~855*755_0044 {{California}} Intuit QuickBooks Support Number Little Rock, Fort Smith, North Little Rock, Fayetteville, Springdale ??New York?? 1(855)?(755)-(0044) ??

California?? Intuit QuickBooks Support Number Little Rock Little Rock, Fort Smith, North Little Rock, Fayetteville, Springdale &lt;&gt;%&lt;&gt;California &lt;&lt;@&gt;&gt;1(855)-(755)-(0044)&lt;&lt;@&gt;&gt; 

Intuit QUickBooks Payroll Support Number Los Angeles, San Diego, San Jose, San Francisco, Fresno Jashn-e-Rekhta Phone California {{1-855-755-0044}} Texas Number For 

Quickbooks Enterprise Technical Support Telephone ????? Texas {}{}1~855*755*0044{}{} [[California]] ++Ohio++ Phone Number for Quickbooks enterprise payroll support Richa 

Anirudh California {{{1~855~755~0044}}} (Ohio) Phone number for quickbooks intuit tech support &lt;&gt;@@&lt;&gt;18557550044&lt;&gt;@@&lt;&gt; [[California]] texas Phone number for quickbook 

enterprise desktop support )()()(Ohio)()() (1~855*755*0044) )()California()( Phone Number For Quickbooks Customer Support 24/7 Suddenly  California @&lt;&gt;@1**855**755**0044@&lt;&gt;@ 

(()()TEXAS)()()( Ohio~ Phone number for quickbooks payroll @TExas@%@@18557550044@@%@California@ Phone Number For Quickbooks Technical Support Tahir Faraz @California@ 

{{{1+855+755+0044}}} [[Texas]] Contact Number For Quickbooks Intuit Support &quot;USA&quot; +++1.8.5.5.7.5.5.0.0.4.4+++ @Texas@Phone number for Quickbooks Mac Customer Service @New 

York@ ???? &lt;@&gt; ]]&lt;&lt;@@&gt;&gt; TEchnical SUpport For Quickbooks jAI sRI rAM &lt;&lt;1~855~755~0044&gt;&gt; inTUIT qqUICKBOOKS pOINT OF SALE SUPPORT 

nUMBER************************************************************************************************************************************************************************

******************************************************************************************************************************************************************************

******************
+++[[[1+855+755+0044]]]&lt;&gt;Intuit &lt;&gt;Quickbooks &lt;&gt;Enterprise 2017 &lt;&gt;Customer &lt;&gt;Support &lt;&gt;Toll~free &lt;&gt;NUmber @texas@ California @New York@Support {{{18 55 75 50 044}}} Number For 

Quickbooks technical support {{1&lt;&gt;85&lt;&gt;57&lt;&gt;55&lt;&gt;00&lt;&gt;404}} BABABA???Support 1^855^755^0044 intuit Number for Quickbooks TEchbnical Support ? ???? ?? ((1.8.5.5.7.5.5.0.0.4.4)) ?? 

Intuit Quickbooks Technical support   ???@&lt;&gt;@(1 855 755 0044)@&lt;&gt;@ Intuit Quickbooks Technical support Number 24x7  BABABA Quickbooks [[[1~855 {{755}} 0044]]] Support For  

[https://kdp.amazon.com/community/thread.jspa?threadID=331719]  Technical ????????{{{1 855 755 0044}}} Quickbooks Technical Support Toll FRee Number  +1*855*755*0044 ?Intuit? 

Phone Number For  [https://kdp.amazon.com/community/thread.jspa?threadID=331743] Tech Support New york//CALIFORNIA//CANADA\\ ALL TIME@24/7@ 1 844 414 4868 Phone number for 

quickbooks 24/7 support TEXAS/CALIFORNIA\?????? POS Support{}{8.5.5.7.5.5.0.0.4.4}{} Quickbooks Point Of Sale NuMBer
ALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 

Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone 

[https://kdp.amazon.com/community/thread.jspa?threadID=331745]  for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support 

TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL 

TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 

Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for 

Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical 

Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXA NAMO ???

CANADA 1 844 414 4868 Phone number for quickbooks 24/7 support CALIFORNIA  preternatural {{ {}&lt;&gt; Quickbooks Point Of Sale NUMBER????! Intuit &lt;&gt;{}1.8.5.5.7.5.5.0.0.4.4{}&lt;&gt; 

Quickbooks Point Of Sale NUMBER babaho +++[[1~855~755~0044]]++ 24x7 Quickbooks Point Of Sale Support Number ???? ?? ????? {}@{}1~855~755~0044{}@{} Quickbooks Point of Sale 

2013 Support Number USA.UK ???? ?????{@855~755~0044@} Quickbooks  [https://kdp.amazon.com/community/thread.jspa?threadID=333575]  of Sale 2016 Support Number U.K 

https://kdp.amazon.com/community/thread.jspa?threadID=333504 ???@(1?855?755?0044)Quickbooks Point Of Sale Customer Support phone Numbers 

https://kdp.amazon.com/community/thread.jspa? ???? USA1?855?755?0044UK Quickbooks Point of Sale Support Phone 

NumberthreadID=333504https://kdp.amazon.com/community/thread.jspa?threadID=333504https:// ???? ????? [@[855~755~0044]@] Quickbooks Point Of Sale South Africa USA UK @?1?855?

755?0044?@ Quickbooks Point Of Sale Software Free Download Support ???? USA1?855?755?0044UK Quickbooks Point of Sale Support Phone Number Intuit []1?855?755?0044[] 

Quickbooks Point of SaleSupport  Phone Number intuit {855~755~0044} Quickbooks Point Of Sale Customer Support Number 24/7 ????? ?[]?1 855 755 0044?[]? Quickbooks Point Of 

Sale Support Number 24/7 *??*Phone ++[855~755~0044]++ Quickbooks Point Of SAle Support Number [OHIO] HUM tunm Ek [][]85.5.75.5.0.0.44{}{} Quickbooks Point Of Sale Support 

24x7 Ding 1: {=}1+855+755+0044[=] Intuit Quickbooks Point Of Sale Support Number @)85.575500.44(@Quickbooks Point Of SAle Support Number 24x7 ????? ?!!? [[855?755?0044]] ?!!? 

Quickbooks Point oF sALE cUSTOMER sUPPORT nUMBER ?24/7? !!&amp;!!&amp;[[%]]1~8557~550~044NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHONE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION???? ???? ??? }{cALIFORNIA}{ 855 [755]] 0044 &apos;&apos;teXAS&apos;&apos; sUPPORT fOR qUICKBOOKS eNTERPRISE tOLL fREE pHO 85-57-55-00-44&gt;&gt;&lt;&lt; COLOARDO Intuit Quickbooks Payroll Support Phone number NEW YORK Ronny Georgia ^^^855-755-000-4&gt;&gt;Intuit Quickbooks Customer Support Phone 

Number Texas Georgia &lt;&lt;&lt;&lt;85-57-55-00-44&gt;&gt;&gt;&gt; Intuit Quickbooks Enterprise Customer Support Number ^^^^&lt;&gt;TEXAS&lt;&gt;&lt;&gt;185/575-50+044&lt;&gt; &lt;&gt;&lt;&gt;^^ New York Quickbooks Payroll Support 

Phone Number (New York) ro&gt;&gt;se&gt;&gt; California ((1-877)75-5:-0044)))) Coloardo Intuit Quickbooks Payroll Support Phone Number  New  york Pine :the :shake New Jersy 1 85 57 55 00 

44()()( 24/7 Georgia Intuit Quickbooks Payroll SUPPORT Phone Number Colorado Georgia 85&quot;&quot;57&quot;&quot;55&quot;&apos;00&quot;&quot;44 New York Intuit Quickbooks customer support toll free number Texas 

Intuit )(&gt;1-855-755-004-4&gt;() Georgia Quickbooks Payroll Customer Support Number Ohio USA sandy (New Jersey) !^^1-855-755&lt;004-4  Georgia Quickbooks Intuit Payroll Technical 

toll free Support Number Texas 185}}575{{500{{44 New Jersey Quickbooks Payroll Support Phone toll free numberro&quot;&quot;mio{{{}}}}}} 1!! 855!!755!!0044 I ntuit Quickbooks Enterprise 

Payroll Customer S upport toll free number&gt;&gt;&gt;&gt;&gt;&gt; Texas &apos;&apos;&apos;1*855{755}00-44-- New JerseyIntuit Quickbooks Point Of Sale Technical Support toll free Number tata bye bye New York 

***1 855 7----55 00--44--  Texas Quickbooks Payroll Support Phone Number Usa 24-7https://java.net/bugzilla/show_bug.cgi?id=173087 Ohio rocoarto 85&apos;&apos;57&apos;&apos;55&apos;&apos;00&apos; {}{}{} OHIo 

{}California{} Support Number For Quickbooks Support @@California@@ ++1-855-755-0044++ New York ++ Quickbooks Payroll Support Phone Number @@@@18557550044@@@@ &lt;&lt;TExas&gt;&gt; 

Quickbooks Customer Support Phone NumbER &lt;&gt;@&lt;&gt;@&lt;&gt;18557550044&lt;&gt;@&lt;&gt;@&lt;&gt; {{tEXAS}} qUICKBOOKS cUSTOMER sUPPORT nUMBER [JAPAN] [[New York]] ??1-855-755-0044?? ((California)) 

Quickbooks Payroll Customer Support number &lt;&lt;@@ California @@&gt;&gt; 1 855 755 0044 {{Ohio}} Quickbooks Point Of Sale Support Number USA &lt;&gt;@&lt;&gt;18557550044&lt;&gt;@&lt;&gt; {{{{teXAS}}} 

qUICKBOOKS pOINT OF SALE SUPPORT NUMBER @@1&lt;&gt;855&lt;&gt;755&lt;&gt;0044@@ Quickbooks Payroll customer support number 24/7 Californian +++18557&lt;&gt;550044++ {{Texas}} Quickbooks Payroll 

Customer support number ??&lt;@&gt;?1.85.57.55.00.44?&lt;@&gt;? Texas? California ? Quickbooks Payroll Customer Support Phone Number Quickbooks PAYROLL Customer Support Toll Free number 

Texas 1.85.57.55.00.44 Ohio HORNN BLOW &lt;teXAS&gt; &lt;&lt;1.8.5.5.7.5.5.0.0.4.4&gt;&gt; &lt;cALIFORNIA&gt; qUICKBOOKS pAYROLL sUPPORT tOLL fREE NUMBER ????1~85~57~55~00~44???? @Texas@California@ 

?Quickbooks  ?Customer ?Support ?Phone ?Number Aap Ki Adalat ????1*8*5*5*7*5*5*0*0*4*4????  {{Texas}} [California] Quickbooks Point Of Sale Support Number ????? {}{%}{}

1=85~57-55*00.44{}{%}{} Ohio//Texas\\ Quickbooks Payroll Support Phone Number Connecticut Bahamas 1*855*755_0044 QuickBooks Payroll Support Number New Hampshire New York/ 

California 1{855}{755}{0044} QuickBooks Enterprise Customer Support Number California/Los Angeles 1(855)-(755)-(0044)? Bahamas Quickbooks desktop support number Connecticut 

Bahamas 1*855*755_0044 {ALASKA} QuickBooks Payroll Support Number Georgia/New York Intuit 1*855*755_0044&lt;&gt;&lt;&gt; QuickBooks Customer Support Number (IOWA) Alabama ?(1{855}{755}

{0044} Intuit QuickBooks Support Number 24/7 Montgomery Birmingham, Montgomery, Mobile, Huntsville, Tuscaloosa Connecticut 1(855)-(755)-(0044) Quickbooks Point Of sale 

support numbeer Hartford Birmingham, Montgomery, Mobile, Huntsville, Tuscaloosa @@Alaska@@ 1(855)-(755)-(0044) @&lt;&gt;@New York@&lt;&gt;@ Intuit QuickBooks Support Number Juneau 

Anchorage, Fairbanks, Juneau, Sitka, Ketchikan ???Arizona??? 1(855)-(755)-(0044) Intuit QuickBooks Support Number Phoenix, Tucson, Mesa, Chandler, Glendale &lt;&lt;&gt;&gt; OHi&lt;&lt;&gt;&gt; ?

1~855*755_0044 {{California}} Intuit QuickBooks Support Number Little Rock, Fort Smith, North Little Rock, Fayetteville, Springdale ??New York?? 1(855)?(755)-(0044) ??

California?? Intuit QuickBooks Support Number Little Rock Little Rock, Fort Smith, North Little Rock, Fayetteville, Springdale &lt;&gt;%&lt;&gt;California &lt;&lt;@&gt;&gt;1(855)-(755)-(0044)&lt;&lt;@&gt;&gt; 

Intuit QUickBooks Payroll Support Number Los Angeles, San Diego, San Jose, San Francisco, Fresno Jashn-e-Rekhta Phone California {{1-855-755-0044}} Texas Number For 

Quickbooks Enterprise Technical Support Telephone ????? Texas {}{}1~855*755*0044{}{} [[California]] ++Ohio++ Phone Number for Quickbooks enterprise payroll support Richa 

Anirudh California {{{1~855~755~0044}}} (Ohio) Phone number for quickbooks intuit tech support &lt;&gt;@@&lt;&gt;18557550044&lt;&gt;@@&lt;&gt; [[California]] texas Phone number for quickbook 

enterprise desktop support )()()(Ohio)()() (1~855*755*0044) )()California()( Phone Number For Quickbooks Customer Support 24/7 Suddenly  California @&lt;&gt;@1**855**755**0044@&lt;&gt;@ 

(()()TEXAS)()()( Ohio~ Phone number for quickbooks payroll @TExas@%@@18557550044@@%@California@ Phone Number For Quickbooks Technical Support Tahir Faraz @California@ 

{{{1+855+755+0044}}} [[Texas]] Contact Number For Quickbooks Intuit Support &quot;USA&quot; +++1.8.5.5.7.5.5.0.0.4.4+++ @Texas@Phone number for Quickbooks Mac Customer Service @New 

York@ ???? &lt;@&gt; ]]&lt;&lt;@@&gt;&gt; TEchnical SUpport For Quickbooks jAI sRI rAM &lt;&lt;1~855~755~0044&gt;&gt; inTUIT qqUICKBOOKS pOINT OF SALE SUPPORT 

nUMBER************************************************************************************************************************************************************************

******************************************************************************************************************************************************************************

******************
+++[[[1+855+755+0044]]]&lt;&gt;Intuit &lt;&gt;Quickbooks &lt;&gt;Enterprise 2017 &lt;&gt;Customer &lt;&gt;Support &lt;&gt;Toll~free &lt;&gt;NUmber @texas@ California @New York@Support {{{18 55 75 50 044}}} Number For 

Quickbooks technical support {{1&lt;&gt;85&lt;&gt;57&lt;&gt;55&lt;&gt;00&lt;&gt;404}} BABABA???Support 1^855^755^0044 intuit Number for Quickbooks TEchbnical Support ? ???? ?? ((1.8.5.5.7.5.5.0.0.4.4)) ?? 

Intuit Quickbooks Technical support   ???@&lt;&gt;@(1 855 755 0044)@&lt;&gt;@ Intuit Quickbooks Technical support Number 24x7  BABABA Quickbooks [[[1~855 {{755}} 0044]]] Support For  

[https://kdp.amazon.com/community/thread.jspa?threadID=331719]  Technical ????????{{{1 855 755 0044}}} Quickbooks Technical Support Toll FRee Number  +1*855*755*0044 ?Intuit? 

Phone Number For  [https://kdp.amazon.com/community/thread.jspa?threadID=331743] Tech Support New york//CALIFORNIA//CANADA\\ ALL TIME@24/7@ 1 844 414 4868 Phone number for 

quickbooks 24/7 support TEXAS/CALIFORNIA\?????? POS Support{}{8.5.5.7.5.5.0.0.4.4}{} Quickbooks Point Of Sale NuMBer
ALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 

Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone 

[https://kdp.amazon.com/community/thread.jspa?threadID=331745]  for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support 

TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL 

TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 

Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for 

Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical 

Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXAALL TIME@24/7@8557550044 Phone number for Quickbooks TEchnical Support TEXA NAMO ???

CANADA 1 844 414 4868 Phone number for quickbooks 24/7 support CALIFORNIA  preternatural {{ {}&lt;&gt; Quickbooks Point Of Sale NUMBER????! Intuit &lt;&gt;{}1.8.5.5.7.5.5.0.0.4.4{}&lt;&gt; 

Quickbooks Point Of Sale NUMBER babaho +++[[1~855~755~0044]]++ 24x7 Quickbooks Point Of Sale Support Number ???? ?? ????? {}@{}1~855~755~0044{}@{} Quickbooks Point of Sale 

2013 Support Number USA.UK ???? ?????{@855~755~0044@} Quickbooks  [https://kdp.amazon.com/community/thread.jspa?threadID=333575]  of Sale 2016 Support Number U.K 

https://kdp.amazon.com/community/thread.jspa?threadID=333504 ???@(1?855?755?0044)Quickbooks Point Of Sale Customer Support phone Numbers 

https://kdp.amazon.com/community/thread.jspa? ???? USA1?855?755?0044UK Quickbooks Point of Sale Support Phone 

NumberthreadID=333504https://kdp.amazon.com/community/thread.jspa?threadID=333504https:// ???? ????? [@[855~755~0044]@] Quickbooks Point Of Sale South Africa USA UK @?1?855?

755?0044?@ Quickbooks Point Of Sale Software Free Download Support ???? USA1?855?755?0044UK Quickbooks Point of Sale Support Phone Number Intuit []1?855?755?0044[] 

Quickbooks Point of SaleSupport  Phone Number intuit {855~755~0044} Quickbooks Point Of Sale Customer Support Number 24/7 ????? ?[]?1 855 755 0044?[]? Quickbooks Point Of 

Sale Support Number 24/7 *??*Phone ++[855~755~0044]++ Quickbooks Point Of SAle Support Number [OHIO] HUM tunm Ek [][]85.5.75.5.0.0.44{}{} Quickbooks Point Of Sale Support 

24x7 Ding 1: {=}1+855+755+0044[=] Intuit Quickbooks Point Of Sale Support Number @)85.575500.44(@Quickbooks Point Of SAle Support Number 24x7 ????? ?!!? [[855?755?0044]] ?!!? 

Quickbooks Point oF sALE cUSTOMER sUPPORT nUMBER ?24/7? !!&amp;!!&amp;[[%]]1~8557~550~044NE nUMBER USA 2017 uPGRADE NUMBER INTUIT QUICKBOOKS PAYROLL APPLICITION</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>479618</bug_id>
          
          <creation_ts>2017-03-28 12:01:00 +0000</creation_ts>
          <short_desc>BOBLEE__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==</short_desc>
          <delta_ts>2017-04-05 20:07:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>RESOLVED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>smithindiana41</reporter>
          <assigned_to>ScottKurz</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>498701</commentid>
    <comment_count>0</comment_count>
    <who name="">smithindiana41</who>
    <bug_when>2017-03-28 12:01:20 +0000</bug_when>
    <thetext>__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,
 

__1+888_809_3891++=

__1+888_809-3891+++==


1+888+809-3891




__1+888_809-3891+++==Charterhelplinnumber Charter Technical Support *1 888 809 3891* Charter Phone Number 1 888++809++3891++

__1+888_809-3891+++==Charter technical support contact number,__1+888_809-3891+++==
 Charter games support phone number, Charter payroll support phone number.
__1+888_809-3891+++== Charter payroll customer support phone number __1+888_809-3891+++==
__1+888_809-3891+++== Charter technical help telephone number, Charter technical __1+888_809-3891+++==
__1+888_809-3891+++==help contact number, Charter technical support contact number,__1+888_809-3891+++==


 __1+888_809-3891+++==Charter contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter contact phone number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter contact telephone number,__1+888_809-3891+++==
 Charter 21 hour *1 888 809 3891*contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter customer support contact number, __1+888_809-3891+++==
__1+888_809-3891+++==Charter customer service contact number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter official number, Charter official__1+888_809-3891+++==
 __1+888_809-3891+++==contact number, Charter 888 contact __1+888_809-3891+++==
number, Charter toll free number, 888 number for Charter support, __1+888_809-3891+++==
__1+888_809-3891+++==Charter 21/7 support phone number*1 888 809 3891*_
_1+888_809-3891+++== Charter GAMES support phone number,__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support phone number__1+888_809-3891+++==
__1+888_809-3891+++==,Charter GAMES help phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES technical support number.__1+888_809-3891+++==
__1+888_809-3891+++==Charter GAMES support number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES phone number,__1+888_809-3891+++==
__1+888_809-3891+++== Charter GAMES tech support number, __1+888_809-3891+++==
Charter GAMES customer support number, Charter GAMES customer support phone number, Charter GAMES customer service phone number, Charter GAMES payroll customer service phone number,</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4385</bug_id>
          
          <creation_ts>2012-12-03 02:09:00 +0000</creation_ts>
          <short_desc>Spec must specify the effect of throwing Exceptions from Listeners</short_desc>
          <delta_ts>2013-01-16 15:17:47 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P2</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mk111283</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11751</commentid>
    <comment_count>0</comment_count>
    <who name="">mk111283</who>
    <bug_when>2012-12-03 02:09:50 +0000</bug_when>
    <thetext>The spec must define the effect of throwing an Exception from a (Job, Step, Chunk}Listener.

For example, if a StepListener throws a (retryable / skippable) Exception will the  Step still be executed OR skipped OR failed?

The spec must similarly explain for other listeners.

Mahesh.Kannan@Oracle.Com</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11823</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-07 00:16:18 +0000</bug_when>
    <thetext>Yes, you are right.  I will update the spec accordingly.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4304</bug_id>
          
          <creation_ts>2012-11-12 18:19:00 +0000</creation_ts>
          <short_desc>Requirement to use @Named?</short_desc>
          <delta_ts>2013-01-16 17:44:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>chrisschaefer</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11517</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 18:19:18 +0000</bug_when>
    <thetext>In section 6 - Batch Programming Model, it states that all batch artifact classes must be named using the javax.inject.Named annotation. Why is this a hard requirement? I think the developer should have a choice to mark their classes with an annotation or configure it via XML.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11603</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:54:32 +0000</bug_when>
    <thetext>We need a way to go from ref=value in XML to a class name.  Ideally, the means by which this mapping occurs is portable across implementations.  I figured having the ref value match the @Named value would be a good way.  Otherwise, batch applications written for one implementation are not guaranteed to run with another.  Wouldn&apos;t that be undesireable?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11640</commentid>
    <comment_count>2</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-20 20:32:28 +0000</bug_when>
    <thetext>I do agree portability is a good thing but I also think it would be ideal to support XML, annotations or a combination of both. For example with Spring Batch I can XML wire everything as well as annotate supported functionality. 

I&apos;ve just started digging into the RI code and noticed that there is a BatchAnnotationProcessor that scans for annotations and writes a batch.xml file and the JSEBatchArtifactFactoryImpl reads that file, provides the ability to obtain an artifact by id, etc. 

So for example with the above use case (writing / reading from batch.xml), shouldn&apos;t it be possible for the developer to provide a complete batch.xml, have the batch.xml generated in full (via annotation scan), or provide a partial batch.xml which would then have scanned annotated artifacts merged into it?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11719</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:11:53 +0000</bug_when>
    <thetext>We could certainly consider supporting both. That would mean the ref= value would resolve to either an entry from batch.xml or an @Named annotation.  If both are specified,  batch.xml should probably take precedence. The batch.xml data could be read as a resource from the current classpath. Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11720</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:13:23 +0000</bug_when>
    <thetext>BTW, that annotation scanner is some old work we started.  I&apos;m not sure we&apos;re going to support it in the final RI implementation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11728</commentid>
    <comment_count>5</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-30 00:56:33 +0000</bug_when>
    <thetext>Let me interject and say where we&apos;re at and where we&apos;re going with the RI, though I&apos;m not sure it sheds much light on the original spec question.

Our working plans for the RI are to ship with artifact loading in the SE environment done using the META-INF/batch.xml (we also plan on shipping the compile-time annotation scanning to build this automatically).  This is by JSEBatchArtifactFactoryImpl as Chris S. mentioned.  It would also be possible to build this batch.xml by hand or other tooling.

The RI has a plug point, BatchArtifactFactory, (the default impl uses batch.xml like I mentioned).  We think we&apos;ll ship a CDI-based BatchArtifactFactory for use in JSE in case a user has pulled a CDI impl in but that&apos;s not a top priority since we plan to run the SE TCK against the batch.xml-based impl.

We&apos;re not looking to put a ton of polish around the pluggability here... e.g. programmatic config... we&apos;re not trying to anticipate all usages but just doc enough that someone wanting to take the code and do something else would know where to start.

-----

Having explained the RI..I&apos;m going to stop and think about the original question &quot;should @Named be a hard requirement&quot;..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11746</commentid>
    <comment_count>6</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-01 17:30:29 +0000</bug_when>
    <thetext>(In reply to comment #3)
&gt; We could certainly consider supporting both. That would mean the ref= value
&gt; would resolve to either an entry from batch.xml or an @Named annotation.  If
&gt; both are specified,  batch.xml should probably take precedence. The batch.xml
&gt; data could be read as a resource from the current classpath. Thoughts?

Yes I think that sounds like a good idea as it supports both methods. Having the batch.xml taking precedence sounds good as well. Might need to account for instances where the artifact is defined in both the batch.xml and the @Named annotation to avoid duplicate creation etc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11747</commentid>
    <comment_count>7</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-01 18:35:20 +0000</bug_when>
    <thetext>&gt; Our working plans for the RI are to ship with artifact loading in the SE
&gt; environment done using the META-INF/batch.xml (we also plan on shipping the
&gt; compile-time annotation scanning to build this automatically).  This is by
&gt; JSEBatchArtifactFactoryImpl as Chris S. mentioned.  It would also be possible
&gt; to build this batch.xml by hand or other tooling.

Will the RI ship with the ability to merge scanned artifacts into an existing batch.xml if present? I believe right now it would just get overwritten</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11752</commentid>
    <comment_count>8</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-12-03 14:57:01 +0000</bug_when>
    <thetext>(In reply to comment #7)
&gt; Will the RI ship with the ability to merge scanned artifacts into an existing
&gt; batch.xml if present? I believe right now it would just get overwritten

That&apos;s not a priority we have today.   To prioritize anything in this area we need to finish the spec conversation, and see what&apos;s needed just for compliance, then take it from there.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11755</commentid>
    <comment_count>9</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-12-03 15:48:52 +0000</bug_when>
    <thetext>(In reply to comment #6)
&gt; (In reply to comment #3)
&gt; &gt; We could certainly consider supporting both. That would mean the ref= value
&gt; &gt; would resolve to either an entry from batch.xml or an @Named annotation.  If
&gt; &gt; both are specified,  batch.xml should probably take precedence. The batch.xml
&gt; &gt; data could be read as a resource from the current classpath. Thoughts?
&gt; Yes I think that sounds like a good idea as it supports both methods. Having
&gt; the batch.xml taking precedence sounds good as well. Might need to account for
&gt; instances where the artifact is defined in both the batch.xml and the @Named
&gt; annotation to avoid duplicate creation etc.

I think that allowing the partial batch.xml and the override might be setting up an overly complicated CDI integration story.  If there is some precedent for such a framework, that would help me be more comfortable with this.

Otherwise, I&apos;d synthesize this discussion into the following proposal:

A JSR352 impl must support:

1) (SE, EE): batch.xml-based loading - 

 * In this case @Named is NOT required though it MAY be used to have a tool help build the batch.xml

 * batch.xml is like:
&lt;batch-artifacts&gt;
  &lt;batch-element&gt;*
&lt;/batch-artifacts&gt;

  where &lt;batch-element&gt; looks like 

   &lt;batch-type id=&quot;value of JSL @ref&quot;  class=&quot;qualified classname&quot; /&gt;

  e.g.: 
    &lt;batchlet id=&quot;MyBatchlet&quot; class=&quot;mypkg.BatchletUsingStepContextImpl&quot; /&gt;
    &lt;item-processor id=&quot;MyProcessor&quot; class=&quot;mypkg.MyArrayItemProcessorImpl&quot; /&gt;
      ...
 
  Note: we also have to define the batch-type(s) then.


2) (EE): CDI 

 * Using @Named values to match JSL @ref values


Finally, we say that batch.xml loading takes precedence over CDI.   

----

I think that leaves us encouraging but not requiring everything to define the artifacts with @Named.   We get a portable behavior in the absence of CDI (e.g. in SE).

Some of the details with this proposal I&apos;d want to think about a bit more ... e.g. would it be better to somehow have CDI take precedence over batch.xml in EE?

------

Again I feel like there should be another JSR we can usefully reference as precedent in this discussion.   Sorry, haven&apos;t had the time to investigate more though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11780</commentid>
    <comment_count>10</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-05 19:08:57 +0000</bug_when>
    <thetext>&gt; I think that allowing the partial batch.xml and the override might be setting
&gt; up an overly complicated CDI integration story.  If there is some precedent for
&gt; such a framework, that would help me be more comfortable with this.

I don&apos;t use CDI so I may be missing some of the details. The main reason I brought it up was to provide people the ability to use a mix of both configuration options if they choose (similar to Spring).

&gt; Otherwise, I&apos;d synthesize this discussion into the following proposal:
&gt; 
&gt; A JSR352 impl must support:
&gt; 
&gt; 1) (SE, EE): batch.xml-based loading - 
&gt; 
&gt;  * In this case @Named is NOT required though it MAY be used to have a tool
&gt; help build the batch.xml
&gt; 
&gt;  * batch.xml is like:
&gt; &lt;batch-artifacts&gt;
&gt;   &lt;batch-element&gt;*
&gt; &lt;/batch-artifacts&gt;
&gt; 
&gt;   where &lt;batch-element&gt; looks like 
&gt; 
&gt;    &lt;batch-type id=&quot;value of JSL @ref&quot;  class=&quot;qualified classname&quot; /&gt;
&gt; 
&gt;   e.g.: 
&gt;     &lt;batchlet id=&quot;MyBatchlet&quot; class=&quot;mypkg.BatchletUsingStepContextImpl&quot; /&gt;
&gt;     &lt;item-processor id=&quot;MyProcessor&quot; class=&quot;mypkg.MyArrayItemProcessorImpl&quot; /&gt;
&gt;       ...
&gt; 
&gt;   Note: we also have to define the batch-type(s) then.
&gt; 
&gt; 
&gt; 2) (EE): CDI 
&gt; 
&gt;  * Using @Named values to match JSL @ref values
&gt; 
&gt; 
&gt; Finally, we say that batch.xml loading takes precedence over CDI.   
&gt;
&gt; ----
&gt; 
&gt; I think that leaves us encouraging but not requiring everything to define the
&gt; artifacts with @Named.   We get a portable behavior in the absence of CDI (e.g.
&gt; in SE).

At a high level I think that seems fine.
 
&gt; Some of the details with this proposal I&apos;d want to think about a bit more ...
&gt; e.g. would it be better to somehow have CDI take precedence over batch.xml in
&gt; EE?

It appears like a sticky situation since with case 1 the batch.xml can be built from hand, tooling that looks for @Named, etc. In this case if we say CDI takes precedence and the artifacts from batch.xml aren&apos;t loaded as well then we are limited to @Named marked classes.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11792</commentid>
    <comment_count>11</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 17:44:03 +0000</bug_when>
    <thetext>Ok, I think we have a direction: developers can use batch.xml and/or @Named.  EE implementation must support both;  SE must support only batch.xml.  Annotation processor is not part of spec - *may* be included in final RI as a development aid. But with virtually all annotations being removed,  what becomes the purpose of an annotation processor?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11808</commentid>
    <comment_count>12</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-06 21:40:49 +0000</bug_when>
    <thetext>(In reply to comment #11)
&gt; Ok, I think we have a direction: developers can use batch.xml and/or @Named. 
&gt; EE implementation must support both;  SE must support only batch.xml. 
&gt; Annotation processor is not part of spec - *may* be included in final RI as a
&gt; development aid. But with virtually all annotations being removed,  what
&gt; becomes the purpose of an annotation processor?

If the only remaining annotations are DI ones then yea the annotation processor doesn&apos;t seem to have a purpose.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12102</commentid>
    <comment_count>13</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:44:21 +0000</bug_when>
    <thetext>@Named has been removed from the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>3472</bug_id>
          
          <creation_ts>2011-11-01 09:54:00 +0000</creation_ts>
          <short_desc>Link to ANSI/ISA S88 Batch Standard seems to be broken</short_desc>
          <delta_ts>2013-01-16 18:14:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc>http://jcp.org/en/jsr/detail?id=352</bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>picpromusic</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>9375</commentid>
    <comment_count>0</comment_count>
    <who name="">picpromusic</who>
    <bug_when>2011-11-01 09:54:46 +0000</bug_when>
    <thetext>The Link to the ANSI/ISA S88 Batch Standard - http://www.isa.org/~phila/phillyisa/documents/S88intro-PhillyISAFeb2002.pdf seems to be broken.

I found some information on S88 on wikipedia: http://en.wikipedia.org/wiki/ISA-88</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9458</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2011-11-28 13:39:28 +0000</bug_when>
    <thetext>The corrected link is: 


http://www.isa.org/Content/Microsites165/SP18,_Instrument_Signals_and_Alarms/Home163/ISA_Standards_for_Committee_Use/S_8801.PDF


I do not see a way for me to update the JSR text online.  I will contact the administrator to see about adding this correction to the JSR text.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12103</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 18:14:22 +0000</bug_when>
    <thetext>I can no longer find a reliable link to documentation concerning this standard. I will ask the PMO to update the JSR page to point to the wikipedia article:

http://en.wikipedia.org/wiki/ISA-88</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>3473</bug_id>
          
          <creation_ts>2011-11-01 10:00:00 +0000</creation_ts>
          <short_desc>Missing Mailing List for public discussion</short_desc>
          <delta_ts>2013-01-16 17:52:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc>http://java.net/projects/jbatch/lists</bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>picpromusic</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>batmat</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>9376</commentid>
    <comment_count>0</comment_count>
    <who name="">picpromusic</who>
    <bug_when>2011-11-01 10:00:56 +0000</bug_when>
    <thetext>Im JCP 2.8 (http://jcp.org/en/procedures/jcp2) 1.1.1 Public Communications it is recommend to establish a instrument to enable public feedback. Is JSR352 using just the bug-tracker? Or should there be another public discussion(mailing-list)?

I think issues@jbatch.java.net is just for the issues from bugzilla(http://java.net/bugzilla). It would be nice to have an discussion-list like discuss@jbatch.java.net.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9377</commentid>
    <comment_count>1</comment_count>
    <who name="">batmat</who>
    <bug_when>2011-11-01 18:58:30 +0000</bug_when>
    <thetext>+1. Please don&apos;t make the same as Stephen Colebourne described for the Project Lambda&apos;s JSR (http://blog.joda.org/2011/10/transparency-in-action.html).

As stated in the JSR http://jcp.org/en/jsr/detail?id=352 &quot;We&apos;ll use a public mailing list for comments.&quot;. This one should be created quickly to enable an open feedback loop.

Thanks a lot.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9379</commentid>
    <comment_count>2</comment_count>
    <who name="">picpromusic</who>
    <bug_when>2011-11-02 05:35:11 +0000</bug_when>
    <thetext>(In reply to comment #1)
&gt; +1. Please don&apos;t make the same as Stephen Colebourne described for the Project
&gt; Lambda&apos;s JSR (http://blog.joda.org/2011/10/transparency-in-action.html).
This wasn&apos;t my intention. Thanks for remebering me.
&gt; 
&gt; As stated in the JSR http://jcp.org/en/jsr/detail?id=352 &quot;We&apos;ll use a public
&gt; mailing list for comments.&quot;. This one should be created quickly to enable an
&gt; open feedback loop.
That was my goal. Public feedback through an bug tracker doesn&apos;t feel like the right solution. Isn&apos;t it?
&gt; 
&gt; Thanks a lot.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9459</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2011-11-28 14:17:56 +0000</bug_when>
    <thetext>Really sorry gang,  I&apos;m new to the JSR process and I didn&apos;t realize bugzilla, mailing lists, etc were used to discuss and track issues with the JSR itself. I thought these things were only for the EG, when and if the JSR got approved. Shame on me, I guess I should have known better.  

I didn&apos;t have a subscription setup, so I didn&apos;t receive notification that any of your were posting things out here.  So, I&apos;m late to the party, but now trying to make things right.  

My intention is to comply with the transparency rules described by JSR 348. I have to double-check those requirements.  I believe compliance will include a communication structure involving at least a public expert group mailing list and a writable public observer mailing list.  

I will update this bug to communicate resolution.  Thank you.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>9484</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2011-12-05 20:47:03 +0000</bug_when>
    <thetext>The statement about a private mailing list has been removed from the JSR. All JSR 352 Expert Group communication will be public, in keeping with JCP 2.8.  The exact details will be announced shortly, as the expert group formation completes.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4051</bug_id>
          
          <creation_ts>2012-08-20 15:34:00 +0000</creation_ts>
          <short_desc>How to get StepExecution</short_desc>
          <delta_ts>2013-01-16 23:09:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>htavarez</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>10933</commentid>
    <comment_count>0</comment_count>
    <who name="">htavarez</who>
    <bug_when>2012-08-20 15:34:02 +0000</bug_when>
    <thetext>The JobOperator provides a method getStepExecution(jobExecutionId, stepExecutionId) but how do we get the stepExecutionId?  

In fig.X under 1.2 Step, It is implied that a jobExecution has many stepExecutions, but how do we get all the steps executed for a given job execution?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11257</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:44:11 +0000</bug_when>
    <thetext>Looks like we need to add a method for that.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11754</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 15:42:23 +0000</bug_when>
    <thetext>Currently the spec does not have a way to get a StepExecution from the JobExecution it&apos;s related to.  Do we want to fix this issue by correcting that instead or just adding a method to the JobOperator?  Spring Batch handles it by allowing the user to get the StepExecutions from the JobExecution (http://static.springsource.org/spring-batch/apidocs/org/springframework/batch/core/JobExecution.html#getStepExecutions()).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12098</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:26:56 +0000</bug_when>
    <thetext>The following method was added to JobOperator:

	List&lt;StepExecution&gt; getStepExecutions(long executionId) throws NoSuchJobExecutionException;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4085</bug_id>
          
          <creation_ts>2012-08-31 18:12:00 +0000</creation_ts>
          <short_desc>Missing spec detail on problematic inheritance cases</short_desc>
          <delta_ts>2013-01-16 18:29:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>blocker</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ctedlock</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11026</commentid>
    <comment_count>0</comment_count>
    <who name="">ctedlock</who>
    <bug_when>2012-08-31 18:12:10 +0000</bug_when>
    <thetext>Hi,

Below are a few problematic paths that came up while implementing inheritance section 5.8 of the spec. The examples given are narrow in scope, and it&apos;s not clear what should happen in the general case.

Thanks,
Collin

Problematic Inheritance Cases:


1. Inherit leads to schema invalid result

parent:
&lt;step id=&quot;parent&quot;&gt;
	&lt;chunk reader=&quot;r&quot; writer=&quot;w&quot; processor=&quot;p&quot; chunk-size=&quot;1&quot;/&gt;
&lt;/step&gt;

child:
&lt;step id=&quot;child&quot; parent=&quot;parent&quot;&gt;
	&lt;batchlet ref=&quot;b&quot;/&gt;
&lt;/step&gt;

anticipated merge:

&lt;step id=&quot;child&quot;&gt;
	&lt;batchlet ref=&quot;b&quot;/&gt;
	&lt;chunk reader=&quot;r&quot; writer=&quot;w&quot; processor=&quot;p&quot; chunk-size=&quot;1&quot;/&gt;
&lt;/step&gt;




2. Inherited subelement id collides with existing element

parent:
&lt;job id=&quot;parent&quot;&gt;
	&lt;step id=&quot;step&quot; next=&quot;next&quot;&gt;
		&lt;batchlet ref=&quot;b&quot;/&gt;
	&lt;/step&gt;
&lt;/job&gt;

child:
&lt;job id=&quot;child&quot; parent=&quot;parent&quot;&gt;
	&lt;step id=&quot;step&quot; start-limit=&quot;1&quot;&gt;
		&lt;properties&gt;&lt;property name=&quot;n&quot; value=&quot;v&quot;/&gt;&lt;/properties&gt;
	&lt;/step&gt;
&lt;/job&gt;

Merge option 1, child overrides:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;step&quot; start-limit=&quot;1&quot;&gt;
		&lt;properties&gt;&lt;property name=&quot;n&quot; value=&quot;v&quot;/&gt;&lt;/properties&gt;
	&lt;/step&gt;
&lt;/job&gt;

Merge option 2, parent overrides:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;step&quot; next=&quot;next&quot;&gt;
		&lt;batchlet ref=&quot;b&quot;/&gt;
	&lt;/step&gt;
&lt;/job&gt;

Merge option 3, merge attributes only:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;step&quot; start-limit=&quot;1&quot; next=&quot;next&quot;&gt;
		&lt;properties&gt;&lt;property name=&quot;n&quot; value=&quot;v&quot;/&gt;&lt;/properties&gt;
	&lt;/step&gt;
&lt;/job&gt;

Merge option 4, full recursive merge of subelements:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;step&quot; start-limit=&quot;1&quot; next=&quot;next&quot;&gt;
		&lt;properties&gt;&lt;property name=&quot;n&quot; value=&quot;v&quot;/&gt;&lt;/properties&gt;
		&lt;batchlet ref=&quot;b&quot;/&gt;
	&lt;/step&gt;
&lt;/job&gt;


3. Inherit colliding id from dissimilar element

parent:
&lt;job id=&quot;parent&quot;&gt;
	&lt;step id=&quot;collide&quot;/&gt;
&lt;/job&gt;

child:
&lt;job id=&quot;child&quot; parent=&quot;parent&quot;&gt;
	&lt;split id=&quot;collide&quot;/&gt;
&lt;/job&gt;

Merge option 1, error:
Throw an exception on id collision.

Merge option 2, loose merge without validation:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;collide&quot;/&gt;
	&lt;split id=&quot;collide&quot;/&gt;
&lt;/job&gt;

Merge option 3, child overrides:
&lt;job id=&quot;child&quot;&gt;
	&lt;split id=&quot;collide&quot;/&gt;
&lt;/job&gt;

Merge option 4, parent overrides:
&lt;job id=&quot;child&quot;&gt;
	&lt;step id=&quot;collide&quot;/&gt;
&lt;/job&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11066</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-09-07 15:10:32 +0000</bug_when>
    <thetext>Good questions.  Let me respond by first asserting the general rule and then applying to your questions.  

General rule: 

Inheritance combines the elements and attributes of the child and parent, with the child overriding parent attributes. 

Aside: I presume inheritance occurs first, and validation of the resultant job definition second. 

Applied to your questions:

1. Combine the elements, allow validation to flag error - i.e. mutually exclusive elements.

2. Merge option 4 (i.e. combine parent and child elements) 

3. Merge option 2 (i.e. combine parent and child elements, allow validation to flag error - i.e. duplicate ids)

Additional note:  remember that lists (&lt;listeners&gt; and &lt;properties&gt;) get special treatment with the merge=true|false attribute.  True means combine the child and parent lists;  false means child list overrides parent list.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11075</commentid>
    <comment_count>2</comment_count>
    <who name="">ctedlock</who>
    <bug_when>2012-09-10 15:54:43 +0000</bug_when>
    <thetext>Thanks Chris, that helps clear some things up.

There&apos;s a problem #4 here as well, as relates to ordering of elements when inheriting. See below.

Thanks,
Collin


4. How to order inherited elements. There are three subcases:
4a. Inherited properties at any level

The spec imposes no ordering, and intuitively it would seem that property order doesn&apos;t matter. That is:

&lt;properties&gt;
  &lt;property name=&quot;prop1&quot; value=&quot;prop1&quot;/&gt;
  &lt;property name=&quot;prop2&quot; value=&quot;prop2&quot;/&gt;
&lt;/properties&gt;

is equivalent to:

&lt;properties&gt;
  &lt;property name=&quot;prop2&quot; value=&quot;prop2&quot;/&gt;
  &lt;property name=&quot;prop1&quot; value=&quot;prop1&quot;/&gt;
&lt;/properties&gt;

Is this true?


4b. Inherited listeners at any level
Per the spec, e.g.; section 5.1.1: &quot;If multiple job listeners are configured on the same job,  they are invoked in the order they are specified.&quot;
Therefore listener order affects code execution.

Parent listener XML:
&lt;job id=&quot;parent&quot;&gt;
  &lt;listeners&gt;
    &lt;listener ref=&quot;parentListener&quot;/&gt;
  &lt;/listeners&gt;
&lt;/job&gt;

Child listener XML:
&lt;job id=&quot;child&quot; parent=&quot;parent&quot;&gt;
  &lt;listeners merge=&quot;true&quot;&gt;
    &lt;listener ref=&quot;childListener&quot;/&gt;
  &lt;/listeners&gt;
&lt;/job&gt;

Potential merge 1 (parent comes first):
&lt;job id=&quot;child&quot;&gt;
  &lt;listeners&gt;
    &lt;listener ref=&quot;parentListener&quot;/&gt;
    &lt;listener ref=&quot;childListener&quot;/&gt;
  &lt;/listeners&gt;
&lt;/job&gt;

Potential merge 2 (child comes first):
&lt;job id=&quot;child&quot;&gt;
  &lt;listeners&gt;
    &lt;listener ref=&quot;childListener&quot;/&gt;
    &lt;listener ref=&quot;parentListener&quot;/&gt;
  &lt;/listeners&gt;
&lt;/job&gt;

Which should happen? The example in section 5.1.1 of the spec suggests, but does not explicitly state, that option 1 is correct.


4c. Inherited execution elements
Execution element is not a term formally defined by the spec, but section 6.4.1.2 uses it to describe a step, split, or flow. I use it here loosely to describe the logical flow of a job.

Per 5.2.5: &quot;The first step, flow, or split defines the first step (flow or split) to execute for a given Job XML.  The &apos;next&apos; attribute on the step, flow, or split defines what executes next.&quot;
Per 5.2, the &apos;next&apos; attribute &quot;specifies the next step, flow, split, or decision to run after this step is complete.  It must be a valid XML string value.  This is an optional attribute.   The default is this step is the last step in the job.&quot;

&lt;job id=&quot;parent&quot;&gt;
  &lt;step id=&quot;parentStep&quot;/&gt;
&lt;/job&gt;

&lt;job id=&quot;child&quot; parent=&quot;parent&quot;&gt;
  &lt;step id=&quot;childStep&quot;/&gt;
&lt;/job&gt;

Merge option 1 (parent goes first):
&lt;job id=&quot;child&quot;&gt;
  &lt;step id=&quot;parentStep&quot;/&gt;
  &lt;step id=&quot;childStep&quot;/&gt;
&lt;/job&gt;
Here, parentStep goes first by virtue of being first element, executes first. The childStep, by virtue of 1) being the only other step, and 2) being the only step without a next attribute, will go last. (Side note: what happens if there is a third step here, also without a next attribute?)


Merge option 2 (parent goes last):
&lt;job id=&quot;child&quot;&gt;
  &lt;step id=&quot;childStep&quot;/&gt;
  &lt;step id=&quot;parentStep&quot;/&gt;
&lt;/job&gt;
Here, the reverse happens. Which is correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11076</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-09-10 16:17:59 +0000</bug_when>
    <thetext>(In reply to comment #2) 
Good questions.  Answers: 
&gt; 4. How to order inherited elements. There are three subcases:
The principle is natural order.  Let&apos;s see how that affects outcomes below:
&gt; 4a. Inherited properties at any level
&gt; The spec imposes no ordering, and intuitively it would seem that property order
&gt; doesn&apos;t matter. 
Correct:  property order does not matter.  However, when merge=true, properties should be ordered parent-first, child-second - i.e. natural order.
&gt; 4b. Inherited listeners at any level
Parent-first, child-second (i.e. your option 1)
&gt; 4c. Inherited execution elements
Parent-first, child-second (i.e. your option 1)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11278</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 13:52:30 +0000</bug_when>
    <thetext>After further discussion with the EG,  we have decided to match Spring Batch inheritance rules.  I believe that means:

1. jobs can inherit jobs, but not parent&apos;s steps, flows, splits 

2. steps can inherit steps 

3. non-intersecting elements are merged 

4. non-intersecting attributes on intersecting elements are merged 

5. intersecting attributes on intersecting elements result in child overrides parent attribute

6. lists support merge=true|false attribute.  Note: the order in which listeners are invokes is not guaranteed, so the order in which they are merged does not matter.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11279</commentid>
    <comment_count>5</comment_count>
    <who name="">ctedlock</who>
    <bug_when>2012-10-10 14:17:35 +0000</bug_when>
    <thetext>(In reply to comment #4)

Does #1 mean that when inheriting from a job we do not pull in its steps, flows, and splits into the final merged job? i.e.; we only merge properties and listeners?

#2 only mentions steps explicitly; combined with #1 then are flows and splits no longer inheritable at all?

#3-#5 seem to imply no changes to direction except that we are restricting what can be merged by #1 and #2.

For #6:
In the 3.0 spec, (Sec 5.1.1), the order of the listeners is stated to matter:

&quot;Multiple listeners may be configured on a job.  A job listener is invoked according to its relationship to the job life cycle.  If multiple job listeners are configured on the same job,  they are invoked in the order they are specified.  &quot;

Is that changing or should this be reconsidered?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11280</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 14:30:30 +0000</bug_when>
    <thetext>Does #1 mean that when inheriting from a job we do not pull in its steps,
flows, and splits into the final merged job? i.e.; we only merge properties and
listeners?

Correct.

#2 only mentions steps explicitly; combined with #1 then are flows and splits
no longer inheritable at all?

Correct.

#3-#5 seem to imply no changes to direction except that we are restricting what
can be merged by #1 and #2.

Correct. 

For #6:
In the 3.0 spec, (Sec 5.1.1), the order of the listeners is stated to matter:

&quot;Multiple listeners may be configured on a job.  A job listener is invoked
according to its relationship to the job life cycle.  If multiple job listeners
are configured on the same job,  they are invoked in the order they are
specified.  &quot;

Is that changing or should this be reconsidered?  

Listeners order is not guaranteed.  The spec draft was in error.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4091</bug_id>
          
          <creation_ts>2012-09-04 14:04:00 +0000</creation_ts>
          <short_desc>JobOperator missing &apos;abandon&apos; operation</short_desc>
          <delta_ts>2013-01-16 18:39:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11032</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-04 14:04:44 +0000</bug_when>
    <thetext>JobOperator missing &apos;abandon&apos; operation as mentioned in Sec 5.5 discussion of ABANDONED state.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11067</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-09-07 15:13:08 +0000</bug_when>
    <thetext>You are correct.  That is a spec oversight, which will be corrected before we go to JCP Final Approval Ballot.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12052</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:20:36 +0000</bug_when>
    <thetext>method was added to final approval draft</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4092</bug_id>
          
          <creation_ts>2012-09-04 14:35:00 +0000</creation_ts>
          <short_desc>Exit status globbing tweaks suggested</short_desc>
          <delta_ts>2013-01-16 23:03:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11033</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-04 14:35:57 +0000</bug_when>
    <thetext>For exit status pattern-matching (in decisions) we have (Sec 5.2.5 and several other similar places):

...Specifies an exit status to match to the current next element.  It must be a valid XML string value.  Wildcards of &quot;*&quot; and &quot;?&quot; may be used.  &quot;*&quot; matches one or more characters.  &quot;?&quot; matches exactly one character.....


Three comments:

A) The typical behavior in globbing for Ant, shell, etc. is for &quot;*&quot; to match zero or more characters, rather than one or more.  I think &quot;one or more&quot; is surprising. 

B) Since the majority (though not all) glob impls seem to support backslash escaping... it would only help clarify to point out that this is not supported.      (I don&apos;t see the need for escaping either since by the time you&apos;re in JSL you&apos;re not trying to defer a wildcard expansion to some other processing...  you&apos;re already at the end of the line).   

C) It would also only help to state that multiple &quot;*&quot; and &quot;?&quot; chars are allowed in the pattern string, with combinations of the two.    I think this is a more obvious thing to assume, in contrast to B), so could be omitted for brevity.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11219</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:16:05 +0000</bug_when>
    <thetext>I agree with all three recommendations and will incorporate them into the next draft of the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12081</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:19:45 +0000</bug_when>
    <thetext>actually spec was updated with recommendation of item A) only</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4098</bug_id>
          
          <creation_ts>2012-09-05 14:56:00 +0000</creation_ts>
          <short_desc>More detail needed on execution sequence during restart</short_desc>
          <delta_ts>2013-01-16 17:45:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11043</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-05 14:56:45 +0000</bug_when>
    <thetext>First, if this is the wrong place to make a note like this, please let me know.   (e.g. if you&apos;d rather I bring it up on the mailing list).  This isn&apos;t a bug, it is just a suggestion.   I thought it would be helpful to capture it as an item to be addressed though so I&apos;m starting here.

I think the spec takes too much for granted with respect to the execution sequence during restart.

To kick off the discussion, let me write some sample proposal text.   I&apos;m not necessarily strongly arguing for the interpretations explained below, and I&apos;m more interested in simply having the behavior clarified one way or the other.

Though I expect the examples below are less common or even rare use cases, I do think they are worth clarifying in the spec.

------------------------------------------------------------------------------

Suggested text:

==================
Restart processing
==================

The key idea to understand in restart processing is that while the business logic of the step may or may not need to be rerun, 
(if it already ran to a COMPLETED state in an earlier execution), the decision logic WILL always rerun.   

Though it will probably be an atypical case, the ability to use Job XML substitution combined with the ability to use different
job parameter values on restart (different than the parameter values on the original execution) means that the step sequence could
be substantially different on the restart execution.

Though it&apos;s a complicated example, this sequence illustrates the point:

(Note in all these examples I&apos;m using the default value for &quot;allow-start-if-complete&quot;, which is &apos;false&apos;)

Say we start with:

&lt;step id=&quot;step1&quot;&gt;
  &lt;next on=&quot;#{jobParameters[&apos;parm1&apos;]}&quot; to=&quot;step2&quot; /&gt;
  &lt;next on=&quot;*&quot; to=&quot;step3&quot; /&gt;
  ...

&lt;step id=&quot;step3&quot;&gt;
  ...
  &lt;stop on=&quot;#{jobParameters[&apos;parm2&apos;]}&quot; restart=&quot;step1&quot;/&gt;
  
During the job execution for the original job submission, we have:
parm1 =&gt; set to &quot;RC1.a&quot;. 
parm2 =&gt; set to &quot;RC3.a&quot;. 

As it turns out, &quot;step1&quot; ends with exit status &quot;RC1.b&quot;.  So execution proceeds
to &quot;step3&quot;, which exits with &quot;RC3.a&quot;, and so the job is stopped.

During restart, the value of parm1 is overridden to &quot;RC1.b&quot;.   The business logic in &quot;step1&quot;, having already completed, is not re-run,
and the earlier exit status of &quot;RC1.b&quot; is used.  

However, now the first &apos;next on&apos; clause matches the &quot;step1&quot; exit status, and so execution proceeds to &quot;step2&quot;, even though &quot;step2&quot; may
have not have already run in any previous execution.

If execution ever proceeds to &quot;step3&quot;, the business logic in &quot;step3&quot; will NOT be re-run, but the earlier exit status of &quot;RC3.a&quot; will
be used.  This is true even though the execution sequence landed on &quot;step3&quot; via a different route. Of course, if job parameter &apos;parm2&apos; is not overridden, the job execution will again stop after &quot;step3&quot;.

-------

Another point is that, in contrast to step business logic, the decider application logic is always rerun.

I.e. for something like:

&lt;decision id=&quot;decision1&quot; ref=&quot;MyDecider&quot;&gt;
  &lt;properties&gt;	
	&lt;property name=&quot;prop1&quot; value=&quot;jobParameters[&apos;d1.prop1Val&apos;]&quot; /&gt;
  &lt;/properties&gt;

then the logic in &quot;MyDecider&quot; will always rerun, and overridden job parameters in decision properties can similarly cause the execution sequence to differ than that in the original execution.


------------------------------------------------------------------------------

We could go even further.

One more quick example:  be clear that if stepX runs for the first time in execution 2, and stepY for the first time in execution 3, then on execution 4 neither stepX nor stepY will rerun (i.e. it&apos;s not just the steps that just ran on the last most recent execution that won&apos;t rerun).   Maybe that&apos;s clear enough without additionally spelling it out though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11259</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:44:56 +0000</bug_when>
    <thetext>Agreed.  Expect this in next rev of spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11647</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-21 12:34:52 +0000</bug_when>
    <thetext>Just realizing that in writing this up we should be sure to incorporate, allow-start-if-complete, as this of course will cause the application logic to rerun as well on restart.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11762</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 19:47:15 +0000</bug_when>
    <thetext>This is a big departure from what was expected (and what we thought was implied) in the current version of the spec.  It has been my expectation that since steps are independent components, once a step is complete, it should not be re-evaluated to determine the flow.

The example provided by Scott opens up a large can of worms.  If we follow that logic that all decision logic is rerun...if I have a 3 step job that fails in step 3, this is saying that the job could in theory be restarted from any step on the fly.  Spring Batch (for reference) does not allow parameter injection at this point for this reason.  We do have a &quot;allow-start-if-complete&quot; for steps that should be rerun if the job is restarted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11765</commentid>
    <comment_count>4</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-12-03 21:16:18 +0000</bug_when>
    <thetext>I think this example illuminates the difference in side effects from the natural key approach to job identification vs id generation.  Now that you explain some scenarios I think there are unwanted side effects for steps that are going to be more difficult to manage than immutable jobs / steps once a job is executed. I relented on job identification before because it seemed to be the general feeling of the group but seeing the side effects makes me want to reconsider the discussion around job identification and what value allowing the changing of job parameters adds to the batch DSL.  I remember one member (Tim?) described a scenario that he felt required upstream data cleanup that provoked job parameter changes but there may be better ways to solve that problem.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11817</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 23:53:04 +0000</bug_when>
    <thetext>Ok, well I didn&apos;t expect the firestorm that has now ensued :)  

A few points:

1) The use case for job parameters on restart exists, but is somewhat weak.  So it&apos;s not worth breaking a sweat over.

2) If we were determined to have job parameters on restart (which we are not) we could restrict substitution on flow control elements/attributes.  

3) Rather than heroic efforts, I think we should just drop job parameters on restart from the spec.  

4) Dropping job parameters on restart increases harmony with SpringBatch. If some vendor thinks this is important, they are free to add a non-standard extension if they think it adds value.  

5) We are free to propose adding job parameters on restart in a future version of the spec if it ever becomes important.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11818</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 23:56:12 +0000</bug_when>
    <thetext>So to conclude:

1) I retract my statements in comment #1. 

2) I propose we remove job parameters on restart from the spec.  

3) We still need to work out how restart behaves.  The objective in this instance is to follow the example offered by Spring Batch.  There are some questions about that behavior and some of that behavior may need to be described in the spec.  So that&apos;s what we have to work on.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4110</bug_id>
          
          <creation_ts>2012-09-07 13:44:00 +0000</creation_ts>
          <short_desc>Clarify at what point the JobOperator.stop returns (and maybe start/restart?)</short_desc>
          <delta_ts>2013-01-16 23:04:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11065</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-07 13:44:22 +0000</bug_when>
    <thetext>Reading into the return types of stop/start/restart... it&apos;s clear that you expect them to work asynchronously to the actual stop/start/restart.

E.g. if you expected stop() to block until the job was stopped, you&apos;d have some kind of return code indicator.   And start/restart are clearly supposed to return once the execution id has been assigned.

So I&apos;m calling this minor but I think it would help to spell it out a bit more...  knowing that a method is asynchronous in any manner is one of the most important things to know about it.   I think it could even be in the Javadoc as you&apos;ve started describing it there..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11249</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:11:11 +0000</bug_when>
    <thetext>I will clarify in the spec.  I will start here:

JobOperator.stop is a non-blocking operation.  It returns after the stop directive has been queued up for processing by the batch container.  JobOperator.stop does not indicate whether or not the job has actually stopped. That is known only by querying job status.

The processing of the queued element should start an asynchronous unit of execution (e.g. executor thread) that carries out the stop request by invoking the batchlet&apos;s stop method and then by interrupting the thread.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12091</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:14:53 +0000</bug_when>
    <thetext>This is clearly documented in 7.8.10 JobOperator.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4111</bug_id>
          
          <creation_ts>2012-09-07 17:19:00 +0000</creation_ts>
          <short_desc>spec should point out that you can&apos;t repeat steps/splits/flows within a single job execution</short_desc>
          <delta_ts>2013-01-16 23:05:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11068</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-07 17:19:11 +0000</bug_when>
    <thetext>From email:


Should we outlaw revisiting a given step within a job?

&lt;step id=&quot;step1&quot; next=&quot;step2&quot;&gt;
...
&lt;step id=&quot;step2&quot; next=&quot;step1&quot;&gt;

----------

Should it be outlawed?  Yes, because it is not valid.  Without special detection in the batch runtime,  it would result in an endless loop.  

FYI, by default,  a step runs to completion only once for a given job instance.  That may be overridden by specifying allow-start-if-complete on the step,  but that only applies to each execution (i.e. to the initial start or to a restart).   Therefore, strictly speaking, a step may run to completion no more than once per execution.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11240</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:21:11 +0000</bug_when>
    <thetext>Agreed.  This is a documentation issue that will be addressed in next rev of spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12093</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:19:32 +0000</bug_when>
    <thetext>the spec says you can&apos;t loop</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4113</bug_id>
          
          <creation_ts>2012-09-10 14:55:00 +0000</creation_ts>
          <short_desc>JobOperator checked exceptions should be fully defined in Sec. 7.10</short_desc>
          <delta_ts>2013-01-16 23:05:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11074</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-10 14:55:57 +0000</bug_when>
    <thetext>The JobOperator checked exception classes:

NoSuchJobException,
NoSuchJobInstanceException,
NoSuchJobExecutionException, 
JobStartException,
JobRestartException,
JobInstanceAlreadyCompleteException,
JobExecutionNotRunningException

need a package, plus getters/setters, and constructors.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11243</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:33:52 +0000</bug_when>
    <thetext>Agreed.  Next spec rev.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11763</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 19:54:07 +0000</bug_when>
    <thetext>Small point of clarification here....All of the exceptions defined in the spec are RuntimeExceptions (BatchOperationsRuntimeException extends RuntimeException).  Should we be declaring those exceptions in the throws clauses at all?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12086</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:31:40 +0000</bug_when>
    <thetext>I reduced the amount of specification around this and the spec now only lists the defined exceptions:

1.	JobExecutionAlreadyCompleteException
2.	JobExecutionIsRunningException
3.	JobExecutionNotMostRecentException
4.	JobExecutionNotRunningException
5.	JobRestartException
6.	JobStartException
7.	NoSuchJobException
8.	NoSuchJobExecutionException
9.	NoSuchJobInstanceException


The RI will reveal a concrete implementation.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4115</bug_id>
          
          <creation_ts>2012-09-11 14:43:00 +0000</creation_ts>
          <short_desc>Spec should mention chunk loops ends when reader returns null</short_desc>
          <delta_ts>2013-01-16 23:05:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11079</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-11 14:43:19 +0000</bug_when>
    <thetext>Sorry if this is already there... I don&apos;t see it though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11246</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 20:36:27 +0000</bug_when>
    <thetext>It should be there. I don&apos;t see it either.  Thanks for reminding me.  I&apos;ll add it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12090</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:09:41 +0000</bug_when>
    <thetext>Well, I forgot to add this to the spec.  I just updated secdtion 6.1.1.1 ItemReader to state that the step ends when the reader returns null.  This update will appear in proposed final draft iterim version v1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4117</bug_id>
          
          <creation_ts>2012-09-11 22:57:00 +0000</creation_ts>
          <short_desc>LogicalTx* in RI and namespace</short_desc>
          <delta_ts>2013-01-16 23:01:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>waynexlund</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11082</commentid>
    <comment_count>0</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-09-11 22:57:34 +0000</bug_when>
    <thetext>We dropped the term LogicalTX and replaced with more concrete terms.  There are no references in the spec but there are remaining references in the RI and namespace.  This is a cleanup request to remove those leftover artifacts.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11238</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:04:23 +0000</bug_when>
    <thetext>Right, we need to catch the RI up with the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12078</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:13:52 +0000</bug_when>
    <thetext>RI will be 100% in sync with spec at final approval ballot</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4118</bug_id>
          
          <creation_ts>2012-09-12 21:12:00 +0000</creation_ts>
          <short_desc>For Sec. 5.2.1 Chunk JSL, need to update &quot;Syntax&quot; to match the table descriptions:</short_desc>
          <delta_ts>2013-01-16 23:06:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11083</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-12 21:12:03 +0000</bug_when>
    <thetext>For syntax you still have:

Syntax:
&lt;chunk reader=&quot;{ref}&quot; 
	processor=&quot;{ ref}&quot; 
	writer=&quot;{ ref}&quot; 
	checkpoint-policy=&quot;{item|time|custom}&quot; 
	commit-interval=&quot;{value}&quot; 
	buffer-reads=&quot;{true|false}&quot;  	
	chunk-size=&quot;{value}&quot;
	skip-limit=&quot;{value}&quot;
	retry-limit=&quot;{value}&quot;
/&gt;

But the table explains that buffer-reads and chunk-size have been replaced with 

&quot;buffer-size&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11242</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:33:28 +0000</bug_when>
    <thetext>Yes, this was noted in Bug 4160.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12085</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:28:26 +0000</bug_when>
    <thetext>updated</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4124</bug_id>
          
          <creation_ts>2012-09-13 22:02:00 +0000</creation_ts>
          <short_desc>For global tran chunk step, are open/close performed in global tran?</short_desc>
          <delta_ts>2013-01-16 23:06:41 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11090</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-13 22:02:24 +0000</bug_when>
    <thetext>Say I&apos;m in global transaction mode, my last checkpoint was just committed, and my app blows up in @AfterCheckpoint.

Do we agree that the step status is still set to STARTED?    

I.e. the commit/rollback of the last checkpoint by the runtime is only coordinated with the batch application&apos;s use of enlisted transactional resources... 
It is not coordinated with the updating of step and job/status.

In theory this could mean that on restart, you reach the &apos;start-limit&apos; and end up in FAILED state even though the core chunk
processing for the step really completed.   I think that&apos;s fine.. just pointing this out in case anyone is looking at this thinking &quot;why does this even matter?&quot;

Separate, related question.. there is no other global transaction going to be present in global tran mode, e.g. in the beginning or
end of the step, correct?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11245</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 20:16:21 +0000</bug_when>
    <thetext>I don&apos;t fully understand the question.  Seems to me the step status would be &quot;failed&quot;, not &quot;started&quot;.   And I don&apos;t see how this question relates to start limit.  Please clarify.  Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11248</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-05 21:10:18 +0000</bug_when>
    <thetext>(In reply to comment #1)
&gt; I don&apos;t fully understand the question.  Seems to me the step status would be
&gt; &quot;failed&quot;, not &quot;started&quot;.   And I don&apos;t see how this question relates to start
&gt; limit.  Please clarify.  Thanks

------------------------------------------------------------------------------

Sorry, my example obscured my point.    What I was really getting at was that the step status was NOT set to COMPLETED.  

And bringing up &apos;start-limit&apos; was probably unnecessary... I was just building the case that this was an interesting question and not hair-splitting.

------------------------------------------------------------------------------

There&apos;s a broader question/point here.    Are there any other local or global transactional scopes defined by this JSR (especially with respect to updating job/step status)? 

I think saying nothing further could be OK, since it implies undefined.    

This implies that say an @AfterStep/@AfterJob listener might not want to set autoCommit=false, since a particular container impl might run this portion of the app in a global tran.

So I just wanted to get in synch on this issue...

Thanks,
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11491</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 21:42:48 +0000</bug_when>
    <thetext>I&apos;m going to pile on to my earlier comments and ask more simply:

For a global tran chunk step, should open/close be performed in a global tran as well?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12089</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:36:57 +0000</bug_when>
    <thetext>open/close (on EE) run in a global tran - this is clear in section 8 of proposed final draft v1</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4125</bug_id>
          
          <creation_ts>2012-09-13 22:10:00 +0000</creation_ts>
          <short_desc>Do @AfterJob and @AfterStep run after job, step batch status / exit status have been hardened/persisted?</short_desc>
          <delta_ts>2013-01-16 23:07:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11091</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-13 22:10:13 +0000</bug_when>
    <thetext>The question is what opportunity to @AfterJob and @AfterStep have to influence the job/step (respectively) batch and execution status.

One approach that seems simple to me would be to say that the batch status should be fixed/persisted by this point... but there is still an opportunity for the respective listener artifact to change the execution status.

Not sure if there are any gaps with that approach...

One implication is that if the @AfterStep somehow throws an unchecked exception it wouldn&apos;t change the step batch status which had already, say, reached COMPLETED state.

And it doesn&apos;t seem to change anything with respect to the defaulting of exit status to batch status..</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11176</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-28 14:22:09 +0000</bug_when>
    <thetext>Just re-reading section 5.5, 

&quot; The batch and exit status of the job is set as follows:

1.	it is initially the same as the batch and exit status of the last execution element (step, flow, split) to  run
2.	batch and exit status can be overridden by a decision element 
3.	batch and exit status for the job can be overridden by a job listener as the job ends.  This overrides all else. &quot;

------------------------------------------------------------------------------

So this suggests a different rule than my interpretation.

The JobContext doesn&apos;t have an API to set the batch status, only the exit status, but if I read into this language it would seem that the batch status is not hardened in @AfterJob.   If an unchecked exception is thrown, the batch status would end up as FAILED, and it is even theoretically if not actually possible that you could stop a job while the @AfterJob is running, leaving the job in a stopped state.   (On restart there might be no steps to run, but that&apos;s the behavior).

I think this could be elaborated on a bit, and also the language regarding step batch/exit status isn&apos;t quite so clear on this point.. but assuming we continue the pattern, it would work similarly.

-------------

There is one more subtlety here.

When exactly is the defaulting of exit status to batch status going to be visible in the JobContext for the other batch artifacts?

That is, if I do JobContext.getExitStatus() in a &lt;decision&gt;&apos;s decider, am I going to see this exit status defaulted to the batch status already?  Or does the defaulting only happen after all three elements of the spec&apos;d statements above have been &quot;executed&quot;?

This matters if @AfterJob is supposed to be called even for stopped, failed jobs, which I&apos;m realizing is a separate question (will open up a new issue).

And there&apos;s an analogous question for step, etc., I&apos;m pretty sure.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11251</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:30:04 +0000</bug_when>
    <thetext>Spec clarifications needed:

1) Application code can set exit status, not batch status.  Batch status is set only by the batch runtime.  So section 5.5 needs to be updated.

2) As for when status changes and is visible. I would suggest the following:

2.1) JobContext - this is job level batch and exit status.  I would suggest batch status in the context is updated as it changes during the running of the job - e.g. STARTED-&gt;FAILED.  Set job level exit status to batch status after the last application artifact has been invoked if and only if exit status is still not set.  

2.2) StepContext - same idea as JobContext.  Set exit status to batch status after last step-level application artifact has been invoked. 

Note: we need a value for user exit in the context objects before it is set.  I suggest UNSET</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4135</bug_id>
          
          <creation_ts>2012-09-20 15:22:00 +0000</creation_ts>
          <short_desc>The JobOperator interface in the RI is different than what&apos;s listed in the specification document.</short_desc>
          <delta_ts>2013-01-16 23:03:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jfullam</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11117</commentid>
    <comment_count>0</comment_count>
    <who name="">jfullam</who>
    <bug_when>2012-09-20 15:22:06 +0000</bug_when>
    <thetext>For example:

The specification shows the following methods in the JobOperator interface:

JobInstance getJobInstance(long instanceId)
List&lt;Long&gt; getJobInstanceIds(String jobName, int start, int count)
StepExecution getStepExecution(long jobExecutionId, long stepExecutionId);

And these are not in the RI version.

long registerJobEndCallback(JobEndCallback callback) 

is in the RI and not in the Document.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11220</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:18:09 +0000</bug_when>
    <thetext>The RI presently lags behind the spec while we are developing the spec and the RI.  This will be improved over time.   By the time we deliver the final approval draft,  the RI and spec will agree completely.  Until then,  the latest spec draft is the authority.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12056</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:26:50 +0000</bug_when>
    <thetext>The RI will lag behind the spec until final approval ballot (FAB).  For FAB to start,  spec, RI and TCK must all be available and in synch.  FAB will begin tentatively Feb 12th, 2013.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4136</bug_id>
          
          <creation_ts>2012-09-20 15:26:00 +0000</creation_ts>
          <short_desc>The RI use of batch.xml is not consistent with the specification document</short_desc>
          <delta_ts>2013-01-16 23:04:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jfullam</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11118</commentid>
    <comment_count>0</comment_count>
    <who name="">jfullam</who>
    <bug_when>2012-09-20 15:26:20 +0000</bug_when>
    <thetext>The document states that batch.xml is to be used for two purposes:
1. to specify the optional batch artifact factory (see section 6.7)
2. artifact factoryartifact factoryto specify the optional transaction management SPI (see section 6.8.2)

The RI is not using it for either purpose, but rather to list the batch artifact id and implementation combinations.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11226</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:54:23 +0000</bug_when>
    <thetext>Right - the RI lags behind the spec drafts.  They will get tighter with each draft.  They will be 100% in agreement by final approval draft.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12062</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:35:53 +0000</bug_when>
    <thetext>correction:  RI and spec will be 100% sync&apos;d when final approval ballot begins.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4137</bug_id>
          
          <creation_ts>2012-09-20 15:29:00 +0000</creation_ts>
          <short_desc>In the RI, the applyTo attribute in the chunk properties doesn&apos;t work as expected</short_desc>
          <delta_ts>2013-01-16 18:39:54 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jfullam</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11119</commentid>
    <comment_count>0</comment_count>
    <who name="">jfullam</who>
    <bug_when>2012-09-20 15:29:08 +0000</bug_when>
    <thetext>When applyTo property is used, the RI actually applies the property to all artifact types within the chunk type step (reader, writer, and processor).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11232</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:31:32 +0000</bug_when>
    <thetext>This is an RI/spec sychronization issue.  The applyTo attribute was removed in the early draft review copy of the spec.  #{&lt;artifact-name&gt;[&apos;&lt;property-name&gt;&apos;]} (section 5.2.1.1) is the replacement fo applyTo.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11272</commentid>
    <comment_count>2</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-09 14:11:52 +0000</bug_when>
    <thetext>The #{&lt;artifact-name&gt;[&apos;&lt;property-name&gt;&apos;]} syntax seems to imply that the source of the property is from &lt;artifact-name&gt; instead of the target of the property injection. 

It seems to be more natural and readable to express the target of a property injection through an XML attribute instead of through an expression language. 
If the property target is part of the expression language we will have to parse the EL twice or store the target separately as a hidden attribute of the property after the initial parsing only to retrieve that information again later; so why not just separate it up front and make it a visible attribute?

In section 5.8.1 of the spec there is an example similar to the one below. There the target is the artifact type instead of the artifact name. I don&apos;t really have much of preference either way, but I believe the general convention is to target a property to a bean/artifact id.

&lt;chunk reader=&quot;MyReader&quot; writer=&quot;MyWriter&gt;
    &lt;properties merge=&quot;true&quot;&gt;
        &lt;property name=&quot;globalFile&quot; value=&quot;/tmp/golbal.txt&quot; /&gt;
        &lt;property name=&quot;infile&quot; value=&quot;/tmp/input.txt&quot; target=&quot;reader,writer&quot;/&gt;
        &lt;property name=&quot;outfile&quot; value=&quot;/tmp/output.txt&quot; target=&quot;writer&quot;/&gt;
    &lt;/properties&gt;
&lt;/chunk&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12071</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:06:10 +0000</bug_when>
    <thetext>applyTo has been dropped from the spec</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4138</bug_id>
          
          <creation_ts>2012-09-20 15:47:00 +0000</creation_ts>
          <short_desc>Processor shouldn&apos;t be a required attribute to a chunk type step</short_desc>
          <delta_ts>2013-01-16 23:09:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jfullam</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>chrisschaefer</cc>
    
    <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11120</commentid>
    <comment_count>0</comment_count>
    <who name="">jfullam</who>
    <bug_when>2012-09-20 15:47:07 +0000</bug_when>
    <thetext>There are many batch jobs that only require readers and writers.  The specification document and RI make the processor required.  While creating sample jobs using the RI, I encountered the need to create a &quot;dummy processor&quot; just to fulfill this requirement.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11256</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:41:07 +0000</bug_when>
    <thetext>sure, processor can be optional</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11513</commentid>
    <comment_count>2</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 17:29:31 +0000</bug_when>
    <thetext>+1 on making it optional</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12099</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:32:28 +0000</bug_when>
    <thetext>processor is now optional</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4139</bug_id>
          
          <creation_ts>2012-09-20 15:51:00 +0000</creation_ts>
          <short_desc>It is not possible to provide my own implementation of BatchArtifactFactory when using the RI</short_desc>
          <delta_ts>2013-01-16 20:55:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>jfullam</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11121</commentid>
    <comment_count>0</comment_count>
    <who name="">jfullam</who>
    <bug_when>2012-09-20 15:51:06 +0000</bug_when>
    <thetext>The RI implementation of BatchArtifactFactory (along with that of other services) is hardcoded in a &quot;ServicesManager&quot; class.  The specification document suggests another implementation can be provided.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11224</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:52:27 +0000</bug_when>
    <thetext>It will be possible to supply your own batch artifact loader as soon as we get the RI closer to the spec,  which is part of an on-going effort.  The RI and spec will not agree 100% until the finall approval draft is submitted.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12061</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:34:33 +0000</bug_when>
    <thetext>the SPI has been dropped</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4148</bug_id>
          
          <creation_ts>2012-09-26 14:44:00 +0000</creation_ts>
          <short_desc>Interaction between retryable-exception-classes, no-rollback-exception-classes, and skippable-exception-classes</short_desc>
          <delta_ts>2013-01-16 23:05:34 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11158</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 14:44:46 +0000</bug_when>
    <thetext>There could be some confusion as to how configuration of retryable-exception-classes interacts with configuration of no-rollback-exception-classes, and skippable-exception-classes.

------------------------------------------------------------------------------

First, w.r.t. the interaction between retryable-exception-classes and no-rollback-exception-classes.    

I imagine you intended these to be two peer configurations on the chunk.  

I don&apos;t think you expect a user to configure no-rollback-exception-classes ONLY when having first defined the same exception filter on an earlier retryable-exception-classes.

The outline organization slightly confuses this.. You have:

5.2.1.2	Chunk Exception Handling

5.2.1.2.1	Skipping Exceptions 
5.2.1.2.2	Retrying Exceptions
5.2.1.3	Controlling Rollback During Retry

Assuming I&apos;m correct I think it would be clearer to have:

5.2.1.2	Chunk Exception Handling

5.2.1.2.1	Skipping Exceptions 
5.2.1.2.2	Retrying Exceptions - Rollback
5.2.1.2.3	Retrying Exceptions - No Rollback

Maybe from a conceptual level your organization flows better but I think it&apos;s more helpful to try to align the doc organization with the JSL organization in a case like this.

As a peer section the new Section 5.2.1.2.3 should clarify that:

1) The retry listener is called (if present)
2) The current chunk is reprocessed with buffer-size=0, but with no rollback
(It&apos;s not crystal clear that this is supposed to happen in the no-rollback case).

Possibly a better name would be: 

retryable-no-rollback-exception-classes   or maybe
retryable-in-tran-exception-classes

but I wouldn&apos;t say that&apos;s essential.
------------------------------------------------------------------------------

There is a second issue regarding the interaction between all three: 
retryable-exception-classes, no-rollback-exception-classes, and skippable-exception-classes.

What happens if an exception instance matches more than one?   You should probably just state the order, and that a match to one of the &quot;filters&quot; i.e. include/exclude settings implies that the remaining filters are completely ignored.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11160</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 15:28:04 +0000</bug_when>
    <thetext>I see I missed a key point here.. the no-rollback-exception is caught and then the same read, process, or write is immediately performed again.   Whereas for retryable exceptions the entire chunk is reprocessed, starting of course with a new read.

I still think the reorganization I mentioned would be helpful though.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11168</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 21:13:44 +0000</bug_when>
    <thetext>Sorry but I keep thinking of more comments...

In saying for &lt;retryable-exception-classes&gt; we should &quot;re-process the current chunk with a buffer-size of 0&quot; what do you mean by the &quot;current chunk&quot;?

Do you mean the items handled since the last write or since the last checkpoint?  

Based on the association with the tran it would seem you mean &quot;last checkpoint&quot;, but in the terminology sections 4.7 &amp; 4.8 you seem to use the word &quot;chunk&quot; to mean the set of items that will constitute a single buffer write.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11250</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:14:28 +0000</bug_when>
    <thetext>I&apos;ll consider the section reorg you propose.  I use chunk and checkpoint somewhat interchangeably.  I&apos;ll see how I can clarify things as I do the next rev.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12092</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:17:26 +0000</bug_when>
    <thetext>The spec has been updated to reflect that a chunk is the number of items written in a single global tran.  There is one write per chunk (buffer-items=true) or one write per item (buffer-items=false).</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4149</bug_id>
          
          <creation_ts>2012-09-26 15:07:00 +0000</creation_ts>
          <short_desc>XSD inconsistencies</short_desc>
          <delta_ts>2013-01-16 18:30:07 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>Macintosh</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11159</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-26 15:07:00 +0000</bug_when>
    <thetext>With the agreement that the XSD will be included as part of the specification, there are a number of inconsistencies between it and the spec as it is currently defined.  The list of issues below (while I&apos;m sure not exhaustive) was compiled against the XSD provided on 9/25/2012:

- Property is incorrect
    - target missing
    - applyTo should not be there
    - applyToPartition should not be there
- Properties is incorrect
    - Missing partition
- Error handling is missing
    - Skipping exceptions (4.2.1.2.1)
    - Retryable exceptions (4.2.1.2.2)
    - Rollback exceptions (4.2.1.3)
- Partition is incorrect
    - threads does not belong.
- Flow is incorrect
    - does not allow a nested partition element (although, is this even needed?)
- Partition Mapper is missing
- Partition Reducer is missing
- Logical Transaction verbage still exists.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11169</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-27 14:14:59 +0000</bug_when>
    <thetext>Michael, thanks for making those comments as those changes all were needed to the RI working copy of the XSD I shared.

One exception.. I didn&apos;t follow your comment about the flow not being able to support the nested partition... The flow already can contain a child step, and the partitioned aspect is configured with a &lt;partition&gt; child of &lt;step&gt;, right?

That said, the spec does in section 5.2.6 suggest that &lt;partition&gt; follow &lt;chunk&gt;/&lt;batchlet&gt;, unlike the existing RI XSD, so that&apos;s still something to clear up.

I have a separate bug (question) open (4148) about the no-rollback vs. retryable... so we haven&apos;t updated that part yet, but I&apos;ll attach the merge of the changes we made so far.

Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11171</commentid>
    <comment_count>2</comment_count>
      <attachid>63</attachid>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-27 14:19:18 +0000</bug_when>
    <thetext>Created attachment 63
Working copy of RI XSD</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12051</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:19:37 +0000</bug_when>
    <thetext>Corrected XSD has been updatedin proposed final draft.</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>63</attachid>
            <date>2012-09-27 14:19:00 +0000</date>
            <delta_ts>2012-09-27 14:19:18 +0000</delta_ts>
            <desc>Working copy of RI XSD</desc>
            <filename>jobXML.xsd</filename>
            <type>text/plain</type>
            <size>11678</size>
            <attacher>ScottKurz</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>4150</bug_id>
          
          <creation_ts>2012-09-26 15:41:00 +0000</creation_ts>
          <short_desc>Difference between @OnRetryReadException and @OnRetryReadItem</short_desc>
          <delta_ts>2013-01-16 23:06:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11161</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 15:41:42 +0000</bug_when>
    <thetext>Why are there two methods here?  I&apos;m not following...

Clearly the first is supposed to be called before the second, but you seem to be trying to be saying something about the tran scope.

For the latter, we say, 

&quot;If the exception is a non-rollback  exception, this method receives control in the same transaction scope as the item reader.&quot;      

So you mean the same tran scope as the original item reader&apos;s read, right?  Even for a retryable exception with rollback, of course it&apos;s going to be the same tran as the retried read.

Is one key point that for a retryable exception with rollback, the @OnRetryReadException only gets called once, but the @OnRetryReadItem gets called once for each item as we retry the whole chunk, one record at a time???</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11167</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 20:48:07 +0000</bug_when>
    <thetext>Another couple follow-up questions:  

Does calling of @OnRetryReadItem happen instead of or in addition to @BeforeRead?   (Since @AfterRead doesn&apos;t have a retry analogue I&apos;m guessing
it happens in addition to @BeforeRead... probably before @BeforeRead).

What about @OnReadError?  Does that get called before any skip or retry processing (or only if it&apos;s NOT skipped or retried?)  Before @OnRetryReadException gets called then?

One more point which maybe ideally would be listed as a separate issue but you might prefer to deal with it with these others.

We have:

@OnReadError void &lt;method-name&gt; (Exception ex) throws Exception

Since Java has different meanings for Error vs. Exception and since we have specific exception-handling behavior.. it might be better to name this:

@OnReadException

Or.. if you really intend any Throwable to result in a call maybe:
@OnReadError void &lt;method-name&gt; (Throwable t) throws Throwable
but I think only handling Exception(s) is better.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11170</commentid>
    <comment_count>2</comment_count>
      <attachid>62</attachid>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-27 14:15:43 +0000</bug_when>
    <thetext>Created attachment 62
Working copy of RI XSD</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11244</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 20:12:36 +0000</bug_when>
    <thetext>This is a prime example of where a flow diagram would help.  I will try to improve the spec.  Here&apos;s the short answer:

1) @OnRetryReadException is invoked by the container immediately after the item reader throws a retryable exception.  This is always the same transaction scope as the one in which the item reader was running when the exception occurred. 

2) The batch container rolls back the current transaction and starts new scope.

3) @OnRetryReadItem is invoked in new transaction scope. 

Note: that step #2 can be skipped by specifying the retryable exception is also a no-rollback-exception.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12087</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:34:43 +0000</bug_when>
    <thetext>onRetryReadException was kept;  onRetryReadItem was removed</thetext>
  </long_desc>
      
          <attachment
              isobsolete="0"
              ispatch="0"
              isprivate="0"
          >
            <attachid>62</attachid>
            <date>2012-09-27 14:15:00 +0000</date>
            <delta_ts>2012-09-27 14:15:43 +0000</delta_ts>
            <desc>Working copy of RI XSD</desc>
            <filename>jobXML.xsd</filename>
            <type>text/plain</type>
            <size>11678</size>
            <attacher>ScottKurz</attacher>
            

          </attachment>
      

    </bug>
    <bug>
          <bug_id>4151</bug_id>
          
          <creation_ts>2012-09-26 15:48:00 +0000</creation_ts>
          <short_desc>spec questions on skippable exceptions:  write, runtime exceptions, exclude</short_desc>
          <delta_ts>2013-01-16 23:06:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11162</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-26 15:48:02 +0000</bug_when>
    <thetext>Some questions on skippable exceptions (which basically apply to retryable, no-rollback exceptions too):

1) See my email to the issues mailing list w/ Subject 
&quot;Interaction of SkipListener and chunked writes&quot;

2) The language of the spec currently seems to allow for subjecting runtime exceptions to the skip (and retry) processing.    This could get tricky... if the runtime exception is coming from the batch container, then it might cause some complications if that can be caught and &quot;skipped&quot;.    Could a runtime even end up in an inconsistent state somehow?

It seems one option would be to flat out disallow this in the spec wording (even though we can&apos;t easily express this in the method signature of read/write/process where we say &quot;throws Exception&quot;).  OTOH, what if there is an API that throws a predictable runtime exception that the JSR352 developer would like to skip... it would be a bit odd to ask them to catch a RuntimeException just to throw a checked exception.     

I think the current language is fine, just wanted to make sure this issue was considered.

3) This one almost doesn&apos;t need to be asked:

If I have just an &quot;exclude&quot;.. I&apos;m not going to match anything, right?   We basically start with an implicit &lt;exclude class=&quot;*&quot;/&gt;   (not that using a wildcard here is legal), so until you &lt;include&gt; something, &lt;exclude&gt; has no further affect.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11247</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 20:40:13 +0000</bug_when>
    <thetext>I think there are no restrictions on which exceptions can be skipped or retried.  Even if they originated in the batch runtime.  Afterall, there is nothing stopping the application catching any and every exception and preventing the batch runtime from seeing those exceptions again.  

Yes, exclude qualifies include.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4155</bug_id>
          
          <creation_ts>2012-09-28 14:23:00 +0000</creation_ts>
          <short_desc>Do @AfterJob/@AfterStep etc. run for failed/stopped jobs, steps, etc. (on best-effort basis)?</short_desc>
          <delta_ts>2013-01-16 23:06:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11177</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-28 14:23:38 +0000</bug_when>
    <thetext>Or do they only run for non-stopped, non-failed jobs/steps/etc.?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11216</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 16:23:15 +0000</bug_when>
    <thetext>From Wayne on issues mailing list:

I think someone responded to this but my vote is only run after successful
job or step.  An exception would take a different flow and they would not
get invoked. 

Wayne Lund</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11239</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:20:17 +0000</bug_when>
    <thetext>There should be a reliable way for user code to receive control at start/end of job and start/end of step whether or not the job or step fails.  In both cases, the batch runtime should be able to catch the error and pass control to an end of step and/or end of job method.  If the batch runtime can&apos;t do this for a particular error, it is a bug in the batch runtime.  Now having said that, we need to identify how the end of job/end of step user code can distinguish between normal and failure conditions. We have two choices:

1) document that @AfterJob/@AfterStep can access @BatchContext (JobContext of StepContext) to examine the batch and exit status values.

2) introduce new method annotations for error conditions - e.g. @AfterJobError, @AfterStepError.  

I prefer option #1.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11764</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 20:31:41 +0000</bug_when>
    <thetext>+1 for option 1.  As a point of reference, bot the StepExecutionListener.afterStep and JobExecutionListener.afterJob are called regardless of if the step or job were successfully completed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4156</bug_id>
          
          <creation_ts>2012-09-28 14:30:00 +0000</creation_ts>
          <short_desc>what does buffer-size=0 wording mean?</short_desc>
          <delta_ts>2013-01-16 23:08:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>kmukher</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11178</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-28 14:30:25 +0000</bug_when>
    <thetext>Already sent this to &apos;issues&apos; list..

I&apos;m calling this severity=trivial...  but since we don&apos;t have a whole lot of educational language in the spec (in contrast to purely functional/declarative)... it might be nice to be clearer here (unless it&apos;s just me who doesn&apos;t get this):

Under &quot;buffer-size&quot; it says: 
  A buffer size of 0 is appropriate for transactional resources - e.g. a JMS reader.  
Not trying to nit pick... I&apos;m just trying to understand what we&apos;re trying to say here..

It sounds like you&apos;re saying that there&apos;s no way to rollback the read?        So... how is buffering vs. not buffering the writes making this situation any better?

Aren&apos;t you just as unable to rollback the one message that you&apos;ve read vs. multiple messages?

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11253</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:39:01 +0000</bug_when>
    <thetext>buffer-size=0 means do not buffer reads.  Buffering reads is not necessary for transactional readers, such as JMS.  I will improve the description in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11708</commentid>
    <comment_count>2</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-28 21:52:27 +0000</bug_when>
    <thetext>What is the difference between buffer-size=0 and 1?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12096</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:23:05 +0000</bug_when>
    <thetext>buffer-size was removed</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4157</bug_id>
          
          <creation_ts>2012-09-28 14:33:00 +0000</creation_ts>
          <short_desc>CDI language should be removed from spec</short_desc>
          <delta_ts>2013-01-16 23:03:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11179</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 14:33:59 +0000</bug_when>
    <thetext>The spec should not be CDI specific and all language specifying that should be removed (spec section 7.7 for example).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11230</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:24:10 +0000</bug_when>
    <thetext>Yes, references to CDI will be removed.  However, use of @Named will remain. The spec will say that @Named is required to provide the batch artifact loader SPI in a consistent way to associate JSL ref-id with implementation names.  How that mapping is achieved is up to the batch artifact loader implementation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12065</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:40:47 +0000</bug_when>
    <thetext>all reference to CDI has been removed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4158</bug_id>
          
          <creation_ts>2012-09-28 14:37:00 +0000</creation_ts>
          <short_desc>Job Repository not clearly defined in the spec</short_desc>
          <delta_ts>2013-01-16 23:04:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mk111283</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11180</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 14:37:16 +0000</bug_when>
    <thetext>The spec defines that there should be a repository, however outside of this provides no further guidance on it&apos;s purpose.  To be thorough, should we include a more descriptive explanation of what functionality the repository is intended to facilitate (restartability, metrics, etc)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11237</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:03:46 +0000</bug_when>
    <thetext>I agree further explanation is required.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11748</commentid>
    <comment_count>2</comment_count>
    <who name="">mk111283</who>
    <bug_when>2012-12-03 01:44:46 +0000</bug_when>
    <thetext>Also, Section 4.4 of the sepc says:

&quot;A job repository holds information about jobs currently running and jobs that have run in the past. The JobOperator interface provides access to this repository. The repository contains job instances, job executions, and step executions.&quot;

The spec must mention when information about jobs that have run in the past are kept. At the minimum it must say one of the following:

a) Info / details about jobs (including the details about the jobs that have run in the past) created by a JavaEE application are removed when the JavaEE application is un-deployed

OR

b)  Info / details about jobs (including the details about the jobs that have run in the past) created by a JavaEE application are retained even after the JavaEE application is un-deployed. The duration of how long these data are retained is unspecified</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11749</commentid>
    <comment_count>3</comment_count>
    <who name="">mk111283</who>
    <bug_when>2012-12-03 01:46:09 +0000</bug_when>
    <thetext>Previous comment was posted by Mahesh.Kannan@Oracle.Com</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12077</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:13:19 +0000</bug_when>
    <thetext>The spec has been updated to state what the job repository holds and further states the implementation of the job repository is an implementer decision.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4159</bug_id>
          
          <creation_ts>2012-09-28 14:37:00 +0000</creation_ts>
          <short_desc>Definition needed for &quot;item-time&quot; checkpoint policy (see email to issues list)</short_desc>
          <delta_ts>2013-01-16 23:04:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11181</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-09-28 14:37:35 +0000</bug_when>
    <thetext>Copying the email I sent to the &apos;issues&apos; list:
(the earlier formatting might have been easier to read)
-------------------------------------------------

Chris,

Not sure how you envisioned the JSL looking for the &quot;item-time&quot; checkpoint policy given that you said it is a &quot;built-in custom&quot; policy.

I could imagine it implemented as another built-in with either:

1a.  
                               &lt;!-- overload existing attr using CSV of (item, time)--&gt;
		&lt;chunk ... commit-interval=&quot;10,5&quot; checkpoint-policy=&quot;item-time&quot;&gt;

                        spec needs to say: 
                                - that there is NO defaulting of either item or time
                                - strike out the statement  &quot;It must be valid XML integer. &quot;   (by the way this statement was only true after substitution but I think the point was clear)

1b.  
                               &lt;!-- new attributes --&gt;
		&lt;chunk ... checkpoint-policy=&quot;item-time&quot;item-size=&quot;10&quot; time-interval=&quot;5&quot;&gt;

                        spec needs to say: 
                                - maybe a bit more complicated statement of what &lt;chunk&gt; attribute combos are allowed (note the new attrs probably could be defaulted, )

Trying to read into your thoughts, I could imagine you were thinking something like:


2a.		&lt;chunk ... checkpoint-policy=&quot;custom&quot;&gt;
		&lt;checkpoint-algorithm ref=&quot;item-time&quot;&gt;
			&lt;properties&gt;
				&lt;property name=&quot;item&quot; value=&quot;10&quot; /&gt;
				&lt;property name=&quot;time&quot; value=&quot;5&quot; /&gt;
			&lt;/properties&gt;	
		&lt;/checkpoint-algorithm&gt;

or even:

2b.		&lt;chunk ... checkpoint-policy=&quot;custom&quot;&gt;
		&lt;checkpoint-algorithm&gt;     
			&lt;properties&gt;
				&lt;property name=&quot;item&quot; value=&quot;10&quot; /&gt;   &lt;!-- Could default --&gt;
				&lt;property name=&quot;time&quot; value=&quot;5&quot; /&gt;    &lt;!-- Could default --&gt;
			&lt;/properties&gt;	
		&lt;/checkpoint-algorithm&gt;
or:

2c.                         &lt;chunk ... checkpoint-policy=&quot;custom&quot;&gt;
		    &lt;checkpoint-algorithm item-time=&quot;true&quot;&gt;     ... use either attrs like in 1b. or child elements like in 2b.
------------------------------------------------------------------------------

I don&apos;t like 2a)  since it seems to pollute the batch artifact namespace...     

I guess 2b. or 2c. would work... we don&apos;t have a need to assign any other significance to &quot;custom&quot; policy minus a @ref...   The 2c. option makes it even
more clear we are omitting @ref in order to do item-time.

Thanks,</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11241</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 19:31:09 +0000</bug_when>
    <thetext>item-time will be removed from the spec.  I recommend we implement it in the RI/TCK as the way to test checkpoint-algorithm.  The way to define it is style &quot;2a&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12084</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:27:54 +0000</bug_when>
    <thetext>item-time checkpoint policy has been removed</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4160</bug_id>
          
          <creation_ts>2012-09-28 14:58:00 +0000</creation_ts>
          <short_desc>checkpoint-policy configuration needs clarification (5.2.1)</short_desc>
          <delta_ts>2013-01-16 18:45:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11182</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 14:58:48 +0000</bug_when>
    <thetext>* why does this define a type of policy and not the policy itself?
* If it is to define the type of policy, how are the other attributes configured (where is time configured for example?)?
* Why the separate commit interval and chunk size?  Aren&apos;t they synonymous?
* buffer-size is in the table but buffer-reads is in the description above...buffer-reads is what I thought we were going with but buffer-size is a different concept all together.
* skip-limit/retry-limit...is the default no limit or no skip/retry?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11228</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:16:29 +0000</bug_when>
    <thetext>* why does this define a type of policy and not the policy itself?

I don&apos;t understand the difference. I would say it does define the policy.  The policy implementation is built into the batch runtime.  If you want to supply another policy you specify &quot;custom&quot; and provide a checkpoint algorithm.


* If it is to define the type of policy, how are the other attributes
configured (where is time configured for example?)?

when checkpoint-policy=time, then the unit of measure on commit-interval specifies seconds.

checkpoint-policy=&quot;time&quot; commit-interval=&quot;10&quot; &lt;!- 10 seconds --&gt;


* Why the separate commit interval and chunk size?  Aren&apos;t they synonymous?
When checkpoint-policy=&quot;time&quot; then commit-interval specifies seconds, not items.

* buffer-size is in the table but buffer-reads is in the description
above...buffer-reads is what I thought we were going with but buffer-size is a
different concept all together.

I messed up.  But it&apos;s buffer-size we&apos;re going with.  We reasoned that chunk-size and commit-interval were indeed synonymous when checkpoint-policy=&quot;item&quot;, that we needed a way to specify how many items to buffer when checkpoint-policy=&quot;time&quot; and that buffer-size=0 and buffer-reads=false were synonymous, so we didn&apos;t need both.  So chunk-size and buffer-reads are gone, replaced by buffer-size.

I have to fix his section up.

* skip-limit/retry-limit...is the default no limit or no skip/retry?

Yes, default is no limit, no skip, no retry.   I will make sure this is clear in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12064</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:38:59 +0000</bug_when>
    <thetext>checkpoint specification has been completely revised in the proposed final draft.  I believe all issues with it are now resolved.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4161</bug_id>
          
          <creation_ts>2012-09-28 15:01:00 +0000</creation_ts>
          <short_desc>Clarification needed around retry (5.2.1.2.2)</short_desc>
          <delta_ts>2013-01-16 20:56:35 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11183</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:01:44 +0000</bug_when>
    <thetext>retry-exceptions (5.2.1.2.2) this section talks about retrying an operation...aren&apos;t we retrying an entire chunk?  The spec is unclear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11193</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:40:34 +0000</bug_when>
    <thetext>The retry semantics defined in the spec in general are a bit confusing.  A diagram outlining how they are expected to work may help clarify things.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11235</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:54:40 +0000</bug_when>
    <thetext>Both cases are supported:  retry an individual operation (no rollback) and retry the entire chunk (rollback).  I will try to make the spec more clear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12074</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:09:12 +0000</bug_when>
    <thetext>I updated this section and hope it is more clear.  You&apos;ll let me know if I&apos;m wrong :)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4162</bug_id>
          
          <creation_ts>2012-09-28 15:03:00 +0000</creation_ts>
          <short_desc>Clarification around property names</short_desc>
          <delta_ts>2013-01-16 20:58:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11184</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:03:50 +0000</bug_when>
    <thetext>The various properties elements specify that the name is a &quot;unique property name&quot;.  That is unique within the space of the parameters in general, correct?  aka, we do allow the reuse of a property value in multiple locations within a job.  It would be helpful if the spec clarified.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11221</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:18:55 +0000</bug_when>
    <thetext>Correct, the uniqueness is within scope.  I will update the spec  to clarify.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12054</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:23:49 +0000</bug_when>
    <thetext>proposed final draft was updated accordingly</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4163</bug_id>
          
          <creation_ts>2012-09-28 15:07:00 +0000</creation_ts>
          <short_desc>Partition numbering is 1 based</short_desc>
          <delta_ts>2013-01-16 23:08:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11185</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:07:35 +0000</bug_when>
    <thetext>This is a small nit-pick but almost all of Java uses a 0 based counter (the first element in an array, List, etc...the exception being JDBC).  Yet the partition numbering in section 5.2.6.2 states it&apos;s 1 based (begins with 1).  Do we want to be consistent with the majority of Java and make it 0 based?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11254</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:39:29 +0000</bug_when>
    <thetext>Yes, 0 based.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4164</bug_id>
          
          <creation_ts>2012-09-28 15:10:00 +0000</creation_ts>
          <short_desc>Clarifications with the Flow element (5.3)</short_desc>
          <delta_ts>2013-01-16 23:02:02 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11186</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:10:10 +0000</bug_when>
    <thetext>* Why can&apos;t a Flow contain a split?
* The spec is unclear on what an abstract flow can be used for (what can be included in it, what can be inherited, etc).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11233</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:43:48 +0000</bug_when>
    <thetext>* Why can&apos;t a Flow contain a split?

To reduce complexity.  Is this an important use case?

* The spec is unclear on what an abstract flow can be used for (what can be
included in it, what can be inherited, etc).

I would be happy to dispense with abstract flows.  If we have them, I suppose the use case is to supply a templated sequence of steps.  If we agree to keep abstract flows, I will try to improve this treatment in the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12070</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:05:25 +0000</bug_when>
    <thetext>flow no longer supports abstract</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4165</bug_id>
          
          <creation_ts>2012-09-28 15:18:00 +0000</creation_ts>
          <short_desc>Inheritance clarifications (5.8)</short_desc>
          <delta_ts>2013-01-16 23:08:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11187</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:18:49 +0000</bug_when>
    <thetext>* The spec allows for lists to be merged, yet guarantees order in other places (listeners for example are to be executed in the order they are configured, yet the list can be merged).  How does this work with inheritance?  Who executes first?  Spring Batch allows the ability to merge the lists but does not guarantee execution order.
* Are all aspects inheritable?  For example, if I configure a job that inherits from another job, do I inherit the steps in the parent job as well?  If so, how are they ordered?  Spring Batch does not bring the steps of a parent job into the child.
* 5.8.2 - Why does the parent id refer to the file name and not the id of the element?  Seems a bit odd and I would expect it to break down for things like steps...are we really going to define a new file for every step?  I would expect the parent id to be the id of the element itself.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11252</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:38:14 +0000</bug_when>
    <thetext>* The spec allows for lists to be merged, yet guarantees order in other places
(listeners for example are to be executed in the order they are configured, yet
the list can be merged).  How does this work with inheritance?  Who executes
first?  Spring Batch allows the ability to merge the lists but does not
guarantee execution order.

My thinking was:  parent first - think of it as appending the child listeners to the parent&apos;s list.  If you think this is an issue, I&apos;m willing to say no guarantee of execution order.  I don&apos;t think the rule is so important - just that we have one. 


* Are all aspects inheritable?  For example, if I configure a job that inherits
from another job, do I inherit the steps in the parent job as well?  If so, how
are they ordered?  Spring Batch does not bring the steps of a parent job into
the child.

What is the behavior of inheriting a job in Spring Batch?  If not the steps, seems like it&apos;s not very useful.


* 5.8.2 - Why does the parent id refer to the file name and not the id of the
element?  Seems a bit odd and I would expect it to break down for things like
steps...are we really going to define a new file for every step?  I would
expect the parent id to be the id of the element itself.

So we don&apos;t have to read all the XML in up front just to be ready in case there is inheritance. And to minimize the number of files that potentially have to be read.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11288</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 18:15:38 +0000</bug_when>
    <thetext>In the public draft review edition,  I have updated the inheritance specification to (I think) match Spring.  The change includes not inheriting job steps and no guarantees of order for lists.

Regarding what the parent= value means,  I think we need to back off and leave that as an implementation detail.  It&apos;s not part of the programming model.  It&apos;s not part of the JSL model.  So I think that&apos;s ok.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4166</bug_id>
          
          <creation_ts>2012-09-28 15:22:00 +0000</creation_ts>
          <short_desc>ItemReader annotation @Open shouldn&apos;t be required</short_desc>
          <delta_ts>2013-01-16 23:02:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>keilw</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11188</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:22:00 +0000</bug_when>
    <thetext>The @Open annotation on an ItemReader (6.1.1.1.1) is required.  This is not always needed and should be optional just like the @Close.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11225</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:53:01 +0000</bug_when>
    <thetext>I agree.  I will update the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4167</bug_id>
          
          <creation_ts>2012-09-28 15:30:00 +0000</creation_ts>
          <short_desc>@CheckpointInfo clarification</short_desc>
          <delta_ts>2013-01-16 23:03:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11189</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:30:02 +0000</bug_when>
    <thetext>@CheckpointInfo (6.1.1.1.4) requires the return of an Externalizable object.  I would expect this method to just update the appropriate context (Job, Step, Chunk, etc) and let the container address anything else.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11231</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:28:35 +0000</bug_when>
    <thetext>@CheckpointInfo should be used to return the data that the container should checkpoint for a given reader or writer.  This provides better encapsulation of the reader or writer function than storing it in the context.  

However, there is a persistent part of the step context, which gets stored each time a checkpoint it taken. 

If we make @CheckpointInfo optional, then the user has a choice.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12069</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:03:42 +0000</bug_when>
    <thetext>this was made optional on the abstract reader/writer classes</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4168</bug_id>
          
          <creation_ts>2012-09-28 15:31:00 +0000</creation_ts>
          <short_desc>@Stop on a batchlet shouldn&apos;t be required.</short_desc>
          <delta_ts>2013-01-16 23:03:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11190</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:31:29 +0000</bug_when>
    <thetext>The @Stop annotation (6.1.2.2), while a good idea in practice, probably should not be required.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11218</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:14:51 +0000</bug_when>
    <thetext>It should be required because without it there is little hope that a batchlet can be stopped.  This creates an operational concern.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12083</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:25:16 +0000</bug_when>
    <thetext>It is now optional on an abstract class.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4169</bug_id>
          
          <creation_ts>2012-09-28 15:36:00 +0000</creation_ts>
          <short_desc>CheckpointListener clarification</short_desc>
          <delta_ts>2013-01-16 23:04:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11191</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:36:01 +0000</bug_when>
    <thetext>The CheckpointListener in the spec sounds like the methods are to be executed around the act of Checkpointing itself, instead of around the chunk of items.  Spring Batch&apos;s ChunkListener&apos;s beforeChunk is executed prior to any items being processed and afterChunk is executed once all of them within the chunk have been completed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11223</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:51:13 +0000</bug_when>
    <thetext>I think the issue is only terminology. We have a blending of WebSphere and Spring wording.  WebSphere uses the term &quot;checkpoint&quot; not only to cannote the actual act of writing the checkpoint, but also extends the term to refer to the items processed since the last time a checkpoint was taken. Hence checkpoint = chunk.  

I will look to clarify the language in the next spec draft.  

I am planning a flow diagram, which will help.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11291</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 21:41:45 +0000</bug_when>
    <thetext>After further review, I realize there is a distinction between before/after chunk and before/after checkpoint.  

I revised the spec:

1) renamed CheckpointListener to ChunkListener
2) added beforeChunk/afterChunk method annotations
3) kept beforeCheckpoint/afterCheckpoint method annotations</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4170</bug_id>
          
          <creation_ts>2012-09-28 15:37:00 +0000</creation_ts>
          <short_desc>Parameter order of Listener API</short_desc>
          <delta_ts>2013-01-16 23:07:37 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11192</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:37:10 +0000</bug_when>
    <thetext>Minor thing...if we&apos;re going to use the listener API straight from Spring Batch, can we update the method parameters to match the order as well?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11255</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:39:58 +0000</bug_when>
    <thetext>yes</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11292</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 22:01:15 +0000</bug_when>
    <thetext>I take it back.  Sorry.   Spring Batch listener parameter order is not consistent.  E.g.


public interface ItemProcessListener&lt;T, S&gt; extends StepListener {
    void onProcessError(T item, Exception e);
}

public interface ItemWriteListener&lt;S&gt; extends StepListener {
    void onWriteError(Exception exception, List&lt;? extends S&gt; items);
}

public interface SkipListener&lt;T,S&gt; extends StepListener {
    void onSkipInProcess(T item, Throwable t);
    void onSkipInWrite(S item, Throwable t);
}

The difference is where the exception (or throwable) is positioned.  The spec will put the exception last, to match the majority of the Spring batch listeners.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4172</bug_id>
          
          <creation_ts>2012-09-28 15:51:00 +0000</creation_ts>
          <short_desc>Parallelization clarifications</short_desc>
          <delta_ts>2013-01-16 20:56:53 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11195</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:51:14 +0000</bug_when>
    <thetext>* Parallelization (6.5) - Is the role of the PartitionMapper really to calculate the NUMBER of partitions or the data that exists within each partition?  I thought it was the latter 
* @Begin (6.5.2.1)
    * remove sub-job verbiage.
    * How is the logical grouping denoted?  In otherwords, who calls the @Begin, etc and when?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11222</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 17:24:31 +0000</bug_when>
    <thetext>The role of the mapper is decide which items exist in each partition. It does this by assigning properties to each partition, which indirectly defines the number of partitions.  These properties communicate to the partition which items to process. Key ranges, line numbers, and file names are all examples of property values that might communicate data range for a given partition.


Sub-job verbiage will be removed from next version of spec.   @Begin, etc is invoked by the batch runtime.  I will add a flow diagram to the spec to spell this out.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12059</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:29:02 +0000</bug_when>
    <thetext>I didn&apos;t add a diagram,  but I did add a section that enumerate the sequence of events for partition execution.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4173</bug_id>
          
          <creation_ts>2012-09-28 15:59:00 +0000</creation_ts>
          <short_desc>Decider does not get context</short_desc>
          <delta_ts>2013-01-16 23:01:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11196</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 15:59:25 +0000</bug_when>
    <thetext>A decider element should be provided with at least the Job context.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11229</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:21:10 +0000</bug_when>
    <thetext>The approach for contexts is that they are injectable using the @BatchContext
field annotation.  So any batch artifact can have access to any context via:

@BatchContext JobContext _jobctxt;
@BatchContext StepContext _stepctxt;

etc.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12066</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:54:17 +0000</bug_when>
    <thetext>We added a context parameter to the decider interface.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4175</bug_id>
          
          <creation_ts>2012-09-28 16:04:00 +0000</creation_ts>
          <short_desc>JobOperator interface incorrectly cited</short_desc>
          <delta_ts>2013-01-16 23:09:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11198</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-09-28 16:04:55 +0000</bug_when>
    <thetext>Section 7.3 says to see the JobOperator interface in section 7.3.  It&apos;s in section 7.10.7.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11258</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 21:44:32 +0000</bug_when>
    <thetext>thanks - will fix in next rev.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12101</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:34:57 +0000</bug_when>
    <thetext>this is fixed</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4182</bug_id>
          
          <creation_ts>2012-10-03 19:06:00 +0000</creation_ts>
          <short_desc>The transient user data in a Job Context needs to be cloneable or serializable.</short_desc>
          <delta_ts>2013-01-16 23:02:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11213</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-03 19:06:14 +0000</bug_when>
    <thetext>When we invoke parallel steps in a job, the parent job&apos;s context is partially copied to the parallel steps; specifically the job properties and the transient user data. Since each thread has it&apos;s own copy of the job context the transient data in the context needs to be either cloneable or serializable so we are able to make a proper copy of it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11227</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:02:17 +0000</bug_when>
    <thetext>java.util.Properties is already cloneable/serializable.  I do not think transient data should be copied.  The transient data is intended to have strictly thread local behavior.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11263</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-08 19:58:01 +0000</bug_when>
    <thetext>If it&apos;s supposed to be thread local behavior then I wonder if we need to say more about the &quot;main&quot; thread.  Are step1 and step2 guaranteed to run on the same thread?   What if step1 is followed by split2 which is followed by step3, are steps 1 and 3 guaranteed to run on the same threads?   

I think it would be valid to leave this undefined if that is your intention, but just trying to get you to commit to it in writing if you are assuming there will be a single thread in these cases.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11264</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-08 20:38:14 +0000</bug_when>
    <thetext>Nope: there will be no requirement that a job&apos;s steps execute on the same thread. The transient area visibility is limited to a single step in a single job execution.  If the step is partitioned,  the visibility is limited to each partition. No sharing across threads;  between partitions;  or across job executions.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4183</bug_id>
          
          <creation_ts>2012-10-03 19:39:00 +0000</creation_ts>
          <short_desc>There is no way to access the parent job context at the end of a Split</short_desc>
          <delta_ts>2013-01-16 23:02:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11214</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-03 19:39:02 +0000</bug_when>
    <thetext>Analyzers, collectors, and Reducers are currently not applicable to the split construct so there is no way to coordinate between multiple threads within a split like we can in a partitioned step. In the case of a split we may want to have multiple steps run in parallel and then have some way to &quot;analyze&quot; the data as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11234</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-05 18:51:54 +0000</bug_when>
    <thetext>You are correct there is no way for application code to interpose on the batch status and exit status of the flows within a split. However, the split can pass control to a decider. The decider has visibility to the SplitContext.  If we store the results of each of the flows within the SplitContext,  then the Decider could make an informed decision.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12073</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:08:25 +0000</bug_when>
    <thetext>The spec was updated so the split context has a list of results from each flow in the split.  This way the decider can see all that happened in the split and make a decision accordingly.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4197</bug_id>
          
          <creation_ts>2012-10-10 16:20:00 +0000</creation_ts>
          <short_desc>issues with JobPath (Sec 7.5), should it be in the spec?</short_desc>
          <delta_ts>2013-01-16 23:09:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11281</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-10 16:20:31 +0000</bug_when>
    <thetext>First, isn&apos;t the only use case for JobPath the inheritance use case given that JobOperator.submit() requires the full JSL as a String (rather than a path/location)? 

...

My bigger issue is I&apos;m having a hard time understanding why the spec needs to prescribe where to find the JSL files.   

What if my JEE-based implementation wants to define its own construct for allowing certain JSL to serve as the implementation to other child JSL(s)?  Are you saying it must first look at this &quot;javax.jobpath&quot; mechanism?  

Or is this rule only for JSE implementations maybe?  

What piece of code/script/etc. am I allowing to remain common across implementations?

If we want to define a new batch packaging format, then we could certainly come up with rules for importing/exporting from these packages.   

But if we&apos;re not going in that direction, it seems it might be enough for this spec to define what the artifacts should look like, and not where in the filesystem they should be placed/deployed.

...

If it is kept in the spec maybe it needs to be something more like a classpath in case it is zipped up in a JAR along with (or separately from) other batch artifacts.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11284</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 16:47:48 +0000</bug_when>
    <thetext>This may be a case of possible implementation bleeding into spec.  I think you may be right that how the inheritance source is located need not be specified. We should not assume the way this needs to work in an SE environment vs a EE environment vs a future environment in which there is potentially an external batch scheduler is the same.

Let&apos;s try removing it from the spec and see how that holds up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12100</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:32:59 +0000</bug_when>
    <thetext>jobpath was removed.   META-INF/batch-jobs was added</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4198</bug_id>
          
          <creation_ts>2012-10-10 16:43:00 +0000</creation_ts>
          <short_desc>use of JobOperatorFactory SPI unclear</short_desc>
          <delta_ts>2013-01-16 23:07:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11283</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-10 16:43:23 +0000</bug_when>
    <thetext>Trying to understand your vision for Launcher leading to a @JobOperator injection.

In Sec. 7.8 you have:

&gt; In a Java SE environment,  the @JobOperator annotation is resolved in this class and in this class alone. If a batch artifact factory SPI is configured (see 6.7) a single call is made to the factory with a ref name of &quot;System.JobOperator&quot; to create the JobOperator instance.  The factory must return an instance of type javax.batch.spi.ArtifactFactory.  

Did you mean to end with:

&quot;The factory must return an instance of type javax.batch.spi.JobOperatorFactory&quot;?

If that&apos;s the case then is the flow?: 

1. user runs Launcher main with JobOperator client w/ @JobOperator (field?/setter?)

2. runtime impl calls BatchArtifactFactory SPI impl 
  baf.create(&quot;System.JobOperator&quot;)  // return JobOperatorFactory

3. runtime impl calls getInstance on returned JobOperatorFactory impl
   job.getInstance() 

4. runtime injects returned value into @JobOperator

------------------------------------------------------------------------------
 
Is that the correct interpretation?  Or had you envisioned something different?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11286</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 17:05:23 +0000</bug_when>
    <thetext>I think maybe we don&apos;t need this in the spec.  What we&apos;re trying to do is resolve @JobOperator in an SE environment.  Maybe this is only an implementation concern.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12088</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:35:31 +0000</bug_when>
    <thetext>the SPI has been dropped</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4199</bug_id>
          
          <creation_ts>2012-10-10 16:56:00 +0000</creation_ts>
          <short_desc>Use of batch.xml in JEE environment</short_desc>
          <delta_ts>2013-01-16 18:32:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11285</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-10 16:56:42 +0000</bug_when>
    <thetext>It seems like the use of a batch.xml, presumably packaged in an application JAR/WAR/etc., would not fit so well into something like a JEE environment. 

Take BatchArtifactFactory....

Does it really seem correct to force a JEE-based JSR352 implementation to allow an app to specify its own artifact loading scheme, overriding what is probably an already carefully constructed and non-trivial loading scheme in the managed environment?

I&apos;m not sure how much sense it makes for the transaction SPI either.

Would it be better to say there are two modes:  JEE, JSE (or managed/unmanaged maybe).   

Leave it undefined, i.e. implementation-specific, how the runtime decides which mode it is operating under.

But these SPIs would then only apply to JSE (unmanaged) mode.

As I&apos;m saying this I&apos;m realizing these thoughts must have come up in other JSR discussions if not this one.   If that&apos;s the case then I&apos;m curious how you thought this would fit into JEE.

Thanks
Scott</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11287</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-10 18:04:33 +0000</bug_when>
    <thetext>The idea behind these SPIs is:

- use of alternate DI technologies - CDI, Spring DI, OSGi Blueprint
- use of platform appropriate transaction manager:  JTA, CICS, JOTM, etc
- DI agnostic @JobOperator injection

I think I agree exposing this to the application developer directly via a mechanism like batch.xml is not the best idea.


I&apos;m thinking maybe the best approach is to eliminate the SPIs altogether and leave it to the implementer.   For transaction management, we can stipulate JTA is must be used.  

On the other hand,  maybe we should keep the SPIs, but expose them differently - outside the reach of the application developer.  Perhaps we simply specify the SPIs are implemented with an interface and  factory pattern.  An implementer could provide their own implementation of the factory ...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11547</commentid>
    <comment_count>2</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-11-14 23:24:21 +0000</bug_when>
    <thetext>I do not believe that JTA should be a must use for transaction.  I think local transactions are sufficient for single process, single resource batch scenarios, which covers a large number of batch cases. I&apos;m wondering if the JPA spec provides an approach we can leverage with providing configurations for JSE vs JEE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12053</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:22:39 +0000</bug_when>
    <thetext>The transaction manager SPI has been removed.  The choice of global vs local has been removed.  The final proposed draft states global transactions are used in JEE and local in SE.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4202</bug_id>
          
          <creation_ts>2012-10-11 15:52:00 +0000</creation_ts>
          <short_desc>transaction text should say resources get auto-enlisted</short_desc>
          <delta_ts>2013-01-16 23:07:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11296</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-10-11 15:52:54 +0000</bug_when>
    <thetext>Maybe everyone would assume this anyway, but... 
Should we have something like the EJB 2 spec says for CMT:

&quot;The Container automatically enlists all the resource managers
accessed by the business method with the transaction.&quot;

I did list this as trivial but it seems like it closes the minor possibility of misinterpretation.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11298</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-10-11 16:08:28 +0000</bug_when>
    <thetext>I think the batch spec must clearly identify where transaction scopes exist during the batch job lifecycle.  I do not think the batch spec should say anything about resource enlistment because resource enlistment is outside the scope of the batch spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11729</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-30 01:03:16 +0000</bug_when>
    <thetext>I think resource enlistment is critical in JEE since otherwise the programming model is potentially not standard (if you have to enlist yourself or with some other mechanism).

But I suppose you could take the perspective that if you&apos;re running in JEE you must be running in an EJB or servlet which already specifies that managed resources are enlisted in trans.

On the flip side..... transactions are tied to threads... and JobOperator will be spawning new threads... maybe it would be better to be clearer about enlistment.

On the other hand (flipping sides yet another time).... maybe this is more the domain of something like JSR 236 WorkManager thread.   

I think there&apos;s a strong case that it needs to be specified, I&apos;m just not proving that it&apos;s the batch spec that does it.. but then who does?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12095</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:22:21 +0000</bug_when>
    <thetext>the spec says when global trans are used.   pointing out that transactional resources get enlisted is unnecessary - that is well known.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4232</bug_id>
          
          <creation_ts>2012-10-23 14:18:00 +0000</creation_ts>
          <short_desc>Clarification for onRetryProcessItem and onRetryWriteItems methods</short_desc>
          <delta_ts>2013-01-16 23:08:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>dmbelina</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11360</commentid>
    <comment_count>0</comment_count>
    <who name="">dmbelina</who>
    <bug_when>2012-10-23 14:18:52 +0000</bug_when>
    <thetext>The onRetryProcessItem and onRetryWriteItems methods take an Item (or List of Items, for the write) and an Exception as arguments.   Is this Item (or List of Items) the current object being used as we attempt the retry? Or the original object that caused the exception?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12097</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:24:04 +0000</bug_when>
    <thetext>those methods were deleted, so this is no longer an issue.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4233</bug_id>
          
          <creation_ts>2012-10-23 15:23:00 +0000</creation_ts>
          <short_desc>Step level properties shouldn&apos;t be available through Job Context</short_desc>
          <delta_ts>2013-01-16 20:57:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11361</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-23 15:23:12 +0000</bug_when>
    <thetext>In section 5.1.2 it states, &quot;Step level properties are available through the Job Context runtime object.&quot; I believe this is just a typo and should be, &quot;Job level properties are available through the Job Context runtime object.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12068</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:01:18 +0000</bug_when>
    <thetext>I missed this in the proposed final draft :(   I just updated it and it will appear in proposed final draft v1.1</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4234</bug_id>
          
          <creation_ts>2012-10-23 15:53:00 +0000</creation_ts>
          <short_desc>Transitions within a split are not valid</short_desc>
          <delta_ts>2013-01-16 23:01:14 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11362</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-23 15:53:01 +0000</bug_when>
    <thetext>In section &apos;5.4 Split&apos; it states, &quot;The flows within a split may only transition among themselves; flows in a split may not transition to elements outside of the split.&quot; This may just be a cut and paste error from &apos;Flows&apos;

I believe all flows within a split run concurrently so there should be no order associated with the flows in a split and transitions within a split should not be valid.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12082</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:24:09 +0000</bug_when>
    <thetext>I missed this in the proposed final draft.  I just deleted this line:

&quot;The flows within a split may only transition among themselves; flows in a split may not transition to elements outside of the split.&quot;

this change will appear in the v1.1 interim version of the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4241</bug_id>
          
          <creation_ts>2012-10-26 19:05:00 +0000</creation_ts>
          <short_desc>Clarify when the Batch Container guarantees global transaction mode sematics</short_desc>
          <delta_ts>2013-01-16 23:01:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11375</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-10-26 19:05:17 +0000</bug_when>
    <thetext>In section 6.7.1 the spec states that the batch container will provide &quot;global transaction mode semantics if and only if the services of a JTA-compliant transaction manager are made available to the batch runtime through use of the Transaction Management SPI.&quot; However, the &quot;Otherwise the property is ignored,&quot; statement implies that the batch container will ignore the property if the given transaction manager is not JTA-compliant. 

Since there is no way for the batch container to verify if a transaction manager is JTA-compliant we should qualify the &quot;ignore&quot; statement with, &quot;If the given transaction manager does not implement the TransactionManagerSPI the property will be ignored.&quot; I believe this make it clear that you can still provide a transaction manager spi implementation that is not JTA-compliant that will be used but that the batch container will not guarantee global mode semantics in this case.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12060</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:30:31 +0000</bug_when>
    <thetext>The SPI is dropped.  The spec has been updated to clarify the use of global transactions.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4259</bug_id>
          
          <creation_ts>2012-11-06 22:58:00 +0000</creation_ts>
          <short_desc>chunk properties naming</short_desc>
          <delta_ts>2013-01-16 17:49:20 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11451</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-06 22:58:37 +0000</bug_when>
    <thetext>Instead of having a specific property naming pattern for chunk artifacts (&lt; artifact-name :property-name&gt;) why not just using a child element of the chunk element for each artifact (reader, processor, writer) ? I think it would be clearer and more consistent with the rest of the job xml specification.

Example:
&lt;chunk&gt;
   &lt;reader ref=MyReader&gt;
       &lt;properties&gt;
           &lt;property name=&quot;filename&quot; value=&quot;/tmp/infile.txt&quot; &gt;
       &lt;/properties&gt;
   &lt;/reader&gt;
   &lt;processor ref=MyProcessor/&gt;
   &lt;writer ref=MyWriter&gt;
       &lt;properties&gt;
           &lt;property name=&quot;filename&quot; value=&quot;/tmp/outfile.txt&quot; &gt;
       &lt;/properties&gt;
   &lt;/writer&gt;
&lt;/chunk&gt;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11608</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:17:37 +0000</bug_when>
    <thetext>Good idea. It solves the problem we&apos;ve been wrestling with concerning how to assign properties to each artifact:  reader, processor, writer.   Originally, we patterned off Spring Batch&apos;s chunk element, which uses elements to specify those  three artifacts.   But having separate elements works better here.  I think this is a good change.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4265</bug_id>
          
          <creation_ts>2012-11-09 19:01:00 +0000</creation_ts>
          <short_desc>Clarification of JobExecution</short_desc>
          <delta_ts>2013-01-16 16:15:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11468</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:01:49 +0000</bug_when>
    <thetext>In section 4.1.3, the spec discusses the concept of a JobExecution and the concepts of an execution being &quot;complete&quot;.  However, it does not discuss what should occur if the JobExecution that is &quot;complete&quot; is attempted to be restarted (Spring batch does not allow this behavior).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11562</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 19:49:35 +0000</bug_when>
    <thetext>The spec does not allow restart of a completed execution, either, but that fact is well hidden.  You see the evidence on the JobOperator.restart() method in that it throws JobInstanceAlreadyCompleteException 


Long restart(long instanceId, Properties jobParameters)
	throws JobInstanceAlreadyCompleteException,
	NoSuchJobExecutionException, NoSuchJobException,
	JobRestartException;


I added the following statement to 4.1.3: 

Note a completed JobExecution cannot be restarted.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4266</bug_id>
          
          <creation_ts>2012-11-09 19:09:00 +0000</creation_ts>
          <short_desc>Step&apos;s start-limit</short_desc>
          <delta_ts>2013-01-16 16:33:43 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11469</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:09:48 +0000</bug_when>
    <thetext>Section 5.2 of the spec identifies the start-limit attribute.  It states that this attribute indicates &quot;number of times this step may be restarted&quot; and defaults to 0 which means no limit.  If 0 means no limit, how are steps that cannot be restarted indicated?  In Spring Batch, this attribute is the number of executions (not restarts) allowed.  A step that can only be run once (not restarted) would have a start-limit=&quot;1&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11594</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:26:37 +0000</bug_when>
    <thetext>Agreed.  Spec updated accordingly.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4267</bug_id>
          
          <creation_ts>2012-11-09 19:19:00 +0000</creation_ts>
          <short_desc>checkpoint-alghrithm is not defined by the spec</short_desc>
          <delta_ts>2013-01-16 15:53:19 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11470</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:19:00 +0000</bug_when>
    <thetext>In section 5.2.1 of the spec, the checkpoint-policy element discusses that if the policy is &quot;custom&quot;, then the developer would specify a &quot;checkpoint-algorithm&quot; element, however that element is never defined in the spec.

As a side note, why not just have the string identified in the checkpoint-policy identify the algorithm itself (instead of a two step process)?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11590</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:48:42 +0000</bug_when>
    <thetext>The checkpoint algorithm element is defined in section 5.2.1.5 of the public draft. An element vs an attribute value is needed so there is a place to specify batch properties for the checkpoint algorithm.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4268</bug_id>
          
          <creation_ts>2012-11-09 19:20:00 +0000</creation_ts>
          <short_desc>commit-interval attribute unit</short_desc>
          <delta_ts>2013-01-16 17:25:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11471</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:20:18 +0000</bug_when>
    <thetext>Should commit-interval be in seconds or milliseconds?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11597</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:37:35 +0000</bug_when>
    <thetext>I think milliseconds is too fine-grained for batch execution. In most cases, I think seconds make more sense.  If a user wants milliseconds,  they can implement a custom checkpoint algorithm.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4269</bug_id>
          
          <creation_ts>2012-11-09 19:27:00 +0000</creation_ts>
          <short_desc>buffer-size should be a boolean</short_desc>
          <delta_ts>2013-01-16 15:19:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11472</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:27:24 +0000</bug_when>
    <thetext>In section 5.2.1 of the spec, buffer-size is an integer used to indicate how many items to buffer prior to writing.  However, this buffer size should be a function of the chunk size and not independent of that.  Otherwise, you can end up with a scenario where the chunk size is 10 but a buffer size of 15.  How is that handled?

This attribute should be a boolean indicating if the input should be buffered at all or not and let the implementation handle how large the buffer is.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11559</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 17:03:45 +0000</bug_when>
    <thetext>I do not agree. The buffer-size is an integer on purpose so you can buffer and commit with different criteria - especially for the following scenario:

1) checkpoint-policy=time
2) commit-interval=30
3) buffer-size=100

That means commit every 30 seconds, buffer 100 items before writing.  

The case you are concerned with is 

1) checkpoint-policy=time
2) commit-interval=10
3) buffer-size=15

That means commit every 10 items,  buffer 15 items before writing.  The runtime will invoke itemWriter when the commit-interval is reached,  regardless of the buffer-size specification.  

I updated the documentation of buffer-size to include this statement:

When the checkpoint policy commit-interval is reached, the buffer is emptied to the ItemWriter immediately before the checkpoint is committed whether or not the buffer is full.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11618</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-19 17:18:55 +0000</bug_when>
    <thetext>I&apos;m a bit confused.  Are checkpoints not tied to commits?  The configuration you propose here:

1) checkpoint-policy=time
2) commit-interval=30
3) buffer-size=100

Are you saying that you could have multiple buffer flushes per commit (something that is not allowed in Spring Batch) if you process, say, 200 items in that 30 second interval?  This adds a level of complexity that I&apos;m not seeing the benefit of.  What is the use case where this is needed?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11713</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 19:55:49 +0000</bug_when>
    <thetext>Yes, checkpoints are tied to commits insofar as when a checkpoint is taken, a commit occurs.

The reason for setting a buffer-size is so time-based checkpoint intervals don&apos;t get OOM.  Time-based checkpoints are helpful if you&apos;re trying to avoid transaction timeouts.   

BTW, default buffer-size is commit-interval when policy is items, which is also default.   So if you&apos;re doing Spring style checkpointing,  all you have to specify is commit-interval.

Multiple flushes is not a problem for transactional readers.  But it is a problem for non-transactional readers. 

Maybe a better approach is to control the commit interval with an item count and optional time limit.  Buffering would then be a boolean choice. The count would cause a commit every N (N&gt;0) items.  The time limit would cause a commit every S (S&gt;0) seconds.  If buffering, the buffer would never be larger than N. The result would be commit every N items or S seconds, which ever comes first.

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11753</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 15:23:48 +0000</bug_when>
    <thetext>I don&apos;t see why OOM issues are tied only to time based checkpoints.  They can happen in either case.  If you are concerned with time based ones...either switch to item based ones or reduce your time interval.  

I think this complexity is making this feature less useful than it could be.  In Spring Batch, the framework supports two ways of identifying commit intervals: number of items and the result of a call to the CompletionPolicy.isComplete.  This is setup this way because item counting is a fundimental piece of information when processing an item based step (so we include that as a commit interval metrics) and provide a point of extension for the developer to provide any other method they wish.  This eliminates the confusing scenarios we are getting into (where timeouts and item counts work in special ways, etc).  With it implemented this way, along with tying checkpoints to commit interval, the commit interval becomes a boolean and simplifies the entire thing.

Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11775</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-04 22:28:27 +0000</bug_when>
    <thetext>My thoughts ...

1st. Well, sure OOM is not exclusive to time-based checkpoints.  I will suggest, however, time-based is more vulnerable.  I will also suggest item-based is more vulnerable to transaction timeouts than is time-based. 

2nd. I agree the currently specified chunk externals for checkpoint configuration are confusing and need to be changed. 

3rd. I agree that buffer-size should be a boolean (e.g. buffer-items=true|false)

4th. I do not agree to have an item-based checkpoint criterion only. 

5th. I offer an analysis and proposal below that I invite you to consider.

--------------------------------------------------------------------------
Analysis: 

It would be useful to take a step back and consider what requirements and issues I think are driving the spec&apos;s approach toward specifying a step&apos;s checkpoint policy: 

Requirements: 

1. Requirement: batch developers must have a simple declarative way to specify checkpoint policy.  

2. Requirement: declarative checkpoint policy must enable reliable, predictable checkpoint behavior.  

3. Requirement: batch developers should have a way to provide custom checkpoint criteria.  

Issues: 

1. Issue: A strictly item based checkpoint policy is vulnerable to transaction timeouts. 

Why? Because you can&apos;t reliably predict how long it takes to process N items and you are not assured of specifying a transaction timeout in your job that will guarantee success in your production environment. 

Observation: specifying time as a checkpoint criterion facilitates avoiding transaction timeouts by making the duration of the checkpoint interval more predictable. 

2. Issue: A stricly time based checkpoint policy (with buffering enabled) is vulnerable to OOM.  

Why? Because you can&apos;t reliably predict how many items the system can buffer in T amount of time and you are not assured your job has access to sufficient memory to guarantee success in your production environment. 

Observation: specifying a buffer limit (i.e. item-count) as a checkpoint criterion facilitates avoiding OOMs by making the checkpoint working set more predictable.

3. Issue: it is insufficient to overcome issues 1 &amp; 2 above in a production environment by instructing operators (or developers) to simply modify their checkpoint criteria.

Why? Because post-production tuning is disruptive to production itself and needs to be avoided. The need for post-production tuning can be reduced by tuning in a pre-production environment. However, accurate tuning depends on homologous environments, which itself cannot be assured.

-----------------------------------------------------------------------------
Proposal: 

I submit the following proposal to address the aforementioned requirements and address the stated issues in a straight-forward way. 

Objectives:

1. Make item based checkpoint criteria default and simple.
2. Allow for both count and time as checkpoint criteria.
3. Allow for for custom checkpoint criteria. 
4. Accomodate item buffering as an orthogonal capability.

Externals (chunk attributes)

1. checkpoint-policy={item|custom}

The default is item. Specifying custom means use a checkpoint-algorithm (already in spec), which is specified separately in the job. Reminder: a checkpoint-algorithm is an application-provided boolean-based commit interval, allowing for user-defined checkpoint criteria.

2. item-count=&lt;number of items before checkpoint&gt;

Default=10.  After the specified number of items is processed, a checkpoint is taken.

3. time-limit=&lt;time before checkpoint&gt;

Default=0, which means no time limit.  After the specified amount of time transpires, a checkpoint is taken.

4. buffer-items=true|false

The default is true. Specifies whether items are buffered until checkpoint interval reached. When checkpoint interval reached, itemWriter is called once with a list of the buffered items. 

Note: if you combine item-count and time-limit, a checkpoint occurs after item-count items or after time-limit time, whichever happens first.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11785</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 16:13:33 +0000</bug_when>
    <thetext>I am going to put the proposal described in comment #5 into the spec and close this bug.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4270</bug_id>
          
          <creation_ts>2012-11-09 19:43:00 +0000</creation_ts>
          <short_desc>Step Sequence allows for looping</short_desc>
          <delta_ts>2013-01-16 17:04:54 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11473</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:43:28 +0000</bug_when>
    <thetext>Section 5.2, it is stated that the next attribute on the step element cannot create a loop (can&apos;t refer to the same step or one prior to the current one), however 5.2.5 (the next element) does not have that same restriction.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11595</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:28:58 +0000</bug_when>
    <thetext>We never intended to support looping.  Just need to make that clear in the spec.  Thanks for catching this oversight.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4271</bug_id>
          
          <creation_ts>2012-11-09 19:48:00 +0000</creation_ts>
          <short_desc>planplan typo in section 5.2.6.1</short_desc>
          <delta_ts>2013-01-16 17:25:18 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>trivial</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11474</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:48:28 +0000</bug_when>
    <thetext>Section 5.2.6.1 has a typo of calling the plan element planplan (appears both in the last sentence of the first paragraph in the section and the example below it (end of page 27).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11598</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:39:24 +0000</bug_when>
    <thetext>fixed - thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4272</bug_id>
          
          <creation_ts>2012-11-09 19:50:00 +0000</creation_ts>
          <short_desc>Nested flows should be supported</short_desc>
          <delta_ts>2013-01-16 15:27:11 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11475</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:50:37 +0000</bug_when>
    <thetext>Section 5.3 of the spec states that a flow can contain steps, decision and split elements.  It should be allowed to contain a flow as well.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11566</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:12:26 +0000</bug_when>
    <thetext>Yes, I think we had agreed on that before.  I missed a spec update.  Thanks for pointing it out. This time I made the update :)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12057</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:27:11 +0000</bug_when>
    <thetext>nested flows are supported</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4273</bug_id>
          
          <creation_ts>2012-11-09 19:58:00 +0000</creation_ts>
          <short_desc>Split Collector and analyzer should not be allowed</short_desc>
          <delta_ts>2013-01-16 15:36:04 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11476</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 19:58:58 +0000</bug_when>
    <thetext>A split is a set of steps or flows that are independent of each other running in different threads.  Because they are intended to be independent, there is no need for a collector/analyzer for this functionality.  Providing this allows the developer to build too much coupling between their steps.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11480</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 20:35:14 +0000</bug_when>
    <thetext>I was going to comment saying I thought this change was meant to address the issue raised as Bug 4183:

http://java.net/bugzilla/show_bug.cgi?id=4183

But then I read Chris&apos; response there and it seems to suggest that if you want to &quot;analyze&quot; the split results on the main thread, you should transition from the split to a decider which will have the split&apos;s FlowContext(s).    

Will wait to hear your response then Chris.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11587</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:22:08 +0000</bug_when>
    <thetext>We need a way for a decision following a split to know what happened in the split.  There are two needs:

1) The decision element requires an input user exit value - which user exit value from the flow should be used?  Each flow in the split produces a user exit value. 

2) The decision element should have access to the user exit status from each flow in the split in case the decision depends on the unique outcome of each flow.

There are a few ways I can think of to solve this:

1) the collector/analyzer model - which does invite coupling

2) a SplitListener that gets called at the end of each flow in the split and is passed the flow&apos;s exit status and whose job it is to set the final exit status for the split.

2) provide a map of flow names/exit status pairs in the split context and expose that to the decision - although since decision requires a user exit as input, one of the user exit values from the split flows would have to be selected - as a rule we could state the last flow to end determines the split&apos;s exit status. But that&apos;s non-deterministic. 

So what would you recommend?   I think I like option 2 the best.  For reference, what does Spring Batch do?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11614</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-19 14:47:43 +0000</bug_when>
    <thetext>For the record, Spring Batch does not view splits or flows at the same level as steps.  They are constructs that are used to group steps but do not have the same metadata as a step.  Because of this, a split or flow does not have a status, only the steps within it do.  Since a job is ultimately constructed of steps, an overall status of a split or flow ends up being redundant.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11616</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 15:51:09 +0000</bug_when>
    <thetext>In Spring Batch, a decider receives a StepExecution as input.  When the decision follows a split what StepExecution does the decider receive?  


(In reply to comment #3)
&gt; For the record, Spring Batch does not view splits or flows at the same level as
&gt; steps.  They are constructs that are used to group steps but do not have the
&gt; same metadata as a step.  Because of this, a split or flow does not have a
&gt; status, only the steps within it do.  Since a job is ultimately constructed of
&gt; steps, an overall status of a split or flow ends up being redundant.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11617</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-19 16:22:49 +0000</bug_when>
    <thetext>The decider receives null as the StepExecution if it follows a Split.  It does also receive the JobExecution which we can get all previous StepExecutions from if needed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11714</commentid>
    <comment_count>6</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 20:01:00 +0000</bug_when>
    <thetext>We can drop the split collector/analyer.  I agree it is added complexity with little gain.  The spec does not expose JobExecution/StepExecution interfaces except through JobOperator.   The decider has access to the SplitContext,  which could carry the results of the individual flows - e.g. a map (Flow Id, Flow Exit Status) would probably suffice.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11786</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 16:17:33 +0000</bug_when>
    <thetext>Comment #6 is the proposed resolution to this bug.  I will update the spec accordingly and close this bug.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4274</bug_id>
          
          <creation_ts>2012-11-09 20:16:00 +0000</creation_ts>
          <short_desc>Parallel step instances should not stop when another step fails</short_desc>
          <delta_ts>2013-01-16 16:07:20 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11477</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 20:16:02 +0000</bug_when>
    <thetext>Section 5.5 indicates that when parallel steps in a job are executing and one fails, the other should be marked as STOPPED.  Why would the other step be marked as stopped if it is independent of the step that throws an error?  Why not let it run to completion?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11546</commentid>
    <comment_count>1</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-11-14 23:15:28 +0000</bug_when>
    <thetext>I agree with this assessment. The job would default to FAILED but the rest of the parallel steps may still succeed.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11592</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:16:46 +0000</bug_when>
    <thetext>I&apos;ve had multiple clients ask to stop partitioned execution completely and immediately if any one partition fails so they can trigger off of job failure to promptly commence problem resolution.  So that influenced me here.  You can see room for policy.  But I don&apos;t want to complicate matters.  I agree the parallel execution units should be allowed to complete.  There are sufficient listeners and partition callbacks for the user to interpose and issue a stop if they want to pre-empt processing.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12072</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:07:20 +0000</bug_when>
    <thetext>the updated spec states active partitions are allowed to complete before the job is failed</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4275</bug_id>
          
          <creation_ts>2012-11-09 20:20:00 +0000</creation_ts>
          <short_desc>Stop element inconsistent with other decision elements</short_desc>
          <delta_ts>2013-01-16 16:25:57 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11478</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 20:20:32 +0000</bug_when>
    <thetext>In section 5.6.3, the stop element is given an exit-status element, yet fail and end do not have that.  These elements should be consistent.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11596</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:34:59 +0000</bug_when>
    <thetext>They do in the public draft.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4276</bug_id>
          
          <creation_ts>2012-11-09 20:29:00 +0000</creation_ts>
          <short_desc>ItemReader and ItemWriter interface requires unnecessary methods</short_desc>
          <delta_ts>2013-01-16 15:18:33 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>critical</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11479</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 20:29:18 +0000</bug_when>
    <thetext>The @Open, @Close and @Checkpoint annotations are not required when using annotations yet when we use interfaces, all of the methods are required.  This interface should be broken up into multiple interfaces to correctly reflect which methods are required.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11481</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 20:46:02 +0000</bug_when>
    <thetext>Instead of adding more interfaces to the API and complicating the inheritance tree, this could also be dealt with by simply specifying that an implementation has to accept a checkpointInfo() method returning &apos;null&apos;.

In this way a reader/writer developer could either choose to no-op the interface methods, or to use the annotations (with optional ones of course being optional).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11558</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 16:55:27 +0000</bug_when>
    <thetext>I agree with Scott.  I think the inheritance complexity outweighs the value.  We could either follow Scott&apos;s suggestion (documentation) or provide an abstract class that provides no-op implementatations of the optional methods.  

As an exercise,  I thought about using multiple interfaces, and in order to achieve equivalence with the permutations possible using the annotations, we&apos;d have to have the following (stylized) interfaces:

1. interface ItemReader {
public Item readItem();
}

2. interface OpenableItemReader extends ItemReader {
public void open();
}

3. interface ClosableItemReader extends ItemReader {
public void close();
}

4. interface CheckpointableItemReader extends ItemReader {
public CheckpointInfo getCheckpointInfo();
}

Possible concrete classes:

class MyOpenableReader implements OpenableItemReader { ... }
class MyClosableReader implements ClosableItemReader { ... }
class MyCheckpointableReader implements CheckpointableItemReader { ... }
class MyOpenableClosableReader implements OpenableItemReader,ClosableItemReader { ... }
class MyOpenableCheckpointableReader implements OpenableItemReader,CheckpointableItemReader { ... }
class MyClosableCheckpointableReader implements ClosableItemReader,CheckpointableItemReader { ... }
and finally, fully tricked out ...
class MyOpenableClosableCheckpointableReader implements OpenableItemReader,ClosableItemReader,CheckpointableItemReader { ... }

I think interface decomposition is most useful
when the resultant interfaces represent discrete entities that occur naturally
in the problem domain.  Maybe it&apos;s just the way I&apos;m looking at it, but I am
not seeing that in this case.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11790</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 16:54:01 +0000</bug_when>
    <thetext>We will use the abstract class approach to separate required from optional methods.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4277</bug_id>
          
          <creation_ts>2012-11-09 20:56:00 +0000</creation_ts>
          <short_desc>CheckpointAlgorithm requires checkpointTimeout method</short_desc>
          <delta_ts>2013-01-16 15:57:54 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11482</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 20:56:18 +0000</bug_when>
    <thetext>The CheckpointAlgorithm interface should not require the checkpointTimeout method since most implementations will not need it.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11593</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:18:06 +0000</bug_when>
    <thetext>I think we should resolve this with an abstract class.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12067</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:57:54 +0000</bug_when>
    <thetext>abstract class added</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4278</bug_id>
          
          <creation_ts>2012-11-09 20:58:00 +0000</creation_ts>
          <short_desc>Batchlet interface requires stop method</short_desc>
          <delta_ts>2013-01-16 16:17:50 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11483</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 20:58:53 +0000</bug_when>
    <thetext>Since the @Stop method on a Batchlet will not be required, it should not be required on the interface either.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11564</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:08:44 +0000</bug_when>
    <thetext>Bug 4327 challenges the notion that stop is optional.  After we resolve that bug, should we conclude that stop is still optional,  we can handle it the way we handle other optional methods,  which is the subject raised by bug 4276.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11789</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 16:44:37 +0000</bug_when>
    <thetext>The stop operation will be made optional.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4280</bug_id>
          
          <creation_ts>2012-11-09 21:01:00 +0000</creation_ts>
          <short_desc>Are the ChunkListener.beforeCheckpoint and afterCheckpoint methods necessary?</short_desc>
          <delta_ts>2013-01-16 15:29:17 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11485</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 21:01:24 +0000</bug_when>
    <thetext>With listeners around all business functionality, is there a need to have listener methods around this infrastructure level function?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11584</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 10:59:06 +0000</bug_when>
    <thetext>I think we can remove before/after checkpoint and not lose any functionality.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4281</bug_id>
          
          <creation_ts>2012-11-09 21:27:00 +0000</creation_ts>
          <short_desc>Clarification needed around RetryListener methods</short_desc>
          <delta_ts>2013-01-16 17:48:54 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11487</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 21:27:47 +0000</bug_when>
    <thetext>In section 6.2.8, the interface for a RetryListener seems to have two methods for every event where I would expect only one.  For example, onRetryReadException and onRetryReadItem.  Both are called when a retryable exception is thrown on reading an item.  Both take the Exception that was thrown as the argument.  It is unclear what the difference between the two are and when to use each.  Same goes for onRetryProcessException/onRetryProcess and onRetryWriteException/onREtryWriteItems.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11488</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 21:37:45 +0000</bug_when>
    <thetext>The flow outline in Sec. 8.7 do explain this in more detail.

The onRetryReadException is called immediately after the exception is caught, and the determination is made that it is one to retry upon.   

The onRetryReadItem is called before the read is performed again (retried).  

The one question I have:

In the retry-with-rollback case, are:
onRetryReadItem 
onRetryProcessItem
onRetryWriteItems

supposed to be called for every read/process/write in the rolled back checkpoint?   Or are they supposed to ONLY be called for the read/process/write corresponding to the original failure?

If the latter, there could be some subtleties to iron out, since for example, &quot;process&quot; might return a different item the second time..or filter differently.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11610</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:27:47 +0000</bug_when>
    <thetext>The idea is that one is called in the same transaction as the error, while the other is called in the next transaction before the actual retry.  E.g. this sequence:

reader.readItem(...)
onRetryReadException(...)     
roll back
begin
onRetryRead(...)
reader.ReadItem(...) # again


(In reply to comment #0)
&gt; In section 6.2.8, the interface for a RetryListener seems to have two methods
&gt; for every event where I would expect only one.  For example,
&gt; onRetryReadException and onRetryReadItem.  Both are called when a retryable
&gt; exception is thrown on reading an item.  Both take the Exception that was
&gt; thrown as the argument.  It is unclear what the difference between the two are
&gt; and when to use each.  Same goes for onRetryProcessException/onRetryProcess and
&gt; onRetryWriteException/onREtryWriteItems.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11611</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:33:09 +0000</bug_when>
    <thetext>OnRetryWriteItems is problematic, because I think we intend to retry the chunk, reading one item at a time.  Maybe we should not have OnRetryRead/Process/WriteItem(s) methods. Just have the OnRetry*Exception methods and be done with it.  Thoughts?


(In reply to comment #1)
&gt; The flow outline in Sec. 8.7 do explain this in more detail.
&gt; The onRetryReadException is called immediately after the exception is caught,
&gt; and the determination is made that it is one to retry upon.   
&gt; The onRetryReadItem is called before the read is performed again (retried).  
&gt; The one question I have:
&gt; In the retry-with-rollback case, are:
&gt; onRetryReadItem 
&gt; onRetryProcessItem
&gt; onRetryWriteItems
&gt; supposed to be called for every read/process/write in the rolled back
&gt; checkpoint?   Or are they supposed to ONLY be called for the read/process/write
&gt; corresponding to the original failure?
&gt; If the latter, there could be some subtleties to iron out, since for example,
&gt; &quot;process&quot; might return a different item the second time..or filter differently.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11612</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:34:18 +0000</bug_when>
    <thetext>I think we should not have OnRetryRead/Process/WriteItem(s) methods. Just have the OnRetry*Exception methods and be done with it.  Thoughts?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11615</commentid>
    <comment_count>5</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-19 15:20:35 +0000</bug_when>
    <thetext>I agree with the consolidation of it just down to when the exception is thrown.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4282</bug_id>
          
          <creation_ts>2012-11-09 21:39:00 +0000</creation_ts>
          <short_desc>Checkpoint and application updates should be in the same transaction</short_desc>
          <delta_ts>2013-01-16 16:15:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11489</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 21:39:50 +0000</bug_when>
    <thetext>Per section 6.7, the default behavior is to commit the application data and the checkpoint information in separate transactions.  This means that the default behavior allows the condition of the application&apos;s true state being out of sync from the stored state.  The default should be that these occur in the same transaction.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11512</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-12 17:28:31 +0000</bug_when>
    <thetext>A downside of defaulting to &apos;true&apos; is that the transactional behavior won&apos;t take affect, by default, in an SE environment.   But, given that the spec mentions this is just an intent, it would be a fine choice as well.  

I could go either way.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11563</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:04:15 +0000</bug_when>
    <thetext>Yeah,  trying to thread the needle between SE and EE environments ...

In an SE environment there is simply no guarantee of a XA transaction manager.  So in SE, you get what you get unless you add in JOTM or something comparable. 

But I agree the default is the wrong default.  The default should be XA - if possible.  The opt-out should be local mode.  

So the spec should say something like:

The runtime will attempt to use global transaction mode by default.  But this can only be guaranteed by the Java environment in which the batch runtime is executing. This guarantee is assured by a Java EE environment;  it can only be assured in a Java SE environment if the environment has been configured with an XA tranaction manager. 

A batch step may be executed in local transaction mode,  if desired, by setting step level property: 

javax.transaction.global.mode=false

Note when running in local mode (i.e. global mode is false) application updates and batch runtime checkpoints are not in the same transactional scope.  

Note also that even when global mode is true, that application updates and batch runtime checkpoints are in the same transactional scope if and only if the hosting Java environment supplies an XA transaction manager.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12079</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:15:21 +0000</bug_when>
    <thetext>checkpoint and application updates are in same transaction in EE environment through use of global tran.  not true of SE,  since tran manager is not required on that platform. An implementer is free to accomodate global transaction in SE but is not required to by spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4283</bug_id>
          
          <creation_ts>2012-11-09 21:40:00 +0000</creation_ts>
          <short_desc>TransactionManagerSPI is missing enlist (for enlisting checkpoint resources)</short_desc>
          <delta_ts>2013-01-16 15:28:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11490</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-09 21:40:06 +0000</bug_when>
    <thetext>I think it should have something like:

 enlist(XAResource) 

which it would call after the begin().</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11568</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:30:10 +0000</bug_when>
    <thetext>I&apos;m going to go down swinging on this one, Scott :)   The SPI does not need enlist.  Resource enlistment is the responsibility of the environment.  In EE,  the connection management takes care of it.  In an SE environment, the user-provided XA tran manager takes care of it - e.g. JOTM datasource factories. If the SE environment lacks an XA tran manager,  then of course enlistment is moot. I do not believe there is a scenario in which the batch runtime needs to enlist its checkpoint resource with a transaction manager.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12058</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:28:15 +0000</bug_when>
    <thetext>the SPI has been dropped from the spec</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4286</bug_id>
          
          <creation_ts>2012-11-09 22:21:00 +0000</creation_ts>
          <short_desc>Schema allows for an empty job</short_desc>
          <delta_ts>2013-01-16 15:27:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11494</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 22:21:17 +0000</bug_when>
    <thetext>Per the XSD provided in the spec, an empty job (no listeners, flows/steps/etc) is valid.  We probably should require that a job either contain the elements required to run or be extended from.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11567</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:20:28 +0000</bug_when>
    <thetext>Well, I dunno ...  if people want to pass their time running empty jobs,  who are we to say no?  

One might similarly argue the Java spec should disallow classes that have no members, or perhaps methods that have no code,  or ...  well you see where I&apos;m going.  

I don&apos;t think this is worth worrying about.  If others feel strongly about it, we can consider adding validation to kick out the job with an exception if there&apos;s nothing in it.  But I&apos;m reluctant to do that because it adds more surface area to the spec and I&apos;m unconvinced the addition has substantive value.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4288</bug_id>
          
          <creation_ts>2012-11-09 22:50:00 +0000</creation_ts>
          <short_desc>What does Batchlet.stop apply to?</short_desc>
          <delta_ts>2013-01-16 16:09:24 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11496</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 22:50:34 +0000</bug_when>
    <thetext>Batchlet.stop is an instance method, so it is presumed that calling it would stop the execution of that instance (not all instances in a multithreaded scenario) but it is not clear either way from the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11560</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 19:29:15 +0000</bug_when>
    <thetext>Stop is called by the batch runtime. 

Section 8.11 of the spec states:

&quot;Batchlet Step

The job and step batch status is marked STOPPING. The batch runtime invokes the batchlet&apos;s stop method, if defined.  The batch runtime then interrupts the batchlet thread, which results in java.lang.InterruptedException. The job and step batch status is marked STOPPED.&quot;

Let me know if you still think the spec is unclear.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4290</bug_id>
          
          <creation_ts>2012-11-12 14:26:00 +0000</creation_ts>
          <short_desc>Typo in 4.2 Step</short_desc>
          <delta_ts>2013-01-16 15:24:05 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11501</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:26:02 +0000</bug_when>
    <thetext>Part of &quot;4.2 Step&quot; states:

&quot;requiring little or no code. (depending on the implementations used) A more&quot;

Looks like it should be:

&quot;requiring little or no code (depending on the implementations used). A more&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11565</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:10:13 +0000</bug_when>
    <thetext>Corrected.  Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4291</bug_id>
          
          <creation_ts>2012-11-12 14:40:00 +0000</creation_ts>
          <short_desc>4.5 ItemReader more details reference</short_desc>
          <delta_ts>2013-01-16 15:35:08 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11502</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:40:44 +0000</bug_when>
    <thetext>4.5 ItemReader states &quot;See section 5.2.1 for more details about ItemReaders&quot;. While 5.2.1 mentions it as an attribute of a chunk, 6.1.1.1 goes into greater detail about an ItemReader</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11586</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:05:44 +0000</bug_when>
    <thetext>Thanks. I changed the reference to 6.1.1.1.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4292</bug_id>
          
          <creation_ts>2012-11-12 14:43:00 +0000</creation_ts>
          <short_desc>4.6 Item Writer more details reference</short_desc>
          <delta_ts>2013-01-16 17:54:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11503</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:43:39 +0000</bug_when>
    <thetext>4.6 Item Writer states &quot;See section 5.2.1 for more details about ItemWriters&quot;. While 5.2.1 mentions it as an attribute of a chunk, 6.1.1.3 goes into greater detail about an ItemWriter</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11604</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:56:42 +0000</bug_when>
    <thetext>Referenced changed to 6.1.1.3.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4293</bug_id>
          
          <creation_ts>2012-11-12 14:44:00 +0000</creation_ts>
          <short_desc>4.7 Item Processor more details reference</short_desc>
          <delta_ts>2013-01-16 17:31:36 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11504</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:44:41 +0000</bug_when>
    <thetext>4.7 Item Processor states &quot;See section 5.2.1 for more details about ItemProcessors&quot;. While 5.2.1 mentions it as an attribute of a chunk, 6.1.1.2 goes into greater detail about an ItemProcessor</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11605</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:57:39 +0000</bug_when>
    <thetext>Referenced chagned to 6.1.1.2</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4295</bug_id>
          
          <creation_ts>2012-11-12 14:53:00 +0000</creation_ts>
          <short_desc>Typos in 5.2.6 Step Partitioning</short_desc>
          <delta_ts>2013-01-16 17:51:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11506</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:53:40 +0000</bug_when>
    <thetext>Two things I noticed:

1. &quot;A PartitionReducer provides programmatic control over logic unit of work ....&quot;

The &quot;over logic unit of work&quot; isn&apos;t clear - possibly rephrase as &quot;A PartitionReducer provides programmatic control over a logical unit of work ....&quot;

2. In the XML example, it reads &quot;specify a partitioned step: step id=&quot;Step1&quot;&gt;

The prefixing &lt; is missing before step. It also may be more clear if the step tag was on the following line</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11606</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:10:50 +0000</bug_when>
    <thetext>Both changes made.  Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4296</bug_id>
          
          <creation_ts>2012-11-12 14:56:00 +0000</creation_ts>
          <short_desc>5.2.6.3 typo</short_desc>
          <delta_ts>2013-01-16 18:22:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11507</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 14:56:48 +0000</bug_when>
    <thetext>&quot;Note a the mapper element is mutually exclusive with plan element&quot; 

should be:

&quot;Note the mapper element is mutually exclusive with the plan element&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11607</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:13:14 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4297</bug_id>
          
          <creation_ts>2012-11-12 15:00:00 +0000</creation_ts>
          <short_desc>7.6.3 why StepContext implements Externalizable?</short_desc>
          <delta_ts>2013-01-16 15:31:09 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11508</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-12 15:00:49 +0000</bug_when>
    <thetext>and it is not the case for the other contexts (JobContext, FlowContext, SplitContext).
Isnt it parameter P that should implements Externalizable?

In this case instead of:
public interface StepContext &lt;T,P&gt; extends BatchContext &lt;T&gt;, Externalizable {
...
}

it should be:
public interface StepContext &lt;T,P extends Externalizable&gt; extends BatchContext &lt;T&gt; {
...
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11569</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 20:33:02 +0000</bug_when>
    <thetext>Yeah ...  don&apos;t know what happened there.  It&apos;s P that&apos;s externalizable.  I updated the spec.  Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4298</bug_id>
          
          <creation_ts>2012-11-12 15:03:00 +0000</creation_ts>
          <short_desc>5.4.1 Split Collection has references to wrong sections</short_desc>
          <delta_ts>2013-01-16 17:50:01 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11509</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 15:03:44 +0000</bug_when>
    <thetext>1. &quot;See section 6.5.4 for further information about the Split Analyzer&quot;

Should be:

&quot;See section 6.5.6 for further information about the Split Analyzer&quot;

Section 6.5.4 is &quot;PartitionAnalyzer Interface&quot;and 6.5.4 is &quot;SplitAnalyzer Interface&quot;

2. &quot;The collector element specifies a reference to a SplitCollector batch artifact; see section 6.5.3 for further information&quot;

Should be:

&quot;The collector element specifies a reference to a SplitCollector batch artifact; see section 6.5.5 for further information&quot;

Section 6.5.3 is &quot;PartitionCollector Interface&quot;and 6.5.5 is &quot;SplitCollector Interface&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11609</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:21:43 +0000</bug_when>
    <thetext>I corrected the references.  However, note that split analyzer/collector may be removed based on the resolution of bug 4273</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4300</bug_id>
          
          <creation_ts>2012-11-12 17:27:00 +0000</creation_ts>
          <short_desc>5.4.2 SplitAnalyzer references wrong section</short_desc>
          <delta_ts>2013-01-16 18:06:51 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11511</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 17:27:33 +0000</bug_when>
    <thetext>5.4.2 indicates to see section 6.5.4 in regards to a SplitAnalyzer, but SplitAnalyzer is at section 6.5.6</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11613</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 13:36:54 +0000</bug_when>
    <thetext>Reference fixed.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4301</bug_id>
          
          <creation_ts>2012-11-12 17:37:00 +0000</creation_ts>
          <short_desc>Typo in 5.6 xml attribute</short_desc>
          <delta_ts>2013-01-16 17:44:35 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11514</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 17:37:47 +0000</bug_when>
    <thetext>In the Example the leading r from &quot;ef&quot; to make ref= of the decision tag is missing</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11599</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:41:04 +0000</bug_when>
    <thetext>Fixed. Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4302</bug_id>
          
          <creation_ts>2012-11-12 17:39:00 +0000</creation_ts>
          <short_desc>5.8 invalid closing xml tag</short_desc>
          <delta_ts>2013-01-16 17:48:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11515</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 17:39:31 +0000</bug_when>
    <thetext>In the first example of parent-job.xml, the closing tag should be job rather than step</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11600</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:42:08 +0000</bug_when>
    <thetext>Fixed. Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4303</bug_id>
          
          <creation_ts>2012-11-12 17:53:00 +0000</creation_ts>
          <short_desc>Break RetryListener down into multiple interfaces?</short_desc>
          <delta_ts>2013-01-16 17:55:31 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11516</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-12 17:53:47 +0000</bug_when>
    <thetext>Rather than having one interface for Read, Write and Process - RetryListener should be broken down into specific interfaces such as RetryReadListener, RetryProcessListener, RetryWriterListener. Seems like a lot to possibly have to no-op or use annotations as a work around.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11602</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:49:07 +0000</bug_when>
    <thetext>This is a reasonable argument.  The original intent was to match Spring Batch interfaces where it made sense.  This one does in terms of its singularity, but the methods are different.  I will socialize multiple interfaces with the expert group and see where we end up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11791</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 17:34:49 +0000</bug_when>
    <thetext>Yep, you&apos;re right.  We should have an interface for read, process, write.  That&apos;s what we&apos;ll do.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4319</bug_id>
          
          <creation_ts>2012-11-14 21:48:00 +0000</creation_ts>
          <short_desc>JobOperator does not provide a simple way to get the current JobExecution</short_desc>
          <delta_ts>2017-04-08 08:21:40 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          <see_also>http://java.net/bugzilla/show_bug.cgi?id=4383</see_also>
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>diherbalselalu</cc>
    
    <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11543</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-14 21:48:15 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11544</commentid>
    <comment_count>1</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-14 21:55:05 +0000</bug_when>
    <thetext>Is there a way to get the current JobExecution form a job instance ID without searching through all the job executions associated with a particular instance ID and looking for a batch status associated with running job?

It seems like the only way to do this now is to call List&lt;JobExecution&gt; getJobExecutions(long instanceID) and traverse the list.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11591</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:56:53 +0000</bug_when>
    <thetext>By &quot;current&quot; I suppose you mean the execution with a batch status of STARTING or STARTED?   

JobOperator.start used to return an executionId, I think,  which would have been the typical use cases where an executionId would be good to have.  

JobOperator.start now returns instanceId. BTW, JobOperator.restart returns an executionId.   

So it seems it would be good to have a JobOperator.getRunningExecution(Long executionId) or something similar.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11737</commentid>
    <comment_count>3</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-30 21:23:52 +0000</bug_when>
    <thetext>This sounds good Chris. I&apos;ve added the following method which takes a JobInstance: 

/**
 * Returns the currently running execution of the given jobInstance
 * 
 * @param jobInstance
 * @return The currently running
 */
JobExecution getRunningExecution(JobInstance jobInstance)throws JobExecutionNotRunningException;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11759</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 19:01:40 +0000</bug_when>
    <thetext>That new method probably also needs to throw a NoSuchJobInstanceException for cases where it does not exist...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11773</commentid>
    <comment_count>5</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-12-04 19:51:03 +0000</bug_when>
    <thetext>Sorry to open this up again, but instead of adding a new JobOperator method maybe we could to the following to simplify:

If we change JobOperator.start() to return an execution id/JobExecution instead of an instance id we will automatically return the currently running execution and we don&apos;t have to worry about adding a extra step to get the current execution. And we can use the current API to map from a job execution to a job instance with the addition of a getInstanceId() method to the JobExecution interface. I believe JobExecution to instance id/JobInstance is a natural mapping. 

JobOperator.restart() already returns an execution id so we can keep that the same. 

I&apos;ve been using long instance/execution id&apos;s somewhat interchangeably with JobInstance/JobExecution objects since bug 4383 is still open.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11774</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-04 19:55:09 +0000</bug_when>
    <thetext>I missed the earlier change.  In Spring Batch, the JobOperator.start returns the id of the JobExecution (the newly created artifact)...not of the instance.  From the JobExecution, you can get the instance.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11787</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 16:22:15 +0000</bug_when>
    <thetext>Ok, I&apos;m convinced.  We&apos;ll go with the proposal in comment #5,  which is also consistent with comment #6.  I&apos;m updating the spec accordingly and closing this bug.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12063</commentid>
    <comment_count>8</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:37:46 +0000</bug_when>
    <thetext>JobOperator.start now returns an execution id.  That solves this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543599</commentid>
    <comment_count>9</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:18:39 +0000</bug_when>
    <thetext>Your post had provided me with another point of view on this topic. I had absolutely no notion that things can possibly work in this form as well. Thank you for sharing your perspective. http://colivre.net/diherbal/obat-herbal-hiv-paling-ampuh

I need to appreciate your appropriately written article their useful and your writing style helped me to it with absolutely no difficulty. Credit http://uiupdate.ui.ac.id/blog-entry/obat-hiv-paling-ampuh

I found useful information on this topic as I am working on a business project. Thanks a lot posting relative information and its now becoming easier to complete this project http://fourlook.com/post/obat-hiv-alami-paling-ampuh-53494.html</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543600</commentid>
    <comment_count>10</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:20:42 +0000</bug_when>
    <thetext>We are currently working on a great assignment and I have been exploring your page for a few hours. Thank you for your the idea proved worthwhile for me. https://xplor.xl.co.id/t5/Lounge/Obat-Asma-Pada-Anak/m-p/45414

I probable appreciating any of it. is an incredible  and very good impart. I should much obliged. Great employment! You all an incredible page, and possess some extraordinary substance. https://web.alvernia.edu/eportfolio/view/view.php?id=13282

I&apos;d been very encouraged to locate this website. I desired to thanks with this special study. I certainly savored each and every this  and I&apos;ve you bookmarked to look at brand new things you write. https://cs.byu.edu/job-posting/obat-asma-untuk-anak</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>543602</commentid>
    <comment_count>11</comment_count>
    <who name="">diherbalselalu</who>
    <bug_when>2017-04-08 08:21:40 +0000</bug_when>
    <thetext>The globe is changing fast. people are also getting changed.day by day we are becoming more dependant on degital system.you are making me think of this really.You have a great method of sharing your thoughts. http://braceroarchive.org/myomeka/posters/show/1175

This is definitely really a brilliant post, many thanks alot : ) for telling Great luck I found out about this particular blog site. http://foodspotting.com/guides/143034-obat-kista-herbal-paling-ampuh

I really enjoy simply reading through all your weblogs. Simply wanted to inform you that you have people like me who appreciate your work. Undoubtedly an excellent publish. The information which you have provided is very helpful. https://tackk.com/obat-herbal-kista-endometriosis</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4327</bug_id>
          
          <creation_ts>2012-11-16 14:34:00 +0000</creation_ts>
          <short_desc>Remove InterruptedException from stop processing and require stop() on Batchlet.</short_desc>
          <delta_ts>2012-12-06 16:45:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11556</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-16 14:34:07 +0000</bug_when>
    <thetext>In section 8.11 (Stop Processing) it states, &quot;The batch runtime then interrupts the batchlet thread, which results in java.lang.InterruptedException.&quot;

This implies that the batch container guarantees that we can stop a Batchlet through an interrupt even if a Batchlet does not implement the stop method. Once the batch container gives up control to a Batchlet there is no way to force it to return unless we enforce the best practice of implementing a stop() or release() type method. This is how most threadpool implementations like ExecutorService and WorkManager handle this problem.

The only time InterruptedException will be thrown on a Thread.interrupt() is in a wait(), sleep(), or blocking IO call which throws InterruptedException. Since InterruptedException is a checked exception it could still be caught and ignored by the Batchlet anyway. And if the batchlet it not waiting, sleeping, or in a blocking IO call the Thread.interrupt() will not have any effect unless the batchlet implementation performs period checks to see if the thread has been interrupted.

Another point of ambiguity is that we can&apos;t enforce how the underlying threadpool implements stop processing for work that it is executing. For example, Java&apos;s ExecutorService requires that all Work implement a release() method, and typical implementations only issue a Thread.interrupt when the entire ExecutorService is shut down, but this is not true for other WorkManagers. (From the ExecutorService javadoc: &quot;There are no guarantees beyond best-effort attempts to stop processing actively executing tasks. For example, typical implementations will cancel via Thread.interrupt(), so any task that fails to respond to interrupts may never terminate.&quot;)

So my main point is that we should probably not mention anything in the spec about interrupting threads or InterruptedExceptions, and just require that a stop method is implemented on all Batchlets(change section 6.1.2). This will help to enforce the programming guideline: &quot;A well designed batchlet stops gracefully when the JobOperator.stop operation is invoked.&quot; (which is already in the spec).</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11561</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-17 19:39:26 +0000</bug_when>
    <thetext>You are correct InterruptedException can be caught and ignored.  The batchlet implementor (forced to implement stop) can also implement stop as a no-op.  So you can&apos;t win :)  

I was under the mistaken impression InterruptedException was thrown unconditionally, which I thought made improved its usefulness.  

The debate within the EG that lead to this dual approach of an optional stop method and an InterruptedException is strong opinion that the stop method should not be required.  If not required, it tends to be ignored.  If ignored, you have the operational problem of a poorly behaved batchlet.  

Unfortunately Java doesn&apos;t have an ABTERM function like z/OS - kills threads on contact :)   

I originally proposed a required stop method and no InterruptedException.  The EG then talked me out of that, leading to what we see in the public draft.  

I will discuss with the EG and attempt to achieve concensus on required stop. If concensus is not achieved, I will likely leave the spec as is,  because afterall, the InterruptedException doesn&apos;t hurt anything.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11663</commentid>
    <comment_count>2</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-26 18:51:41 +0000</bug_when>
    <thetext>Thanks Chris, looks like we agree on this. However, by even mentioning InterruptedException we can get ourselves into some trouble. When you bring this up with the expert group please mention that the following statement has some implications that we really don&apos;t want to support in the batch container, &quot;The batch runtime then interrupts the batchlet thread, which results in java.lang.InterruptedException.(Section 8.11).&quot;

1. Firstly, a container can&apos;t throw a java.lang.InterruptedException on a thread where it doesn&apos;t have control; it can only set the interrupted flag to true on a thread and then hope that whatever code has control checks for that flag and throws an InterruptedException. So again, we are back to the Batchlet code having to check for the flag and throw the InterruptedException.

2. The first point then implies that the batch runtime must implement (and spec out) its own JSE and J2EE thread pool management to enforce this thread stop behavior.  The batch container won&apos;t be able to use any managed thread pools included with a J2EE application server or any third party work managers since we have to have full control over the threads and how to stop them. Different workmanagers handle &quot;forced&quot; stops in different ways and most don&apos;t provide a user API that can set an interrupted flag on a thread, (however they all do require a stop() method to be implemented). 

So simply mentioning InterruptedException can be misleading because it is a behavior that is not possible to implement by any batch RI.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11715</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 21:57:53 +0000</bug_when>
    <thetext>I thought thread A could interrupt thread B as long as the SecurityManager allowed access.  In our case thread A would normally have access.  But I see the slippery slope and we don&apos;t need both stop and interrupt.  Stop will probably end up being optional.  But we can drop the interrupt stuff.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4329</bug_id>
          
          <creation_ts>2012-11-17 21:11:00 +0000</creation_ts>
          <short_desc>5.5.2 link to FlowContext</short_desc>
          <delta_ts>2013-01-16 17:33:15 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11570</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:11:17 +0000</bug_when>
    <thetext>In: &quot;See section 6.4.1 for FlowContext&quot;, it may be better to reference 6.4.1.1 as it directly mentions FlowContext</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11718</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:06:14 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4330</bug_id>
          
          <creation_ts>2012-11-17 21:12:00 +0000</creation_ts>
          <short_desc>5.5.3 link to SplitContext</short_desc>
          <delta_ts>2013-01-16 17:47:49 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11571</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:12:18 +0000</bug_when>
    <thetext>In: &quot;See section 6.4.1 for SplitContext&quot;, it may be better to reference 6.4.1.1 as it directly mentions SplitContext</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11725</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:33:28 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4331</bug_id>
          
          <creation_ts>2012-11-17 21:14:00 +0000</creation_ts>
          <short_desc>Formatting of rules in 5.8</short_desc>
          <delta_ts>2013-01-16 17:54:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11572</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:14:25 +0000</bug_when>
    <thetext>Rules 1-3 in section 5.8 are missing capitalization, and colons on top level items are inconsistent (ie: rule #3 ends in a colon where 1 &amp; 2 don&apos;t.)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11793</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 17:46:50 +0000</bug_when>
    <thetext>Your new nickname is &quot;eagle eye&quot; :)   

All fixed up now.  Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11795</commentid>
    <comment_count>2</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-06 17:59:06 +0000</bug_when>
    <thetext>(In reply to comment #1)
&gt; Your new nickname is &quot;eagle eye&quot; :)   
&gt; 
&gt; All fixed up now.  Thanks

LOL! As I read through things I tend to print it out and write all over it so although minor figured I&apos;d share :^)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4332</bug_id>
          
          <creation_ts>2012-11-17 21:20:00 +0000</creation_ts>
          <short_desc>Typos in 6.1.1.1 javadoc</short_desc>
          <delta_ts>2013-01-16 17:28:32 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11573</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:20:03 +0000</bug_when>
    <thetext>1. &quot;The open method prepare the reader to read items.&quot; I think should be &quot;The open method prepares the reader to read items.&quot;

2. &quot;The readitem method returns the next item from the stream.&quot; I think should be &quot;The readItem method returns the next item from the stream.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11717</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:02:59 +0000</bug_when>
    <thetext>1. verb agreement - check
2. camel case - check

Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4333</bug_id>
          
          <creation_ts>2012-11-17 21:22:00 +0000</creation_ts>
          <short_desc>6.1.1.3 missing javadoc</short_desc>
          <delta_ts>2013-01-16 17:46:42 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11574</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:22:42 +0000</bug_when>
    <thetext>1. The ItemReader and ItemProcessor interfaces have class level javadoc where ItemWriter does not.

2. &quot;The open method prepare the writer to write items.&quot; I think should be &quot;The open method prepares the writer to write items.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11724</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:29:42 +0000</bug_when>
    <thetext>1. added - check
2. verb agreement - check

thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4334</bug_id>
          
          <creation_ts>2012-11-17 21:28:00 +0000</creation_ts>
          <short_desc>6.2.4 typo</short_desc>
          <delta_ts>2013-01-16 17:50:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11575</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:28:19 +0000</bug_when>
    <thetext>&quot;A item read listener ...&quot; I think should be &quot;An item read listener ...&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11794</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 17:48:32 +0000</bug_when>
    <thetext>Right you are.  Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4335</bug_id>
          
          <creation_ts>2012-11-17 21:30:00 +0000</creation_ts>
          <short_desc>Usage of &quot;Impl&quot; in class names</short_desc>
          <delta_ts>2012-12-06 16:46:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11576</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:30:13 +0000</bug_when>
    <thetext>This may be nit picky, but I noticed the usage of &quot;Impl&quot; in classes that are annotated vs. implementing an interface. If &quot;Impl&quot; is to be used, it would seem better suited on classes implementing an interface rather than an annotated class.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11716</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:00:31 +0000</bug_when>
    <thetext>Ok, point taken :)  It turns out we are discarding the &quot;annotations only&quot; approach,  so those examples will disappear.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11745</commentid>
    <comment_count>2</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-12-01 17:22:58 +0000</bug_when>
    <thetext>(In reply to comment #1)
&gt; Ok, point taken :)  It turns out we are discarding the &quot;annotations only&quot;
&gt; approach,  so those examples will disappear.

Nice! :-)</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4336</bug_id>
          
          <creation_ts>2012-11-17 21:41:00 +0000</creation_ts>
          <short_desc>6.4.1 JobContext reference</short_desc>
          <delta_ts>2013-01-16 17:45:56 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11577</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:41:15 +0000</bug_when>
    <thetext>&quot;See section 7.6.1 for definition of JobContext class&quot; should be &quot;See section 7.6.2 for the definition of the JobContext class&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11723</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:21:46 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4337</bug_id>
          
          <creation_ts>2012-11-17 21:43:00 +0000</creation_ts>
          <short_desc>6.5 typos</short_desc>
          <delta_ts>2013-01-16 17:49:39 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11578</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:43:55 +0000</bug_when>
    <thetext>1. &quot;1. partitioned&quot; should be &quot;1. Partitioned:&quot;

2. &quot;d. PartitionAnalyzer provides a means gather interrim...&quot; should be &quot;d. PartitionAnalyzer provides a means to gather interim...&quot;

3. &quot;3. concurrent&quot; should be &quot;3. Concurrent:&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11796</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 18:41:23 +0000</bug_when>
    <thetext>Thanks. Updated.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4338</bug_id>
          
          <creation_ts>2012-11-17 21:47:00 +0000</creation_ts>
          <short_desc>6.5.1 reference to PartitionPlan</short_desc>
          <delta_ts>2013-01-16 18:21:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11579</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:47:07 +0000</bug_when>
    <thetext>&quot;See section 7.6.6 for details on the PartitionPlan result value type.&quot; should be &quot;See section 7.6.7 for details on the PartitionPlan result value type.&quot;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11743</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-30 22:08:48 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4339</bug_id>
          
          <creation_ts>2012-11-17 21:56:00 +0000</creation_ts>
          <short_desc>7.2 typos</short_desc>
          <delta_ts>2013-01-16 17:45:11 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11580</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:56:18 +0000</bug_when>
    <thetext>&quot;is&quot; in both the instanceId and executionId descriptions should be capitalized</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11721</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:14:38 +0000</bug_when>
    <thetext>ok. done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4340</bug_id>
          
          <creation_ts>2012-11-17 21:57:00 +0000</creation_ts>
          <short_desc>7.6.2 missing javadoc</short_desc>
          <delta_ts>2013-01-16 17:48:22 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11581</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 21:57:53 +0000</bug_when>
    <thetext>Javadoc is missing on the getBatchStatus method</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11726</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:35:01 +0000</bug_when>
    <thetext>done. thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4341</bug_id>
          
          <creation_ts>2012-11-17 23:32:00 +0000</creation_ts>
          <short_desc>7.6.6 metric names as enum rather than strings</short_desc>
          <delta_ts>2013-01-16 18:06:16 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11582</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-17 23:32:30 +0000</bug_when>
    <thetext>Rather than String&apos;s for metric names, I think it would be nicer to use an enum to represent them.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11742</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-30 22:06:53 +0000</bug_when>
    <thetext>You make a good point.  We&apos;ll change to enum.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4348</bug_id>
          
          <creation_ts>2012-11-20 15:33:00 +0000</creation_ts>
          <short_desc>Do artifacts need no-arg constructor?</short_desc>
          <delta_ts>2013-01-16 16:28:44 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11627</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 15:33:22 +0000</bug_when>
    <thetext>Should the spec say that artifacts need a no-arg constructor?  

Maybe this gets lumped into some of the other discussions with DI/CDI/etc. about artifact portability from a more generic Java perspective...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11628</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 15:34:54 +0000</bug_when>
    <thetext>Minor clarification:  I guess the point in saying the artifact would have a no-arg ctor would be to go on to say that the batch container would actually use it to instantiate the instance....</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11766</commentid>
    <comment_count>2</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-03 21:54:04 +0000</bug_when>
    <thetext>I would assume no given that the loading of artifacts is up to the underlying implementation.  In the Spring example, we don&apos;t require no arg constructors and allow users to use constructor injection as they wish.  Although I&apos;ve never used CDI, I&apos;d imagine similar facilities are available there as well...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11800</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 19:31:59 +0000</bug_when>
    <thetext>Artifacts cannot be portable if spec implementations decide how constructors are supported.  I believe the spec must require no-arg constructors.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11801</commentid>
    <comment_count>4</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-06 19:36:50 +0000</bug_when>
    <thetext>Chris, I respectfully disagree.  By requiring (and therefore implying the use of) no arg constructors, you will then need some form of initialization mechanism to be called once all required properties are set (similar to the InitializationBean interface in Spring).  Without that functionality, I don&apos;t think we can require no-arg constructors.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11804</commentid>
    <comment_count>5</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 20:10:08 +0000</bug_when>
    <thetext>Michael, I see your point, but I&apos;m not so sure the spec can be completely mute on this subject, either. It still seems to me if the spec delegates this part of the programming model to spec implementors that we break portability. 

So I&apos;m starting to think we need to go in the other direction:  rather than requiring a particular sort of constructor in the programming model,  stipulate the runtime implementation must not require any non-default constructors.

In effect, that implies artifacts are initialized with the default constructor. I wonder if the spec should simply state that. 

If you think the spec should say nothing about constructors,  please comment explicitly on how you see code portability working.  

Thanks</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11805</commentid>
    <comment_count>6</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-12-06 20:19:59 +0000</bug_when>
    <thetext>My expectation, since we have agreed that DI is a requirement for the spec and the form of DI is not, was that we would identify a common way to associate artifacts (@Named/batch.xml) and that&apos;s as far as the spec would go.  How those artifacts are constructed is an implementation detail dependent on the DI framework used.  If I choose to use CDI, Spring, Guice or any other DI framework, they all have their own mechanisms for object creation and migrating from one to the other would come with a certain level of effort that is outside of the scope of this spec to mitigate (IMO).

For that reason, I would not expect the spec to weigh in on this topic.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11914</commentid>
    <comment_count>7</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-20 15:50:18 +0000</bug_when>
    <thetext>Michael, I think you&apos;ve convinced me. Construction comes with the DI implementation. The spec will say nothing on this subject.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4349</bug_id>
          
          <creation_ts>2012-11-20 15:47:00 +0000</creation_ts>
          <short_desc>Spec should be clear that properties are not &quot;inherited&quot; or visible from containing scopes in JSL</short_desc>
          <delta_ts>2013-01-16 17:05:57 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11629</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 15:47:41 +0000</bug_when>
    <thetext>For a simple example take:

&lt;job id=&quot;job1&quot;..&gt;
   &lt;properties&gt;
        &lt;property name=&quot;myprop1&quot; value=&quot;xxx&quot;/&gt;
   &lt;/properties&gt;
    &lt;step id=&quot;step1&quot; next=step2&quot;&gt;
        &lt;batchlet ref=&quot;MyBatchlet&quot;/&gt;
    &lt;/step&gt;

Chris&apos; intention in the spec is that there is no ability to inject a batch property (via @BatchProperty) into the batchlet.

However, since it is a common construct of programming languages to allow &quot;inner&quot; scopes to reference &quot;variables&quot; from &quot;outer&quot; scopes... I think it would be very helpful to add some wording clarifying that this is not how JSL works.

Instead of having to do this artifact by artifact maybe it could be summed up in Section 6.3 &quot;Batch Properties&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11630</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-20 16:01:24 +0000</bug_when>
    <thetext>I agree the spec should explicitly state properties are not inherited.  Although omission should never imply the existence of something :) 

The statement about not being able to inject a property into a batchlet is not accurate.  Consider ... 

While it is true properties are not inherited from outer scopes, it is possible to inject a batch property into a batchlet - e.g. 

     &lt;step id=&quot;step1&quot; next=step2&quot;&gt;
         &lt;batchlet ref=&quot;MyBatchlet&quot;&gt;
                &lt;properties&gt;
                       &lt;property name=&quot;MyProp&quot; value=&quot;MyPropValue&quot;/&gt;
                &lt;/properties&gt;
         &lt;/batchlet&gt;
     &lt;/step&gt;

Injects &quot;MyPropValue&quot; into

@BatchProperty(&quot;MyPropValue&quot;) String _propVal; 

inside the batchlet implementation.  

Outer property scopes (e.g. job level) can be SUBSTITUTED (not inherited) into the batchlet property using EL syntax - e.g. 

&lt;property name=&quot;MyProp&quot; value=&quot;#{jobProperties[&apos;SomeJobProperty&apos;]}&quot;/&gt;



(In reply to comment #0)
&gt; For a simple example take:
&gt; &lt;job id=&quot;job1&quot;..&gt;
&gt;    &lt;properties&gt;
&gt;         &lt;property name=&quot;myprop1&quot; value=&quot;xxx&quot;/&gt;
&gt;    &lt;/properties&gt;
&gt;     &lt;step id=&quot;step1&quot; next=step2&quot;&gt;
&gt;         &lt;batchlet ref=&quot;MyBatchlet&quot;/&gt;
&gt;     &lt;/step&gt;
&gt; Chris&apos; intention in the spec is that there is no ability to inject a batch
&gt; property (via @BatchProperty) into the batchlet.
&gt; However, since it is a common construct of programming languages to allow
&gt; &quot;inner&quot; scopes to reference &quot;variables&quot; from &quot;outer&quot; scopes... I think it would
&gt; be very helpful to add some wording clarifying that this is not how JSL works.
&gt; Instead of having to do this artifact by artifact maybe it could be summed up
&gt; in Section 6.3 &quot;Batch Properties&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11635</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:45:57 +0000</bug_when>
    <thetext>Chris,  

I understand and agree...sorry if my wording was confusing as I just meant it was not possible to inject the batchlet property with the exact JSL snippet I started with.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11802</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 19:51:01 +0000</bug_when>
    <thetext>Bottom line,  I will strengthen the explanation in the spec to detail that outer scoped properties are not inherited by inner scopes.  Although, substitution from outer scopes is possible.  But that&apos;s different.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4350</bug_id>
          
          <creation_ts>2012-11-20 16:04:00 +0000</creation_ts>
          <short_desc>Need any late-binding/late-resolution of JSL substitution properties</short_desc>
          <delta_ts>2013-01-16 16:09:57 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11631</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:04:51 +0000</bug_when>
    <thetext>Seems like there might be some value in having a &quot;late binding&quot; type of property, to allow step1 to influence a property used for step 2.

Seems like the only type of substitution which would be a candidate for this type of thing is the system property.   The JSL properties and the job parameters are determined at job start/restart time.

(And I think it is an OK thing for any old API to set a System property, even in JEE, right?) 

Or maybe this makes property substitution too complicated and this type of dynamic binding should be done via JobContext.   The downside of that, of course, is that your app makes use of properties but with no integration into the view of property usage you get via the other JSL/substitution property mechanisms.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11651</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-21 16:09:27 +0000</bug_when>
    <thetext>Incorporating Wayne&apos;s comment...something like this from SpringBatch would be a solution to my issue (but it&apos;s not in the public draft).

&lt;property name=&quot;resource&quot; value=&quot;#{jobExecutionContext[&apos;input.file.name&apos;]}&quot; /&gt;

Maybe we should also still clarify when the system property substitution occurs...I&apos;m thinking at job start time as the JSL is parsed upfront.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11806</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 20:26:51 +0000</bug_when>
    <thetext>Well, the spec includes the #{jobProperty[]} substitution.  But what&apos;s missing for step N to influence step N+1 is a means to capture and expose output properties. 

To do that, we&apos;d have to do like SpringBatch and persist a step&apos;s property values at end of step and expose them through something like #{jobExecution[]}. The output properties have to be persisted so they are available across restarts.

I think it is generally a useful idea, so I will add it to the spec. 

Since the runtime will persist the properties of all steps,  it makes sense to store them in the StepExecution.   

For a given step N+1 to substitute an output property from step N,  it must have a way to designate from which step to resolve the property.  So I propose something like:

#{jobExecution.&lt;stepname&gt;[&apos;&lt;property-name&gt;&apos;]}

Opinions?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11915</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-20 15:55:55 +0000</bug_when>
    <thetext>Ok, so with no further discussion since my last comment, I will proceed to add this to the spec.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12075</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 16:09:57 +0000</bug_when>
    <thetext>&quot;saved&quot; property was added to the spec to address this</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4351</bug_id>
          
          <creation_ts>2012-11-20 16:17:00 +0000</creation_ts>
          <short_desc>BatchContext getBatchContexts() type parameterization shouldn&apos;t be &lt;FlowContext&gt;</short_desc>
          <delta_ts>2013-01-16 16:26:29 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11632</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:17:18 +0000</bug_when>
    <thetext>public List&lt;FlowContext&lt;T&gt;&gt; getBatchContexts();

  should be:

public List&lt;BatchContext&lt;T&gt;&gt; getBatchContexts();</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11741</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-30 22:00:14 +0000</bug_when>
    <thetext>Right. Changed.  Thanks.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4352</bug_id>
          
          <creation_ts>2012-11-20 16:22:00 +0000</creation_ts>
          <short_desc>Any point to 7.6.8 BatchRuntime.getJobOperator()?</short_desc>
          <delta_ts>2013-01-16 15:34:52 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>INVALID</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11633</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:22:47 +0000</bug_when>
    <thetext>How does this help clarify how to get the JobOperator?

Either it needs more detail or should be removed altogether and the JobOperator left as an interface. 

Perhaps you could say something like: 

&quot;A recommended approach for a Java SE-based implementation is to use the java.util.ServiceLoader mechanism for loading an instance of
javax.batch.runtime.BatchRuntime&quot;.

Or maybe the extra wrapper is unnecessary and just say a recommended approach is to use ServiceLoader to load JobOperator directly.

I&apos;d vote NOT to require it though.. but we could do it in the RI for SE.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11807</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 20:30:33 +0000</bug_when>
    <thetext>There needs to be a portable means in the programming model for an application to obtain a reference to a JobOperator.  The spec proposes a factory pattern, which will work for both SE and EE: 

public class Batch { 
     public static JobOperator getJobOperator(); 
}

That is the contract.  The spec implementor must supply an implementation of that class/method that returns a JobOperator.  How the implementor does that is discretionary.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4353</bug_id>
          
          <creation_ts>2012-11-20 16:26:00 +0000</creation_ts>
          <short_desc>Worth definining int-type properties?</short_desc>
          <delta_ts>2013-01-16 17:52:26 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11634</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:26:50 +0000</bug_when>
    <thetext>With only String properties, there will be a lot of boilerplate code converting to int/Integer... which isn&apos;t a huge deal, but would it be worth having something like:

JSL:
&lt;property name=&quot;A&quot; value=&quot;Aval&quot; type=&quot;xsd:int&quot;/&gt;

mapping to Java;

  @BatchProperty Integer A;</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11810</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 22:34:34 +0000</bug_when>
    <thetext>It&apos;s a nice to have. There is room for helpful improvements in maintenance releases.  At this point we need to restrain ourselves to the essentials. Virtually anything that needs to be done can be done from a string property.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4354</bug_id>
          
          <creation_ts>2012-11-20 16:55:00 +0000</creation_ts>
          <short_desc>JSR352-defined exceptions use non-standard constructors, setCause()..why RuntimeException</short_desc>
          <delta_ts>2013-01-16 16:26:11 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11636</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 16:55:20 +0000</bug_when>
    <thetext>First, it seems odd to have a constructor:

  public BatchOperationsRuntimeException(Throwable th, String localizedMessage) 

defined to use setCause().

Why not just use the four standard constructors for each of BatchOperationsRuntimeException and the subclasses we define (NoSuchJobException, etc.)

RuntimeException()
RuntimeException(String message)
RuntimeException(String message, Throwable cause)
RuntimeException(Throwable cause) 

Just use the four forms of super() ctor delegation for each.

------------------------------------------------------------------------------

Also, seems like these would be reasonable candidates for being checked exceptions, i.e. not RuntimeException(s).     

Were you trying to reduce the amount of boilerplate code with catch-blocks etc.?  But doesn&apos;t that just leave you open to NullPointerException, etc.?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11811</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 22:36:31 +0000</bug_when>
    <thetext>Yes, the should be checked exceptions.  There is no reason to use anything but the standard constructors.  The next rev of the spec will include those adjustments.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12038</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-14 14:41:29 +0000</bug_when>
    <thetext>Actually, the spec will just list the exception classes by name without showing the implementation details.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4355</bug_id>
          
          <creation_ts>2012-11-20 18:59:00 +0000</creation_ts>
          <short_desc>Is wording &quot;It must specify a valid XML boolean value&quot; specific enough?</short_desc>
          <delta_ts>2013-01-16 17:46:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11637</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 18:59:36 +0000</bug_when>
    <thetext>There is an XSD boolean, and I think what you&apos;re really trying to say here is that you want to accept
&apos;true&apos;
&apos;false&apos;
and anything else is an error (FAILED state).

In contrast to say Boolean.parseBoolean() which will match &apos;true&apos; ignoring case and which defaults to false rather than blowing up.

If so, maybe simply saying it can be either &apos;true&apos; or &apos;false&apos; would be better.   

This is the definition for multiple attributes in the spec (e.g. /job/@restartable)</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11812</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 22:41:07 +0000</bug_when>
    <thetext>ok - will say &apos;true&apos; or &apos;false&apos;</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4356</bug_id>
          
          <creation_ts>2012-11-20 19:42:00 +0000</creation_ts>
          <short_desc>Function of skipCount across restart</short_desc>
          <delta_ts>2013-01-16 15:58:10 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11638</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 19:42:58 +0000</bug_when>
    <thetext>At first I assumed there was nothing to say here.. the skip count(s) would get reset to &apos;0&apos; and we&apos;d start counting against skip-limit all over again.

I realized I&apos;m making an assumption though... that it&apos;s correct to reset the three &quot;skip metrics&quot; for StepExecution to 0.

If we were to try to persist these values across restart, we have another subtlety:

We can double count skips against certain records if we:
 a) skip
 b) hit a rollback within the same checkpoint
 c) skip the same record on restart

I think that assuming we do reset the count to 0, it is fine to &quot;recount&quot;...but it&apos;s more in the case where we try to persist the count that double-counting is an issue.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11813</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 22:41:52 +0000</bug_when>
    <thetext>The skip count is per job execution.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4357</bug_id>
          
          <creation_ts>2012-11-20 19:49:00 +0000</creation_ts>
          <short_desc>Clarify that batch artifact explicitly setting exit status to &apos;null&apos; or empty string preempts defaulting to batch status.</short_desc>
          <delta_ts>2013-01-16 17:21:03 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11639</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-20 19:49:08 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11814</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 23:20:41 +0000</bug_when>
    <thetext>ok, will update the spec to say so</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12094</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 17:21:03 +0000</bug_when>
    <thetext>The spec says this:

If setExitStatus was not 
	 * called or was called with a null value, then the exit status 
	 * defaults to the batch status of the job.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4363</bug_id>
          
          <creation_ts>2012-11-21 12:39:00 +0000</creation_ts>
          <short_desc>start-limit: on restart, start-limit applies only to actual re-execution of step or even step&apos;s decision logc</short_desc>
          <delta_ts>2013-01-16 15:29:30 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11648</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-21 12:39:46 +0000</bug_when>
    <thetext>Let me reference two earlier issues:  Bug 4266 and Bug 4098.

In Bug 4098, I outlined how the decision logic would rerun for a given step on restart even though the application logic would only rerun if allow-start-if-complete=true. (Since Chris agreed in a comment I&apos;m assuming I&apos;m safe using this understanding as my working assumption.)   

So my first question : does only the execution of a step&apos;s application logic count against the start limit, or does even going through the decision logic?

I mention Bug 4266, since it&apos;s in the same arena and it probably suggests that Spring Batch offers a precedent here.  I&apos;m guessing it&apos;s only the execution of a step&apos;s application logic.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11815</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 23:38:45 +0000</bug_when>
    <thetext>Well, we&apos;re back discussing 4098 because we still don&apos;t have it right.  But concerning start-limit - the intent of start limit is to control the number of times a step&apos;s application logic is attempted.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4364</bug_id>
          
          <creation_ts>2012-11-21 12:47:00 +0000</creation_ts>
          <short_desc>Interaction of start-limit and allow-start-if-complete</short_desc>
          <delta_ts>2013-01-16 15:55:28 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11649</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-21 12:47:46 +0000</bug_when>
    <thetext>One could imagine hitting the start-limit for a given step, not because of repeated failures, but because allow-start-if-complete is set to &apos;true&apos;.

Or should that not count against start-limit?  

If not, then in spite of the conclusion of Bug 4266, we should probably go back to considering this a &quot;restart limit&quot; not a limit on the number of executions.

We could reserve the &apos;0&apos; setting to mean, &quot;cannot be run on restart&quot; and we could use the absence of the attribute altogether to mean &quot;no limit&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11816</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-06 23:42:44 +0000</bug_when>
    <thetext>You get what you get.   If you specify allow-start-if-complete and a start-limit, the step can only start start-limit times.  Start-limit=0 still means no limit.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4365</bug_id>
          
          <creation_ts>2012-11-21 13:18:00 +0000</creation_ts>
          <short_desc>How is the completion of flows/splits persisted and treated on restart?</short_desc>
          <delta_ts>2013-01-16 18:20:38 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11650</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-21 13:18:29 +0000</bug_when>
    <thetext>Assuming the overall approach outlined in Bug 4098 (decision logic reruns on restart, application logic typically doesn&apos;t), there are a couple of reasons why we need to be clear on whether it&apos;s meaningful to consider a flow or a split as having already completed on restart.

Take a flow for example, and assuming that there is no meaning attach to &quot;flow already completed&quot;.

So for one:  intra-flow decision logic rerunning could take us down a different path than during the original run, even if the flow had &quot;completed&quot; successfully.   

Second: allow-start-if-complete steps that were branched to would rerun on restart.

On the other hand, couldn&apos;t we treat a persisted &quot;flow completed&quot; as a signal to simply skip the flow internals, and transition to the @next id, and still have a coherent story? (I realize this gets tricky if we have a decider but I&apos;m going to open a separate issue for that).

Do we need an allow-start-if-complete equivalent for flow (that could get complicated...not trying to introduce it if no one thinks it will be used in real world scenarios)?

---

I noticed in Comment 3, Bug 4273 mminella touched on this question from another angle, saying that SpringBatch doesn&apos;t treat splits/flows as &quot;first class&quot; executions in this regard.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11819</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-07 00:04:40 +0000</bug_when>
    <thetext>Regarding 4098,  we are eliminating job parameters on restart,  so some aspects of what this bug brings up go away.  

Regarding persisting some information that a flow is complete to assist with restart logic - that fine,  but not a spec issue - that should remain an implementation detail.  

Regarding something like a allow-start-if-completed for a flow - no - we need to stay focused on whether or not individual steps are allowed to start or not.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4366</bug_id>
          
          <creation_ts>2012-11-21 23:33:00 +0000</creation_ts>
          <short_desc>@BatchProperty only way to inject properties into an artifact?</short_desc>
          <delta_ts>2013-01-16 17:44:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>chrisschaefer</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11655</commentid>
    <comment_count>0</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-21 23:33:03 +0000</bug_when>
    <thetext>This in a way is similar to the @Named requirement (http://java.net/bugzilla/show_bug.cgi?id=4304). It seems the only way to inject batch properties into an artifact is by marking fields with @BatchProperty.

The 6.3.1 @BatchProperty example shows:

@Named
public class MyItemReaderImpl {
    @BatchProperty String fname=&quot;/tmp/input.txt&quot;;
}

This seems somewhat limiting as for example w/ Spring the wiring is done on the bean/artifact itself. So for instance in Spring Batch MyItemReaderImpl&apos;s fname value could get wired via XML through a constructor argument, setters or on fields (additionally) with annotations along with type conversion, bean scoping, etc. http://java.net/bugzilla/show_bug.cgi?id=4353 also raises a good point on String only properties and manual conversion.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11656</commentid>
    <comment_count>1</comment_count>
    <who name="">chrisschaefer</who>
    <bug_when>2012-11-21 23:40:14 +0000</bug_when>
    <thetext>I could open another issue if needed, but the same seems to apply for BatchContext.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11820</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-07 00:05:57 +0000</bug_when>
    <thetext>In version 1 of this spec,  yes @BatchContext and @BatchProperty are the only way.  There is room for future improvement,  but we need to stay focused on essentials to get version 1 out.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4381</bug_id>
          
          <creation_ts>2012-11-30 15:03:00 +0000</creation_ts>
          <short_desc>Job identifiers clarification</short_desc>
          <delta_ts>2013-01-16 15:41:25 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11731</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-30 15:03:21 +0000</bug_when>
    <thetext>In 7.2, it is not clear to me if instanceId, executionId and stepExecutionId are expected to be globally unique in the repository or just unique for a particular job.
The job operator interface allows to get a JobInstance with only an instanceId and a JobExecution with only an executionId but to get a StepExecution we need both executionId and stepExecutionId =&gt; it means that instanceId and executionId could be unique in the repository but not stepExecutionId. Is there any reason for that?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11733</commentid>
    <comment_count>1</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-30 15:18:54 +0000</bug_when>
    <thetext>It would have to be globally unique since there&apos;s nothing to scope a method like:
  JobInstance getJobInstance(long instanceId);
to a job.

For what it&apos;s worth, the RI is currently using the same id pool for both instanceIDs and executionIDs... which makes the point that there&apos;s no requirement for the ids to be sequential &quot;without gaps&quot; (not that we were specifically trying to make that point).

Also wanted to note that this reminds me of Bug 4051... where we recognized the need to add a way to get step execution ID from something like the JobExecution+stepname perhaps.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11735</commentid>
    <comment_count>2</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-11-30 20:36:56 +0000</bug_when>
    <thetext>I think I missed a key detail in the original comment and confused the reply.

Starting over:

We agree that instanceId and (job) executionId must be globally unique, (not just unique within jobs and job instances).   

But must &apos;stepExecutionId&apos; be globally unique? .. given that its only use as INPUT is:

  StepExecution getStepExecution(long jobExecutionId, long stepExecutionId);

If it is globally unique, then this would suffice:

  StepExecution getStepExecution(long stepExecutionId);

...

Again, this raises the point from Bug 4051, how does the JobOperator client get the &apos;stepExecutionId&apos;?  

We should have something like:

  StepExecution getStepExecution(long jobExecutionId, String stepName);

Note that:

  List&lt;StepExecution&gt; getStepExecutions(long jobExecutionId); 

probably wouldn&apos;t cut it unless StepExecution were to be defined to have a getName().</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11821</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-07 00:09:33 +0000</bug_when>
    <thetext>StepExecutionId will be globally unique, just like InstanceId and ExecutionId.  We are reworking getStepExecution to accept only a StepExecutionId.  We are adding a getter to list an execution&apos;s stepexecutionIds.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4382</bug_id>
          
          <creation_ts>2012-11-30 15:12:00 +0000</creation_ts>
          <short_desc>Status parameter of PartitionReducer.afterPartitionedStepCompletion should be an enum</short_desc>
          <delta_ts>2013-01-16 17:56:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11732</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-30 15:12:44 +0000</bug_when>
    <thetext>As it is specified in 6.5.2 that the value is either &quot;COMMIT&quot; or &quot;ROLLBACK&quot;.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11738</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-30 21:27:44 +0000</bug_when>
    <thetext>No reason for it not to be an enum.  Change made.  Thanks</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4383</bug_id>
          
          <creation_ts>2012-11-30 21:40:00 +0000</creation_ts>
          <short_desc>Change JobOperator parameters from primitive types to Objects</short_desc>
          <delta_ts>2013-01-16 15:27:45 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>geofjamg</cc>
    
    <cc>issues</cc>
    
    <cc>ScottKurz</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11739</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-30 21:40:49 +0000</bug_when>
    <thetext>I&apos;d like to propose changing most of the primitive types used in the JobOperator API to Objects to ensure type safety. This will help to avoid any type of problems where instance id&apos;s are confused with execution id&apos;s or vice versa (We&apos;ve already hit this issue several times in the RI developement). I believe this conforms more closely with Java best practices and will allow the compiler to catch these types of simple errors in a batch application before they get into the runtime. I&apos;ve included a refactored version of the JobOperator here with a few other minor corrections with exceptions, getRunningExecution(), and getStepExecution().

package javax.batch.operations;

import java.util.List;
import java.util.Set;
import java.util.Properties;
import javax.batch.operations.exception.JobExecutionIsRunningException;
import javax.batch.operations.exception.JobExecutionNotRunningException;
import javax.batch.operations.exception.JobInstanceAlreadyCompleteException;
import javax.batch.operations.exception.JobRestartException;
import javax.batch.operations.exception.JobStartException;
import javax.batch.operations.exception.NoSuchJobException;
import javax.batch.operations.exception.NoSuchJobExecutionException;
import javax.batch.operations.exception.NoSuchJobInstanceException;
import javax.batch.runtime.JobExecution;
import javax.batch.runtime.JobInstance;
import javax.batch.runtime.StepExecution;

public interface JobOperator {
	/**
	 * Returns a set of all job names known to the batch runtime.
	 * 
	 * @return a set of job names.
	 */
	Set&lt;String&gt; getJobNames();

	/**
	 * Returns number of instances of a job with a particular name (id).
	 * 
	 * @param jobName
	 *            specifies the name of the job.
	 * @return count of instances of the named job.
	 * @throws NoSuchJobException
	 */
	int getJobInstanceCount(String jobName) throws NoSuchJobException;

	/**
	 * Returns all instanceIds belonging to a job with a particular name.
	 * 
	 * @param jobName
	 *            identifies the job name.
	 * @param start
	 *            identifies the relative starting number to return from the
	 *            maximal list of job instances.
	 * @param count
	 *            identifies the number of instance ids to return from the
	 *            starting position of the maximal list of job instances.
	 * @return list of job instances
	 * @throws NoSuchJobException
	 */
	List&lt;JobInstance&gt; getJobInstances(String jobName, int start, int count)
			throws NoSuchJobException;

	/**
	 * Returns instanceIds for all running jobs across all instances of a job
	 * with a particular name.
	 * 
	 * @param jobName
	 *            identifies the job name.
	 * @return a Set of job instances
	 * @throws NoSuchJobException
	 */
	Set&lt;JobInstance&gt; getRunningInstanceIds(String jobName) throws NoSuchJobException;

	/**
	 * Returns all executionIds belonging to a particular job instance.
	 * 
	 * @param jobInstance
	 *            identifies the job instance
	 * @return List of Job Executions
	 * @throws NoSuchJobInstanceException
	 */
	List&lt;JobExecution&gt; getExecutions(JobInstance jobInstance) throws NoSuchJobInstanceException;

	/**
	 * Returns job parameters for specified execution. These are the key/value
	 * pairs specified when the instance was started or restarted.
	 * 
	 * @param jobExecution
	 *            identifies the execution.
	 * @return a Properties object containing the key/value job parameter pairs.
	 * @throws NoSuchJobExecutionException
	 */
	Properties getParameters(JobExecution jobExecution)
			throws NoSuchJobExecutionException;

	/**
	 * Creates a new job instance and starts the first execution of that
	 * instance.
	 * 
	 * @param job
	 *            specifies the Job XML describing the job.
	 * @param jobParameters
	 *            specifies the keyword/value pairs for property override and
	 *            substitution in Job XML.
	 * @return JobInstance of the new job execution.
	 * @throws JobStartException
	 */
	JobInstance start(String job, Properties jobParameters) throws JobStartException;

	
	/**
	 * Returns the currently running execution of the given jobInstance
	 * 
	 * @param jobInstance
	 * @return The currently running
	 */
	JobExecution getRunningExecution(JobInstance jobInstance)throws JobExecutionNotRunningException;
	
	/**
	 * Restarts a failed or stopped job instance.
	 * 
	 * @param instanceId
	 *            belonging to the instance to restart. The execution that
	 *            restarts is the most recent execution to run.
	 * @param jobParameters
	 *            specify replacement job parameters for the job restart. The
	 *            replacement add to and/or override the original job parameters
	 *            that were specified when the instance was originally started.
	 * @return new job execution
	 * @throws JobInstanceAlreadyCompleteException
	 * @throws NoSuchJobExecutionException
	 * @throws NoSuchJobException
	 * @throws JobRestartException
	 */
	JobExecution restart(JobInstance jobInstance, Properties jobParameters)
			throws JobInstanceAlreadyCompleteException,
			NoSuchJobInstanceException, NoSuchJobException,
			JobRestartException;

	/**
	 * Request a running execution stops. *
	 * 
	 * @param instanceId
	 *            specifies the instance to stop (the currently running
	 *            execution is stopped)
	 * @throws NoSuchJobExecutionException
	 * @throws JobExecutionNotRunningException
	 */
	void stop(JobInstance jobInstance) throws NoSuchJobInstanceException,
			JobExecutionNotRunningException;

	/**
	 * Set batch status to ABANDONED. The instance must not be running.
	 * 
	 * @param instanceId
	 *            specifies the instance to mark abandoned
	 * @throws NoSuchJobExecutionException
	 *             * @throws JobExecutionIsRunningException
	 */
	void abandon(long instanceId) throws NoSuchJobExecutionException,
			JobExecutionIsRunningException;

	/**
	 * Return the job instance for the specified job instance id
	 * 
	 * @param instanceId
	 *            specifies the requested job instance
	 * @return job instance
	 */
	JobInstance getJobInstance(long instanceId);

	/**
	 * Return all job executions belonging to the specified job instance
	 * 
	 * @param jobInstance
	 *            specifies the job instance
	 * @return list of job executions
	 */
	List&lt;JobExecution&gt; getJobExecutions(long instanceId);

	/**
	 * Return job execution for specified execution id
	 * 
	 * @param executionId
	 *            specifies the requested job execution
	 * @return job execution
	 */
	JobExecution getJobExecution(long executionId);

	/**
	 * Return step execution for specified execution
	 * 
	 * @param jobInstance
	 *            specifies the JobInstance
	 * @param jobExecution
	 *            specifies the JobExecution
	 * @param stepId
	 *            specifies the unique step id within a job
	 * @return step execution
	 */
	StepExecution getStepExecution(JobInstance jobInstance, JobExecution jobExecution, String stepId);

	/**
	 * Returns a list of all the executed steps in a job execution. 
	 * 
	 * @param jobExecution
	 * @return
	 */
	List&lt;StepExecution&gt; getJobSteps(JobExecution jobExecution);
}</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11740</commentid>
    <comment_count>1</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-11-30 21:54:39 +0000</bug_when>
    <thetext>Small correction to the getStepExecution() method. Removed the JobInstance parameter, since a JobExecution object is already associated with a JobInstance.

Also, please note that we need to change the last parameter from &apos;long stepExecutionId&apos; to &apos;String stepId&apos; and add a getStepId() method to StepExecution interface. This is because currently there is no way to map from a step id to a StepExecution. For example, if I had job with id=job1 with three steps, id=step1, id=step2, id=step3, and I wanted to get the end time for step2, there is no way to input that to the JobOperator.

/**
 * Return step execution for specified execution
 * 
 * @param jobExecution
 *            specifies the JobExecution
 * @param stepId
 *            specifies the unique step id within a job
 * @return step execution
 */
StepExecution getStepExecution(JobExecution jobExecution, String stepId);



public interface StepExecution&lt;P&gt; {

    
	/**
	 * Get the step id of the executed step.
	 * 
	 * @return
	 */
	public String getStepId();</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11744</commentid>
    <comment_count>2</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-11-30 22:22:38 +0000</bug_when>
    <thetext>In that case, why not removing all the &apos;long&apos; ids from JobOperator interface and also getId() method in JobInstance, JobExecution and StepExecution so that ids are not exposed to the api?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11771</commentid>
    <comment_count>3</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-12-04 16:39:08 +0000</bug_when>
    <thetext>This might be a choice between performance and clarity to the developer, since for a persistent impl, we might typically go to the database to conjure up a full JobExecution/JobInstance object.

We wouldn&apos;t want the JobOperator client to have to new up the JobInstance/JobExecution himself I don&apos;t thik.

With this change, for code like: 

JobExecution exec =  jobOperator.restart(...)
exec.getStartTime(); 

This might then typically be called before the job has (re)started.   

So we end up with a &apos;null&apos; (I doubt we&apos;d want to specify a default value).

OTOH, the batch status is well-defined (STARTING).

I don&apos;t think that&apos;s a big deal....  and like Kaushik said it is a source of confusion to the developer...</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11916</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-20 16:15:13 +0000</bug_when>
    <thetext>The general concept raised by this bug will be factored into the spec.  You will have to look to the Final Proposed spec for details.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4384</bug_id>
          
          <creation_ts>2012-12-03 01:57:00 +0000</creation_ts>
          <short_desc>{Job, Step, Chunk}Listeners don&apos;t receive enough information</short_desc>
          <delta_ts>2013-01-16 15:20:06 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>major</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mk111283</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11750</commentid>
    <comment_count>0</comment_count>
    <who name="">mk111283</who>
    <bug_when>2012-12-03 01:57:21 +0000</bug_when>
    <thetext>Currently, {Job, Step, Chunk}Listeners do not receive any data about the Job, Step or Chunk on the callback methods.

For example, StepListener is defined as

public interface StepListener {
    public beforeStep() throws Exception;
    public afterStep() throws Exception;
}

Shouldn&apos;t these methods StepContext?

Mahesh.Kannan@Oracle.Com</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11779</commentid>
    <comment_count>1</comment_count>
    <who name="">mk111283</who>
    <bug_when>2012-12-05 18:59:59 +0000</bug_when>
    <thetext>This may not be an issue if we use CDI for instantiating these Listeners. If we do that, then these listeners can inject the appropriate {Job, Step, Chunk} Context within them. 

I assume the spec will mention this. 

P.S. Marking this as a P5 since other issues are also marked as P5.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11822</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-07 00:14:33 +0000</bug_when>
    <thetext>Whether or not you use CDI, the @BatchContext injection will work.  That is a requirement of the spec.  So an implementor can can choose between JSR 299,  JSR330, or their own implementation.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4393</bug_id>
          
          <creation_ts>2012-12-04 17:38:00 +0000</creation_ts>
          <short_desc>Enough specified for step (and job) inheritance ?</short_desc>
          <delta_ts>2013-01-16 15:25:21 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11772</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2012-12-04 17:38:04 +0000</bug_when>
    <thetext>Just wanted to write up the working assumption used by the RI/TCK with respect to inheritance, to solicit comments in case there are thoughts that more (or different) detail is needed in the spec.

E.g. I realize that Spring Batch provides more/different capabilities here.

In the TCK we have artifacts like:

EXAMPLE 1: 

parentJob.xml
-------------
&lt;job id=&quot;parent&quot;...

childJob.xml
------------
&lt;job id=&quot;child&quot; parent=&quot;parent&quot; ...



EXAMPLE 2 (no overlap w/ EXAMPLE 1):

parentStep.xml
-------------
&lt;step id=&quot;parent&quot;..&gt;    &lt;!-- Note this is the root element of the document --&gt;

childStep.xml
------------
&lt;job id=&quot;child&quot; parent=&quot;parent&quot; ...
    &lt;step id=&quot;child&quot; parent=&quot;parent&quot;


So the &quot;parent&quot; step is defined in a separate XML document of which it is
the root element.

I call this out since it could be surprsing if one is expecting &lt;job&gt; to be
the root element of any JSL document.   Since nothing is said in the public draft spec, it&apos;s not currently violating the spec.

The way is currently tested in the TCK is by defining a logical &quot;merge parent+child&quot; TCK SPI which the implementation executing the TCK must implement.   I.e. no jobs are actually started... we just confirm that the abstract/logical merge results in the JSL it should result in per the inheritance merging rules.

One more point.. in the RI we make inheritance work by supplying a metadata XML as an index to associate the @parent values with a particular file.
  
------------------------------------------------------------------------------

I don&apos;t have an objection to this, I just wanted to make sure it didn&apos;t slip under the radar that the spec allowed this.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11919</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-20 16:37:45 +0000</bug_when>
    <thetext>The spec will not stipulate how the parent is resolved.  That is an implementation decision. Nor will the spec stipulate what the root element in the parent definition is.  Again, that is an implementation decision.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12055</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-16 15:25:21 +0000</bug_when>
    <thetext>spec was updated to say implementer must provide an implementation specific way to resolve the parent job xml reference,  with resolution from META-INF/batch-jobs as a last resort.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4395</bug_id>
          
          <creation_ts>2012-12-05 22:09:00 +0000</creation_ts>
          <short_desc>PartitionPlan interface should match JSL attributes</short_desc>
          <delta_ts>2013-01-16 16:35:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>minor</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11781</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-12-05 22:09:33 +0000</bug_when>
    <thetext>The PartitionPlan interface method names should match the attribute names for a PartitionPlan JSL element for consistency. 

&lt;partition&gt;
   &lt;plan instances=&quot;3&quot; threads=&quot;2&quot;/&gt; ...

public void setPartitionCount(int count) ;

public void setThreadCount(int count) ;

public int getPartitionCount() ;

public int getThreadCount() ;

We can change the getters and setters to get/setInstances() and get/setThreads() or change the JSL attribute names to partitionCount and threadCount. Either way, they should match up.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11920</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-12-20 16:45:00 +0000</bug_when>
    <thetext>Will change method names.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4447</bug_id>
          
          <creation_ts>2012-12-20 19:46:00 +0000</creation_ts>
          <short_desc>Simplify the &apos;?:&apos; grammar and semantics (5.7)</short_desc>
          <delta_ts>2013-01-16 16:05:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>kmukher</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11923</commentid>
    <comment_count>0</comment_count>
    <who name="">kmukher</who>
    <bug_when>2012-12-20 19:46:07 +0000</bug_when>
    <thetext>Is the &apos;?:&apos; intended to operate against an entire value expression or just an operator expression. As the current grammar is written the &apos;?:&apos; operator can be associated with more than one property or value expression so it is unclear what to replace with the default value. Also, any part of the string after the &apos;?:&apos; is considered part of the default value since there is no end delimiter so it limits the use of the &apos;?:&apos; operator to once per attribute.

I think we need to define the semantics of what the &apos;?:&apos; operates on and in what conditions the default value is used. I propose using the grammar below which will disambiguate the current grammar:

&lt;attribute-value&gt; ::= &apos; &quot; &apos; &lt;value-expression&gt; &apos; &quot; &apos;
&lt;value-expression&gt; ::= &quot;#{&quot;&lt;operator-expression&gt;&quot;}&quot; [ &quot;?:&quot; &lt;value-expression&gt; &quot;;&quot;] | &lt;string-literal&gt; [ &lt;value-expression&gt; ]
&lt;operator-expression&gt; ::= &lt;operator1&gt; | &lt;operator2&gt; | &lt;operator3&gt; | &lt;operator4&gt;
&lt;operator1&gt; ::= &quot;jobParameters&quot; &quot;[&quot; &lt;single-quoted-string-literal&gt; &quot;]&quot;
&lt;operator2&gt; ::= &quot;jobProperties&quot; &quot;[&quot; &lt;single-quoted-string-literal&gt; &quot;]&quot;
&lt;operator3&gt; ::= &quot;systemProperties&quot; &quot;[&quot; &lt;single-quoted-string-literal&gt; &quot;]&quot;
&lt;operator4&gt; ::= &quot;partitionPlan&quot; &quot;[&quot; &lt;single-quoted-string-literal&gt; &quot;]&quot;
&lt;single-quoted-string-literal&gt; ::= &quot; &apos; &quot; &lt;string-literal&gt; &quot; &apos; &quot;
&lt;string-literal&gt; is a valid XML string value.

This grammar directly associates each &apos;?:&apos; with one property or &apos;#&apos;. It also includes an end delimiter of &apos;;&apos; to mark the end of the default value. This also simplifies the semantics of when to use the default value and exactly what gets replaced by having a one-to-one relationship. So we can say if a property resolves to &apos;null&apos; then we evaluate the expression between &apos;?:&apos; and &apos;;&apos; and associated with that property and default to the value of that expression.

This allows us to support cases like the one below where we only want to use the default value for the filename portion and not the entire path. And the spec doesn&apos;t have to define what happens in cases where only part of a value expression resolves or if we consider an expression resolved if there are there are string literals, etc...:

&quot;#{systemProperties[&apos;file.separator&apos;]}test#{systemProperties[&apos;file.separator&apos;]}#{jobParameters[&apos;myLogName&apos;]}?:#{jobParameters[&apos;defaultLogName&apos;]}-#{systemProperties[&apos;dateString&apos;]};.log</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12039</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-14 16:24:41 +0000</bug_when>
    <thetext>The syntax prescribed in this bug has been adopted into the proposed final draft of the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4458</bug_id>
          
          <creation_ts>2012-12-23 20:48:00 +0000</creation_ts>
          <short_desc>PartitionPlan interface should only have getters</short_desc>
          <delta_ts>2013-01-16 15:23:13 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11938</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2012-12-23 20:48:22 +0000</bug_when>
    <thetext>to let the possibility to have a clean immutable implementation of PartitionPlan. The aim of partition plan is to provide the partition count, the thread count and properties per partition to the batch runtime so there is no need to specify setters in the interface.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11953</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-02 19:46:19 +0000</bug_when>
    <thetext>The PartitionPlan is defined either declaratively (in job XML) or programmatically via a PartitionMapper.   The setter methods are necessary for the latter.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4474</bug_id>
          
          <creation_ts>2013-01-03 16:20:00 +0000</creation_ts>
          <short_desc>Clarify if reader/processor/writer are stateful (and so the same instance is used within a step).</short_desc>
          <delta_ts>2013-01-16 17:47:00 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Windows</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>ScottKurz</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>
    
    <cc>mminella</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11958</commentid>
    <comment_count>0</comment_count>
    <who name="">ScottKurz</who>
    <bug_when>2013-01-03 16:20:56 +0000</bug_when>
    <thetext>I&apos;ve been assuming that we use the same Item Reader instance in, for example, the sequence:

ItemReader.open
  // loop
  ItemReader.read()

So you could cache the cursor/index value in the reader instance.   Same for writer, processor, 

If this is the correct assumption, this should be explicitly spelled in the spec, and I&apos;ll leave it at that.  But if you think it&apos;s wrong I&apos;d question whether whatever pattern you end up with is a better programming model than a stateful one.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11959</commentid>
    <comment_count>1</comment_count>
    <who name="">mminella</who>
    <bug_when>2013-01-03 16:32:14 +0000</bug_when>
    <thetext>For the record, Spring Batch&apos;s ItemReader interface does not imply or require stateful or stateless behavior explicitly.  We have ItemReader implementations that are stateful (like the cursor one you describe) as well as stateless ones.  We would prefer that the decision of how to implement an ItemReader be left to the developers and not require stateful or stateless behavior from the spec.  Obviously stateful readers become an issue in a multithreaded environment...

In your specific example, I would expect that the same instance (stateful or not) be used within the scope of a step so that behavior would be ok, however I&apos;m sure Chris will confirm.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11960</commentid>
    <comment_count>2</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-03 16:45:27 +0000</bug_when>
    <thetext>I do not expect the spec should explicitly stipulate stateless vs stateful behavior for batch artifacts.  However, I do believe a developer needs to understand the lifecycle of a batch artifact.  I believe it appropriate to state in the spec that the lifecycle of a step-oriented batch artifact is life of step and that the lifecycle of a job-oriented batch artifact is life of job. 

That being said, a developer could expect, for instance, that an ItemReader is instantiated at start of step and that the same ItemReader instance is used throughout the step. It would follow that the same ItemReader type, if used in a subsequent step, would be a different instance.  If a developer wanted to exploit that lifecycle behavior for stateful purposes, that would be the developer&apos;s decision, but not in anyway required by the spec.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4497</bug_id>
          
          <creation_ts>2013-01-08 21:54:00 +0000</creation_ts>
          <short_desc>EE</short_desc>
          <delta_ts>2013-01-16 17:52:12 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Linux</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WONTFIX</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>geofjamg</reporter>
          <assigned_to>cvignola</assigned_to>
          <cc>issues</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11993</commentid>
    <comment_count>0</comment_count>
    <who name="">geofjamg</who>
    <bug_when>2013-01-08 21:54:42 +0000</bug_when>
    <thetext></thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>12014</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2013-01-11 17:28:27 +0000</bug_when>
    <thetext>I don&apos;t know what this bug is about since it includes no explanation.  So I am going to close it.  If there is something you would like to raise,  please open a new bug.  Thank you.</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4285</bug_id>
          
          <creation_ts>2012-11-09 21:51:00 +0000</creation_ts>
          <short_desc>Transaction Mode Property and Transaction Management SPI should be left to the implementations</short_desc>
          <delta_ts>2013-01-16 17:55:58 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>PC</rep_platform>
          <op_sys>Mac OS</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>FIXED</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>enhancement</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>mminella</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11493</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 21:51:55 +0000</bug_when>
    <thetext>While the spec should identify where the transactional boundaries exist, how those are implemented (how to configure things like timeout, the API for programatic transactions, etc) should be left up to the implementors.  This would mean the removal of sections 6.7.1 and 6.7.2.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11601</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 12:44:48 +0000</bug_when>
    <thetext>I am sympathetic to this argument.  However, I need some help:  what would we say about transaction boundaries in for the Java SE environment?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11654</commentid>
    <comment_count>2</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-11-21 18:17:58 +0000</bug_when>
    <thetext>The comments you added with the wording on #4282 might be sufficient. The implementation will have its own documentation on how to set up the local transactions.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11722</commentid>
    <comment_count>3</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-29 22:19:35 +0000</bug_when>
    <thetext>After further discussion with the EG,  we have decided to remove the mode and SPI. For  transactions,  I believe the spec will only address the following:

1) identify the transaction boundaries 
2) specify that XA (JTA) is used in Java EE
3) provide a way standard way to set the JTA transaction timeout through the Job XML</thetext>
  </long_desc>
      
      

    </bug>
    <bug>
          <bug_id>4287</bug_id>
          
          <creation_ts>2012-11-09 22:26:00 +0000</creation_ts>
          <short_desc>Stop processing is not correct</short_desc>
          <delta_ts>2012-12-06 16:24:48 +0000</delta_ts>
          <reporter_accessible>1</reporter_accessible>
          <cclist_accessible>1</cclist_accessible>
          <classification_id>1</classification_id>
          <classification>Unclassified</classification>
          <product>jbatch</product>
          <component>source</component>
          <version>1</version>
          <rep_platform>All</rep_platform>
          <op_sys>All</op_sys>
          <bug_status>CLOSED</bug_status>
          <resolution>WORKSFORME</resolution>
          
          
          <bug_file_loc></bug_file_loc>
          <status_whiteboard></status_whiteboard>
          <keywords></keywords>
          <priority>P5</priority>
          <bug_severity>normal</bug_severity>
          <target_milestone>---</target_milestone>
          
          
          <everconfirmed>1</everconfirmed>
          <reporter>mminella</reporter>
          <assigned_to>mminella</assigned_to>
          <cc>cvignola</cc>
    
    <cc>issues</cc>
    
    <cc>waynexlund</cc>

      

      

      

          <comment_sort_order>oldest_to_newest</comment_sort_order>  
          <long_desc isprivate="0" >
    <commentid>11495</commentid>
    <comment_count>0</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-09 22:26:42 +0000</bug_when>
    <thetext>Section 8.11 states that if a no-rollback exception occurs, retry up to the limit and roll back if still unsuccessful.  If the exception is marked as no-rollback, then the chunk should not be rolled back.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11588</commentid>
    <comment_count>1</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-19 11:36:40 +0000</bug_when>
    <thetext>So you are saying that an unsuccessful retry should result in commit?</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11653</commentid>
    <comment_count>2</comment_count>
    <who name="">waynexlund</who>
    <bug_when>2012-11-21 18:02:28 +0000</bug_when>
    <thetext>Sounds like we need to discuss this one next Monday but I think Michael is just pointing out that the behavior rollback is deferred to the listener, which by default is rollback but its not automatic with the exception.  Awaiting Michael&apos;s clarification.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11734</commentid>
    <comment_count>3</comment_count>
    <who name="">mminella</who>
    <bug_when>2012-11-30 15:36:14 +0000</bug_when>
    <thetext>You can close this issue.  After some digging, I&apos;m fine with how the spec is worded.</thetext>
  </long_desc><long_desc isprivate="0" >
    <commentid>11736</commentid>
    <comment_count>4</comment_count>
    <who name="">cvignola</who>
    <bug_when>2012-11-30 20:38:25 +0000</bug_when>
    <thetext>thanks, Michael</thetext>
  </long_desc>
      
      

    </bug>

</bugzilla>
